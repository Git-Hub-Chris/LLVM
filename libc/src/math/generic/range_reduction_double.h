//===-- Range reduction for double precision sin/cos/tan --------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_H
#define LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_H

#include "src/__support/FPUtil/FPBits.h"
#include "src/__support/FPUtil/double_double.h"
#include "src/__support/FPUtil/multiply_add.h"
#include "src/__support/FPUtil/nearest_integer.h"
#include "src/__support/common.h"

namespace LIBC_NAMESPACE {

using fputil::DoubleDouble;

LIBC_INLINE constexpr int FAST_PASS_EXPONENT = 23;

namespace generic {

// Digits of -pi/128, generated by Sollya with:
// > a = round(-pi/128, 25, RN);
// > b = round(-pi/128 - a, 23, RN);
// > c = round(-pi/128 - a - b, 25, RN);
// > d = round(-pi/128 - a - b - c, D, RN);
//   -pi/128 ~ a + b + c + d
// The precisions of the parts are chosen so that:
// 1)  k * a, k * b, k * c are exact in double precision
// 2)  k * b + (x - (k * a)) is exact in double precsion
LIBC_INLINE constexpr double MPI_OVER_128[4] = {
    -0x1.921fb5p-6, -0x1.110b48p-32, +0x1.ee59dap-56, -0x1.98a2e03707345p-83};

LIBC_INLINE unsigned range_reduction_small(double x, DoubleDouble &u) {
  constexpr double ONE_TWENTY_EIGHT_OVER_PI = 0x1.45f306dc9c883p5;

  double prod_hi = x * ONE_TWENTY_EIGHT_OVER_PI;
  double kd = fputil::nearest_integer(prod_hi);

  // With -pi/128 ~ a + b + c + d as in MPI_OVER_128 description:
  // t = x + k * a
  double t = fputil::multiply_add(kd, MPI_OVER_128[0], x); // Exact
  // y_hi = t + k * b = (x + k * a) + k * b
  double y_hi = fputil::multiply_add(kd, MPI_OVER_128[1], t); // Exact
  // y_lo ~ k * c + k * d
  double y_lo = fputil::multiply_add(kd, MPI_OVER_128[2], kd * MPI_OVER_128[3]);
  // u.hi + u.lo ~ x + k * (a + b + c + d)
  u = fputil::exact_add(y_hi, y_lo);
  // Error bound: For |x| < 2^-23,
  //  |(x mod pi/128) - (u_hi + u_lo)| <  ulp(y_lo)
  //                                   <= ulp(2 * x * c)
  //                                   <= ulp(2^24 * 2^-56)
  //                                   =  2^(24 - 56 - 52)
  //                                   =  2^-84
  return static_cast<unsigned>(static_cast<int>(kd));
}

// TODO: Implement generic's range_reduction_large correctly rounded for all
// rounding modes.  The current fma's range_reduction_large only works for
// round-to-nearest without FMA instruction.

} // namespace generic

} // namespace LIBC_NAMESPACE

#endif // LLVM_LIBC_SRC_MATH_GENERIC_RANGE_REDUCTION_DOUBLE_H
