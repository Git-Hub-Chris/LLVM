//===-- Half-precision sinpif function ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#include "src/math/sinpif16.h"
#include "src/__support/FPUtil/FEnvImpl.h"
#include "src/__support/FPUtil/FPBits.h"
#include "src/__support/FPUtil/PolyEval.h"
#include "src/__support/FPUtil/multiply_add.h"
#include "src/__support/FPUtil/nearest_integer.h"
#include "src/__support/common.h"
#include "src/__support/macros/config.h"

// TODO: Should probably create a new file; sincospif16_utils.h
// To store the following helper functions and constants.
// I'd defer to @lntue for suggestions regarding that

// HELPER_START
namespace LIBC_NAMESPACE_DECL {

constexpr float PI_OVER_32 = 0x1.921fb6p-4f;

// In Sollya generate 10 coeffecients for a degree-9 chebyshev polynomial
// approximating the sine function in [-pi / 32, pi / 32] with the following
// commands:
// > prec=24;
// > TL = chebyshevform(sin(x), 9, [-pi / 32, pi / 32]);
// > TL[0];
const float SIN_COEFF[10] = {
  0x1.d333p-26, 0x1.000048p0, -0x1.a5d2p-14, -0x1.628588p-3, 0x1.c1eep-5,
  0x1.4455p1, -0x1.317a8p3, -0x1.6bb9p8, 0x1.00ef8p9, 0x1.0edcp14
};
// In Sollya generate 10 coefficients for a degree-9 chebyshev polynomial
// approximating the sine function in [-pi/32, pi/32] with the following
// commands:
// > prec = 24;
// > TL = chebyshevform(cos(x), 9, [-pi / 32, pi / 32]);
// > TL[0];
const float COS_COEFF[10] = {
  0x1.000006p0, 0x1.e1eap-15, -0x1.0071p-1, -0x1.3b56p-4, 0x1.f3dfp-2,
  0x1.ccbap4, -0x1.3034p6, -0x1.f817p11, 0x1.fc59p11, 0x1.7079p17
};
// Lookup table for sin(k * pi / 32) with k = 0, ..., 63.
// Table is generated with Sollya as follows:
// > display = hexadecimmal;
// > prec = 24;
// > for k from 0 to 63 do {sin(k * pi/32);};

const float SIN_K_PI_OVER_32[64] = {
  0, 0x1.917a6cp-4,
  0x1.8f8b84p-3, 0x1.294062p-2,
  0x1.87de2ap-2, 0x1.e2b5d4p-2,
  0x1.1c73b4p-1, 0x1.44cf32p-1,
  0x1.6a09e6p-1, 0x1.8bc806p-1,
  0x1.a9b662p-1, 0x1.c38b3p-1,
  0x1.d906bcp-1, 0x1.e9f416p-1,
  0x1.f6297cp-1, 0x1.fd88dap-1,
  0x1p0, 0x1.fd88dap-1,
  0x1.f6297cp-1, 0x1.e9f416p-1,
  0x1.d906bcp-1, 0x1.c38b3p-1,
  0x1.a9b662p-1, 0x1.8bc806p-1,
  0x1.6a09e6p-1, 0x1.44cf32p-1,
  0x1.1c73b4p-1, 0x1.e2b5d4p-2,
  0x1.87de2ap-2, 0x1.294062p-2,
  0x1.8f8b84p-3, 0x1.917a6cp-4,
  0, -0x1.917a6cp-4,
  -0x1.8f8b84p-3, -0x1.294062p-2,
  -0x1.87de2ap-2, -0x1.e2b5d4p-2,
  -0x1.1c73b4p-1, -0x1.44cf32p-1,
  -0x1.6a09e6p-1, -0x1.8bc806p-1,
  -0x1.a9b662p-1, -0x1.c38b3p-1,
  -0x1.d906bcp-1, -0x1.e9f416p-1,
  -0x1.f6297ep-1, -0x1.fd88dap-1,
  -0x1p0, -0x1.fd88dap-1,
  -0x1.f6297cp-1, -0x1.e9f416p-1,
  -0x1.d906bcp-1, -0x1.c38b3p-1,
  -0x1.a9b662p-1, -0x1.8bc806p-1,
  -0x1.6a09e6p-1, -0x1.44cf32p-1,
  -0x1.1c73b4p-1, -0x1.e2b5d4p-2,
  -0x1.87de2ap-2, -0x1.294062p-2,
  -0x1.8f8b84p-3, -0x1.917a6cp-4
};

int32_t range_reduction(float x, float &y) {
  float kf = fputil::nearest_integer(x * 32);
  y = fputil::multiply_add<float>(x, 32.0, -kf);

  return static_cast<int32_t>(kf);
}
// HELPER_END

LLVM_LIBC_FUNCTION(float16, sinpif16, (float16 x)) {
  using FPBits = typename fputil::FPBits<float16>;
  FPBits xbits(x);

  uint16_t x_u = xbits.uintval();
  uint16_t x_abs = x_u & 0x7fff;

  // Range reduction:
  // For |x| > 1/32, we perform range reduction as follows:
  // Find k and y such that:
  //   x = (k + y) * 1/32
  //   k is an integer
  //   |y| < 0.5
  //
  // This is done by performing:
  //   k = round(x * 32)
  //   y = x * 32 - k
  //
  // Once k and y are computed, we then deduce the answer by the sine of sum
  // formula:
  //   sin(x * pi) = sin((k + y) * pi/32)
  //           = sin(k * pi/32) * cos(y * pi/32) + sin (y * pi/32) * cos (k *
  //           pi/32)
  // The values of sin(k * pi/32) and cos (k * pi/32) for k = 0...63 are
  // precomputed and stored using a vector of 64 single precision floats. sin(y
  // * pi/32) and cos(y * pi/32) are computed using degree-9 chebyshev
  // polynomials generated by Sollya.

  if (LIBC_UNLIKELY(x_abs == 0U)) {
    // For signed zeros
    return x;
  }

  // Numbers greater or equal to 2^10 are integers or NaN
  if (LIBC_UNLIKELY(x_abs >= 0x6400)) {
    // Check for NaN or infinity values
    if (LIBC_UNLIKELY(x_abs >= 0x7c00)) {
      // If value is equal to infinity
      if (x_abs == 0x7c00) {
        fputil::set_errno_if_required(EDOM);
	fputil::raise_except_if_required(FE_INVALID);
      }
      
      // If value is NaN
      return x + FPBits::quiet_nan().get_val();
    }
    return FPBits::zero(xbits.sign()).get_val();
  }

  float f32 = static_cast<float>(x);
  float y;
  int32_t k = range_reduction(f32, y);

  float sin_k = SIN_K_PI_OVER_32[k & 63];
  float cos_k = SIN_K_PI_OVER_32[(k + 16) & 63];

  float cos_y, sin_y;
  if (y == 0) {
    cos_y = 1;
    sin_y = 0;
  } else {
    cos_y = fputil::polyeval(y * PI_OVER_32,
	COS_COEFF[0], COS_COEFF[1],
	COS_COEFF[2], COS_COEFF[3],
	COS_COEFF[4], COS_COEFF[5],
	COS_COEFF[6], COS_COEFF[7],
	COS_COEFF[8], COS_COEFF[9]);
    sin_y = fputil::polyeval(y * PI_OVER_32,
        SIN_COEFF[0], SIN_COEFF[1],
	SIN_COEFF[2], SIN_COEFF[3],
	SIN_COEFF[4], SIN_COEFF[5],
	SIN_COEFF[6], SIN_COEFF[7],
	SIN_COEFF[8], SIN_COEFF[9]);
  }

  return static_cast<float16>(fputil::multiply_add(
      sin_k, cos_y, fputil::multiply_add(sin_y, cos_k, 0.0f)));
}
} // namespace LIBC_NAMESPACE_DECL
