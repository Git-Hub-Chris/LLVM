//===-- DILLexer.h ----------------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLDB_VALUEOBJECT_DILLEXER_H_
#define LLDB_VALUEOBJECT_DILLEXER_H_

#include <limits.h>

#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#include "llvm/ADT/StringRef.h"

namespace lldb_private {

namespace dil {

enum class TokenKind {
  coloncolon,
  eof,
  identifier,
  invalid,
  kw_namespace,
  kw_this,
  l_paren,
  none,
  r_paren,
  unknown,
};

/// Class defining the tokens generated by the DIL lexer and used by the
/// DIL parser.
class DILToken {
public:
  DILToken(dil::TokenKind kind, std::string spelling, uint32_t start,
           uint32_t len)
      : m_kind(kind), m_spelling(spelling), m_start_pos(start), m_length(len) {}

  DILToken()
      : m_kind(dil::TokenKind::none), m_spelling(""), m_start_pos(0),
        m_length(0) {}

  void setKind(dil::TokenKind kind) { m_kind = kind; }
  dil::TokenKind getKind() const { return m_kind; }

  std::string getSpelling() const { return m_spelling; }

  uint32_t getLength() const { return m_length; }

  bool is(dil::TokenKind kind) const { return m_kind == kind; }

  bool isNot(dil::TokenKind kind) const { return m_kind != kind; }

  bool isOneOf(dil::TokenKind kind1, dil::TokenKind kind2) const {
    return is(kind1) || is(kind2);
  }

  template <typename... Ts> bool isOneOf(dil::TokenKind kind, Ts... Ks) const {
    return is(kind) || isOneOf(Ks...);
  }

  uint32_t getLocation() const { return m_start_pos; }

  void setValues(dil::TokenKind kind, std::string spelling, uint32_t start,
                 uint32_t len) {
    m_kind = kind;
    m_spelling = spelling;
    m_start_pos = start;
    m_length = len;
  }

  static const std::string getTokenName(dil::TokenKind kind);

private:
  dil::TokenKind m_kind;
  std::string m_spelling;
  uint32_t m_start_pos; // within entire expression string
  uint32_t m_length;
};

/// Class for doing the simple lexing required by DIL.
class DILLexer {
public:
  DILLexer(std::shared_ptr<std::string> dil_sm) : m_expr(*dil_sm) {
    m_cur_pos = m_expr.begin();
    // Use UINT_MAX to indicate invalid/uninitialized value.
    m_tokens_idx = UINT_MAX;
  }

  bool Lex(DILToken &result, bool look_ahead = false);

  bool Is_Word(std::string::iterator start, uint32_t &length);

  uint32_t GetLocation() { return m_cur_pos - m_expr.begin(); }

  /// Update 'result' with the other paremeter values, create a
  /// duplicate token, and push the duplicate token onto the vector of
  /// lexed tokens.
  void UpdateLexedTokens(DILToken &result, dil::TokenKind tok_kind,
                         std::string tok_str, uint32_t tok_pos,
                         uint32_t tok_len);

  /// Return the lexed token N+1 positions ahead of the 'current' token
  /// being handled by the DIL parser.
  const DILToken &LookAhead(uint32_t N);

  const DILToken &AcceptLookAhead(uint32_t N);

  /// Return the index for the 'current' token being handled by the DIL parser.
  uint32_t GetCurrentTokenIdx() { return m_tokens_idx; }

  /// Return the current token to be handled by the DIL parser.
  DILToken &GetCurrentToken() { return m_lexed_tokens[m_tokens_idx]; }

  /// Update the index for the 'current' token, to point to the next lexed
  /// token.
  bool IncrementTokenIdx() {
    if (m_tokens_idx >= m_lexed_tokens.size() - 1)
      return false;

    m_tokens_idx++;
    return true;
  }

  /// Set the index for the 'current' token (to be handled by the parser)
  /// to a particular position. Used for either committing 'look ahead' parsing
  /// or rolling back tentative parsing.
  bool ResetTokenIdx(uint32_t new_value) {
    if (new_value > m_lexed_tokens.size() - 1)
      return false;

    m_tokens_idx = new_value;
    return true;
  }

private:
  // The input string we are lexing & parsing.
  std::string m_expr;

  // The current position of the lexer within m_expr (the character position,
  // within the string, of the next item to be lexed).
  std::string::iterator m_cur_pos;

  // Holds all of the tokens lexed so far.
  std::vector<DILToken> m_lexed_tokens;

  // Index into m_lexed_tokens; indicates which token the DIL parser is
  // currently trying to parse/handle.
  uint32_t m_tokens_idx;

  // "invalid" token; to be returned by lexer when 'look ahead' fails.
  DILToken m_invalid_token;
};

} // namespace dil

} // namespace lldb_private

#endif // LLDB_VALUEOBJECT_DILLEXER_H_
