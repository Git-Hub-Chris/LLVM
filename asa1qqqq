[1mdiff --git a/clang/lib/Sema/HLSLExternalSemaSource.cpp b/clang/lib/Sema/HLSLExternalSemaSource.cpp[m
[1mindex 6c93afdfaa81..e36bfeab7b49 100644[m
[1m--- a/clang/lib/Sema/HLSLExternalSemaSource.cpp[m
[1m+++ b/clang/lib/Sema/HLSLExternalSemaSource.cpp[m
[36m@@ -330,7 +330,7 @@[m [mstruct TemplateParameterListBuilder {[m
   // matches the CSE that is constructed when parsing the below C++ code:[m
   //[m
   // template<typename T>[m
[31m-  // concept is_typed_resource_element_compatible = sizeof(T) <= 16;[m
[32m+[m[32m  // concept is_typed_resource_element_compatible = __builtin_hlsl_typed_resource_element_compatible<T> && !__builtin_hlsl_is_intangible<T>[m
   // template<typename element_type> requires[m
   // is_typed_resource_element_compatible<element_type>[m
   // struct RWBuffer {[m
[36m@@ -568,11 +568,11 @@[m [mstatic BuiltinTypeDeclBuilder setupBufferType(CXXRecordDecl *Decl, Sema &S,[m
       .addDefaultHandleConstructor(S);[m
 }[m
 [m
[31m-BinaryOperator *constructSizeOfLEQ16Expr(ASTContext &Context,[m
[32m+[m[32mBinaryOperator *constructTypedResourceConstraintExpr(ASTContext &Context,[m
                                          SourceLocation NameLoc,[m
                                          TemplateTypeParmDecl *T) {[m
   // Obtain the QualType for 'unsigned long'[m
[31m-  QualType UnsignedLongType = Context.UnsignedLongTy;[m
[32m+[m[32m  QualType BoolTy = Context.BoolTy;[m
 [m
   // Create a QualType that points to this TemplateTypeParmDecl[m
   QualType TType = Context.getTypeDeclType(T);[m
[36m@@ -581,21 +581,22 @@[m [mBinaryOperator *constructSizeOfLEQ16Expr(ASTContext &Context,[m
   TypeSourceInfo *TTypeSourceInfo =[m
       Context.getTrivialTypeSourceInfo(TType, NameLoc);[m
 [m
[31m-  UnaryExprOrTypeTraitExpr *sizeOfExpr = new (Context) UnaryExprOrTypeTraitExpr([m
[31m-      UETT_SizeOf, TTypeSourceInfo, UnsignedLongType, NameLoc, NameLoc);[m
[32m+[m[32m  TypeTraitExpr *TypedResExpr = TypeTraitExpr::Create([m
[32m+[m[32m      Context, BoolTy, NameLoc, UTT_IsTypedResourceElementCompatible,[m
[32m+[m[32m      {TTypeSourceInfo}, NameLoc, true);[m
 [m
[31m-  // Create an IntegerLiteral for the value '16' with size type[m
[31m-  QualType SizeType = Context.getSizeType();[m
[31m-  llvm::APInt SizeValue = llvm::APInt(Context.getTypeSize(SizeType), 16);[m
[31m-  IntegerLiteral *SizeLiteral =[m
[31m-      new (Context) IntegerLiteral(Context, SizeValue, SizeType, NameLoc);[m
[32m+[m[32m  TypeTraitExpr *IsIntangibleExpr =[m
[32m+[m[32m      TypeTraitExpr::Create(Context, BoolTy, NameLoc, UTT_IsIntangibleType,[m
[32m+[m[32m      {TTypeSourceInfo}, NameLoc, true);[m
 [m
[31m-  QualType BoolTy = Context.BoolTy;[m
[32m+[m[32m  UnaryOperator *NotIntangibleExpr = UnaryOperator::Create([m
[32m+[m[32m      Context, IsIntangibleExpr, UO_Not, BoolTy, VK_LValue, OK_Ordinary,[m
[32m+[m[32m      NameLoc, false, FPOptionsOverride());[m
 [m
   BinaryOperator *binaryOperator =[m
[31m-      BinaryOperator::Create(Context, sizeOfExpr, // Left-hand side expression[m
[31m-                             SizeLiteral,         // Right-hand side expression[m
[31m-                             BO_LE,               // Binary operator kind (<=)[m
[32m+[m[32m      BinaryOperator::Create(Context, TypedResExpr, // Left-hand side expression[m
[32m+[m[32m                             NotIntangibleExpr,   // Right-hand side expression[m
[32m+[m[32m                             BO_LAnd,             // Binary operator kind (&&)[m
                              BoolTy,              // Result type (bool)[m
                              VK_LValue,           // Value kind[m
                              OK_Ordinary,         // Object kind[m
[36m@@ -609,13 +610,10 @@[m [mExpr *constructTypedBufferConstraintExpr(Sema &S, SourceLocation NameLoc,[m
                                          TemplateTypeParmDecl *T) {[m
   ASTContext &Context = S.getASTContext();[m
 [m
[31m-  // first get the "sizeof(T) <= 16" expression, as a binary operator[m
[31m-  BinaryOperator *SizeOfLEQ16 = constructSizeOfLEQ16Expr(Context, NameLoc, T);[m
[31m-  // TODO: add the 'builtin_hlsl_is_typed_resource_element_compatible' builtin[m
[31m-  // and return a binary operator that evaluates the builtin on the given[m
[31m-  // template type parameter 'T'.[m
[31m-  // Defined in issue https://github.com/llvm/llvm-project/issues/113223[m
[31m-  return SizeOfLEQ16;[m
[32m+[m[32m  BinaryOperator *TypedResourceConstraintExpr =[m
[32m+[m[32m      constructTypedResourceConstraintExpr(Context, NameLoc, T);[m
[32m+[m
[32m+[m[32m  return TypedResourceConstraintExpr;[m
 }[m
 [m
 ConceptDecl *constructTypedBufferConceptDecl(Sema &S, NamespaceDecl *NSD) {[m
[1mdiff --git a/clang/test/AST/HLSL/is_typed_resource_element_compatible_concept.hlsl b/clang/test/AST/HLSL/is_typed_resource_element_compatible_concept.hlsl[m
[1mindex 414ed6eb8212..362ce96e808f 100644[m
[1m--- a/clang/test/AST/HLSL/is_typed_resource_element_compatible_concept.hlsl[m
[1m+++ b/clang/test/AST/HLSL/is_typed_resource_element_compatible_concept.hlsl[m
[36m@@ -2,9 +2,13 @@[m
 [m
 // CHECK: ConceptDecl 0x{{[0-9a-f]+}} <<invalid sloc>> <invalid sloc> __is_typed_resource_element_compatible[m
 // CHECK: |-TemplateTypeParmDecl 0x{{[0-9a-f]+}} <<invalid sloc>> <invalid sloc> referenced typename depth 0 index 0 element_type[m
[31m-// CHECK: `-BinaryOperator 0x{{[0-9a-f]+}} <<invalid sloc>> 'bool' lvalue '<='[m
[31m-// CHECK:   |-UnaryExprOrTypeTraitExpr 0x{{[0-9a-f]+}} <<invalid sloc>> 'unsigned long' sizeof 'element_type'[m
[31m-// CHECK:   `-IntegerLiteral 0x{{[0-9a-f]+}} <<invalid sloc>> 'unsigned long' 16[m
[31m-[m
[32m+[m[32m// CHECK: `-BinaryOperator 0x{{[0-9a-f]+}} <<invalid sloc>> 'bool' lvalue '&&'[m[41m[m
[32m+[m[32m// CHECK:   |-TypeTraitExpr 0x{{[0-9a-f]+}} <<invalid sloc>> 'bool' __builtin_hlsl_is_typed_resource_element_compatible[m[41m[m
[32m+[m[32m// CHECK:   `-TemplateTypeParmType 0x{{[0-9a-f]+}} 'element_type' dependent depth 0 index 0[m[41m[m
[32m+[m[32m// CHECK:     `-TemplateTypeParm 0x{{[0-9a-f]+}} 'element_type'[m[41m[m
[32m+[m[32m// CHECK:  `-UnaryOperator 0x{{[0-9a-f]+}} <<invalid sloc>> 'bool' lvalue prefix '~' cannot overflow[m[41m[m
[32m+[m[32m// CHECK:    `-TypeTraitExpr 0x{{[0-9a-f]+}} <<invalid sloc>> 'bool' __builtin_hlsl_is_intangible[m[41m[m
[32m+[m[32m// CHECK:      `-TemplateTypeParmType 0x{{[0-9a-f]+}} 'element_type' dependent depth 0 index 0[m[41m[m
[32m+[m[32m// CHECK:        `-TemplateTypeParm 0x{{[0-9a-f]+}} 'element_type'[m[41m[m
 [m
 RWBuffer<float> Buffer;[m
[1mdiff --git a/clang/test/SemaHLSL/BuiltIns/RWBuffers.hlsl b/clang/test/SemaHLSL/BuiltIns/RWBuffers.hlsl[m
[1mindex 438f8021f96a..8d018bacea7f 100644[m
[1m--- a/clang/test/SemaHLSL/BuiltIns/RWBuffers.hlsl[m
[1m+++ b/clang/test/SemaHLSL/BuiltIns/RWBuffers.hlsl[m
[36m@@ -1,16 +1,79 @@[m
 // RUN: %clang_cc1 -triple dxil-pc-shadermodel6.0-compute -x hlsl -fsyntax-only -verify %s[m
 [m
 typedef vector<float, 3> float3;[m
[32m+[m[32mtypedef vector<double, 2> double2;[m
[32m+[m[32mtypedef vector<double, 3> double3;[m
 [m
[31m-RWBuffer<float3> Buffer;[m
 [m
[31m-// expected-error@+2 {{class template 'RWBuffer' requires template arguments}}[m
[31m-// expected-note@*:* {{template declaration from hidden source: template <typename element_type> requires __is_typed_resource_element_compatible<element_type> class RWBuffer {}}}[m
[31m-RWBuffer BufferErr1;[m
[32m+[m[32m// expected-error@+4 {{constraints not satisfied for class template 'RWBuffer'}}[m
[32m+[m[32m// expected-note@*:* {{template declaration from hidden source: template <typename element_type> requires __is_typed_resource_element_compatible<element_type> class RWBuffer}}[m
[32m+[m[32m// expected-note@*:* {{because 'hlsl::RWBuffer<int>' does not satisfy '__is_typed_resource_element_compatible'}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(hlsl::RWBuffer<int>)' evaluated to false}}[m
[32m+[m[32mRWBuffer<RWBuffer<int> > r5;[m
[32m+[m
[32m+[m[32mstruct s {[m
[32m+[m[32m    int x;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct Empty {};[m
[32m+[m
[32m+[m[32mtemplate<typename T> struct TemplatedBuffer {[m
[32m+[m[32m    T a;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mtemplate<typename T> struct TemplatedVector {[m
[32m+[m[32m    vector<T, 4> v;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m
[32m+[m[32m// expected-error@+4 {{constraints not satisfied for class template 'RWBuffer'}}[m
[32m+[m[32m// expected-note@*:* {{template declaration from hidden source: template <typename element_type> requires __is_typed_resource_element_compatible<element_type> class RWBuffer}}[m
[32m+[m[32m// expected-note@*:* {{because 'TemplatedBuffer<int>' does not satisfy '__is_typed_resource_element_compatible'}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(TemplatedBuffer<int>)' evaluated to false}}[m
[32m+[m[32mRWBuffer<TemplatedBuffer<int> > r8;[m
[32m+[m[32m// expected-error@+4 {{constraints not satisfied for class template 'RWBuffer'}}[m
[32m+[m[32m// expected-note@*:* {{template declaration from hidden source: template <typename element_type> requires __is_typed_resource_element_compatible<element_type> class RWBuffer}}[m
[32m+[m[32m// expected-note@*:* {{because 'TemplatedVector<int>' does not satisfy '__is_typed_resource_element_compatible'}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(TemplatedVector<int>)' evaluated to false}}[m
[32m+[m[32mRWBuffer<TemplatedVector<int> > r9;[m
[32m+[m
[32m+[m[32m// arrays not allowed[m
[32m+[m[32m// expected-error@+3 {{constraints not satisfied for class template 'RWBuffer'}}[m
[32m+[m[32m// expected-note@*:* {{because 'half[4]' does not satisfy '__is_typed_resource_element_compatible'}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(__fp16[4])' evaluated to false}}[m
[32m+[m[32mRWBuffer<half[4]> r10;[m
[32m+[m
[32m+[m[32mtypedef vector<int, 8> int8;[m
[32m+[m[32m// expected-error@+3 {{constraints not satisfied for class template 'RWBuffer'}}[m
[32m+[m[32m// expected-note@*:* {{because 'vector<int, 8>' (vector of 8 'int' values) does not satisfy '__is_typed_resource_element_compatible'}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(int __attribute__((ext_vector_type(8))))' evaluated to false}}[m
[32m+[m[32mRWBuffer<int8> r11;[m
[32m+[m
[32m+[m[32mtypedef int MyInt;[m
[32m+[m[32mRWBuffer<MyInt> r12;[m
[32m+[m
[32m+[m[32m// expected-error@+3 {{constraints not satisfied for class template 'RWBuffer'}}[m
[32m+[m[32m// expected-note@*:* {{because 'bool' does not satisfy '__is_typed_resource_element_compatible'}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(_Bool)' evaluated to false}}[m
[32m+[m[32mRWBuffer<bool> r13;[m
[32m+[m
[32m+[m[32m// expected-error@+3 {{constraints not satisfied for class template 'RWBuffer'}}[m
[32m+[m[32m// expected-note@*:* {{because 'vector<bool, 2>' (vector of 2 'bool' values) does not satisfy '__is_typed_resource_element_compatible'}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(_Bool __attribute__((ext_vector_type(2))))' evaluated to false}}[m
[32m+[m[32mRWBuffer<vector<bool, 2>> r14;[m
[32m+[m
[32m+[m[32menum numbers { one, two, three };[m
[32m+[m
[32m+[m[32m// expected-error@+3 {{constraints not satisfied for class template 'RWBuffer'}}[m
[32m+[m[32m// expected-note@*:* {{because 'numbers' does not satisfy '__is_typed_resource_element_compatible'}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(numbers)' evaluated to false}}[m
[32m+[m[32mRWBuffer<numbers> r15;[m
[32m+[m
[32m+[m[32m// expected-error@+3 {{constraints not satisfied for class template 'RWBuffer'}}[m
[32m+[m[32m// expected-note@*:* {{because 'vector<double, 3>' (vector of 3 'double' values) does not satisfy '__is_typed_resource_element_compatible'}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(double __attribute__((ext_vector_type(3))))' evaluated to false}}[m
[32m+[m[32mRWBuffer<double3> r16;[m
 [m
[31m-// expected-error@+2 {{too few template arguments for class template 'RWBuffer'}}[m
[31m-// expected-note@*:* {{template declaration from hidden source: template <typename element_type> requires __is_typed_resource_element_compatible<element_type> class RWBuffer {}}}[m
[31m-RWBuffer<> BufferErr2;[m
 [m
 struct threeDoubles {[m
   double a;[m
[36m@@ -20,7 +83,7 @@[m [mstruct threeDoubles {[m
 [m
 // expected-error@+3 {{constraints not satisfied for class template 'RWBuffer'}}[m
 // expected-note@*:* {{because 'threeDoubles' does not satisfy '__is_typed_resource_element_compatible'}}[m
[31m-// expected-note@*:* {{because 'sizeof(threeDoubles) <= 16UL' (24 <= 16) evaluated to false}}[m
[32m+[m[32m// expected-note@*:* {{because '__builtin_hlsl_is_typed_resource_element_compatible(threeDoubles)' evaluated to false}}[m
 RWBuffer<threeDoubles> BufferErr3;[m
 [m
 [m
[1mdiff --git a/clang/test/SemaHLSL/Types/Traits/IsTypedResourceElementCompatibleErrors.hlsl b/clang/test/SemaHLSL/Types/Traits/IsTypedResourceElementCompatibleErrors.hlsl[m
[1mindex d3d79aa0499e..cb3e9ae7a615 100644[m
[1m--- a/clang/test/SemaHLSL/Types/Traits/IsTypedResourceElementCompatibleErrors.hlsl[m
[1m+++ b/clang/test/SemaHLSL/Types/Traits/IsTypedResourceElementCompatibleErrors.hlsl[m
[36m@@ -1,9 +1,10 @@[m
 // RUN: %clang_cc1 -triple dxil-pc-shadermodel6.6-library -finclude-default-header -fnative-half-type -verify %s[m
 [m
 // types must be complete[m
[31m-_Static_assert(!__builtin_hlsl_is_typed_resource_element_compatible(__hlsl_resource_t), "");[m
[32m+[m[32m_Static_assert(__builtin_hlsl_is_typed_resource_element_compatible(__hlsl_resource_t), "");[m[41m[m
 [m
 // expected-note@+1{{forward declaration of 'notComplete'}}[m
 struct notComplete;[m
 // expected-error@+1{{incomplete type 'notComplete' where a complete type is required}}[m
 _Static_assert(!__builtin_hlsl_is_typed_resource_element_compatible(notComplete), "");[m
[41m+ [m
