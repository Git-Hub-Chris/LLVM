// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature

// Simple calls to known variadic functions that are completely elided when optimisations are on
// This is a functional check that the expand-variadic pass is consistent with clang's va_arg handling

// -Wno-varargs avoids warning second argument to 'va_start' is not the last named parameter

// RUN: %clang_cc1 -triple aarch64-linux-gnu -Wno-varargs -O1 -emit-llvm -o - %s |  FileCheck %s

// RUN: %clang_cc1 -triple wasm32-unknown-unknown -Wno-varargs -O1 -emit-llvm -o - %s |  FileCheck %s

// x64 needs O2 to remove the extra SROA layer
// RUN: %clang_cc1 -triple x86_64-linux-gnu -Wno-varargs -O2 -emit-llvm -o - %s |  FileCheck %s


#include <stdarg.h>
#include <stdint.h>

template <typename X, typename Y>
static X first(...) {
  va_list va;
  __builtin_va_start(va, 0);
  X r = va_arg(va, X);
  va_end(va);
  return r;
}

template <typename X, typename Y>
static Y second(...) {
  va_list va;
  __builtin_va_start(va, 0);
  va_arg(va, X);
  Y r = va_arg(va, Y);
  va_end(va);
  return r;
}


extern "C"
{

// CHECK-LABEL: define {{[^@]+}}@first_pair_i32
// CHECK-SAME: (i32 noundef returned [[X:%.*]], i32 noundef [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[X]]
//
int first_pair_i32(int x, int y)
{
  return first<int,int>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@second_pair_i32
// CHECK-SAME: (i32 noundef [[X:%.*]], i32 noundef returned [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[Y]]
//
int second_pair_i32(int x, int y)
{
  return second<int,int>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@first_pair_f64
// CHECK-SAME: (double noundef returned [[X:%.*]], double noundef [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret double [[X]]
//
double first_pair_f64(double x, double y)
{
  return first<double,double>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@second_pair_f64
// CHECK-SAME: (double noundef [[X:%.*]], double noundef returned [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret double [[Y]]
//
double second_pair_f64(double x, double y)
{
  return second<double,double>(x, y);
}

}



extern "C"
{
// CHECK-LABEL: define {{[^@]+}}@first_i32_f64
// CHECK-SAME: (i32 noundef returned [[X:%.*]], double noundef [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[X]]
//
int first_i32_f64(int x, double y)
{
  return first<int,double>(x, y);
}


// CHECK-LABEL: define {{[^@]+}}@second_i32_f64
// CHECK-SAME: (i32 noundef [[X:%.*]], double noundef returned [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret double [[Y]]
//
double second_i32_f64(int x, double y)
{
  return second<int,double>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@first_f64_i32
// CHECK-SAME: (double noundef returned [[X:%.*]], i32 noundef [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret double [[X]]
//
double first_f64_i32(double x, int y)
{
  return first<double,int>(x, y);
}

// CHECK-LABEL: define {{[^@]+}}@second_f64_i32
// CHECK-SAME: (double noundef [[X:%.*]], i32 noundef returned [[Y:%.*]])
// CHECK-LABEL:{{.}}:
// CHECK-NEXT:    ret i32 [[Y]]
//
int second_f64_i32(double x, int y)
{
  return second<double,int>(x, y);
}
}
