// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -triple arm64-none-linux-gnu -target-feature +neon -target-cpu cyclone \
// RUN: -disable-O0-optnone -emit-llvm -o - %s | opt -S -passes=mem2reg,instcombine \
// RUN: | FileCheck --check-prefix=UNCONSTRAINED %s
// RUN: %clang_cc1 -triple arm64-none-linux-gnu -target-feature +neon -target-cpu cyclone \
// RUN: -ffp-exception-behavior=strict \
// RUN: -disable-O0-optnone -emit-llvm -o - %s | opt -S -passes=mem2reg,instcombine \
// RUN: | FileCheck --check-prefix=CONSTRAINED %s

// REQUIRES: aarch64-registered-target

// Test new aarch64 intrinsics and types but constrained

#include <arm_neon.h>

// UNCONSTRAINED-LABEL: define dso_local float @test_vfmas_lane_f32(
// UNCONSTRAINED-SAME: float noundef [[A:%.*]], float noundef [[B:%.*]], <2 x float> noundef [[C:%.*]]) #[[ATTR0:[0-9]+]] {
// UNCONSTRAINED-NEXT:  [[ENTRY:.*:]]
// UNCONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x float> [[C]], i64 1
// UNCONSTRAINED-NEXT:    [[TMP0:%.*]] = call float @llvm.fma.f32(float [[B]], float [[EXTRACT]], float [[A]])
// UNCONSTRAINED-NEXT:    ret float [[TMP0]]
//
// CONSTRAINED-LABEL: define dso_local float @test_vfmas_lane_f32(
// CONSTRAINED-SAME: float noundef [[A:%.*]], float noundef [[B:%.*]], <2 x float> noundef [[C:%.*]]) #[[ATTR0:[0-9]+]] {
// CONSTRAINED-NEXT:  [[ENTRY:.*:]]
// CONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x float> [[C]], i64 1
// CONSTRAINED-NEXT:    [[TMP0:%.*]] = call float @llvm.experimental.constrained.fma.f32(float [[B]], float [[EXTRACT]], float [[A]], metadata !"round.tonearest", metadata !"fpexcept.strict") #[[ATTR2:[0-9]+]]
// CONSTRAINED-NEXT:    ret float [[TMP0]]
//
float32_t test_vfmas_lane_f32(float32_t a, float32_t b, float32x2_t c) {
  return vfmas_lane_f32(a, b, c, 1);
}

// UNCONSTRAINED-LABEL: define dso_local double @test_vfmad_lane_f64(
// UNCONSTRAINED-SAME: double noundef [[A:%.*]], double noundef [[B:%.*]], <1 x double> noundef [[C:%.*]]) #[[ATTR0]] {
// UNCONSTRAINED-NEXT:  [[ENTRY:.*:]]
// UNCONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <1 x double> [[C]], i64 0
// UNCONSTRAINED-NEXT:    [[TMP0:%.*]] = call double @llvm.fma.f64(double [[B]], double [[EXTRACT]], double [[A]])
// UNCONSTRAINED-NEXT:    ret double [[TMP0]]
//
// CONSTRAINED-LABEL: define dso_local double @test_vfmad_lane_f64(
// CONSTRAINED-SAME: double noundef [[A:%.*]], double noundef [[B:%.*]], <1 x double> noundef [[C:%.*]]) #[[ATTR0]] {
// CONSTRAINED-NEXT:  [[ENTRY:.*:]]
// CONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <1 x double> [[C]], i64 0
// CONSTRAINED-NEXT:    [[TMP0:%.*]] = call double @llvm.experimental.constrained.fma.f64(double [[B]], double [[EXTRACT]], double [[A]], metadata !"round.tonearest", metadata !"fpexcept.strict") #[[ATTR2]]
// CONSTRAINED-NEXT:    ret double [[TMP0]]
//
float64_t test_vfmad_lane_f64(float64_t a, float64_t b, float64x1_t c) {
  return vfmad_lane_f64(a, b, c, 0);
}

// UNCONSTRAINED-LABEL: define dso_local double @test_vfmad_laneq_f64(
// UNCONSTRAINED-SAME: double noundef [[A:%.*]], double noundef [[B:%.*]], <2 x double> noundef [[C:%.*]]) #[[ATTR0]] {
// UNCONSTRAINED-NEXT:  [[ENTRY:.*:]]
// UNCONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x double> [[C]], i64 1
// UNCONSTRAINED-NEXT:    [[TMP0:%.*]] = call double @llvm.fma.f64(double [[B]], double [[EXTRACT]], double [[A]])
// UNCONSTRAINED-NEXT:    ret double [[TMP0]]
//
// CONSTRAINED-LABEL: define dso_local double @test_vfmad_laneq_f64(
// CONSTRAINED-SAME: double noundef [[A:%.*]], double noundef [[B:%.*]], <2 x double> noundef [[C:%.*]]) #[[ATTR0]] {
// CONSTRAINED-NEXT:  [[ENTRY:.*:]]
// CONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x double> [[C]], i64 1
// CONSTRAINED-NEXT:    [[TMP0:%.*]] = call double @llvm.experimental.constrained.fma.f64(double [[B]], double [[EXTRACT]], double [[A]], metadata !"round.tonearest", metadata !"fpexcept.strict") #[[ATTR2]]
// CONSTRAINED-NEXT:    ret double [[TMP0]]
//
float64_t test_vfmad_laneq_f64(float64_t a, float64_t b, float64x2_t c) {
  return vfmad_laneq_f64(a, b, c, 1);
}

// UNCONSTRAINED-LABEL: define dso_local float @test_vfmss_lane_f32(
// UNCONSTRAINED-SAME: float noundef [[A:%.*]], float noundef [[B:%.*]], <2 x float> noundef [[C:%.*]]) #[[ATTR0]] {
// UNCONSTRAINED-NEXT:  [[ENTRY:.*:]]
// UNCONSTRAINED-NEXT:    [[FNEG:%.*]] = fneg float [[B]]
// UNCONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x float> [[C]], i64 1
// UNCONSTRAINED-NEXT:    [[TMP0:%.*]] = call float @llvm.fma.f32(float [[FNEG]], float [[EXTRACT]], float [[A]])
// UNCONSTRAINED-NEXT:    ret float [[TMP0]]
//
// CONSTRAINED-LABEL: define dso_local float @test_vfmss_lane_f32(
// CONSTRAINED-SAME: float noundef [[A:%.*]], float noundef [[B:%.*]], <2 x float> noundef [[C:%.*]]) #[[ATTR0]] {
// CONSTRAINED-NEXT:  [[ENTRY:.*:]]
// CONSTRAINED-NEXT:    [[FNEG:%.*]] = fneg float [[B]]
// CONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x float> [[C]], i64 1
// CONSTRAINED-NEXT:    [[TMP0:%.*]] = call float @llvm.experimental.constrained.fma.f32(float [[FNEG]], float [[EXTRACT]], float [[A]], metadata !"round.tonearest", metadata !"fpexcept.strict") #[[ATTR2]]
// CONSTRAINED-NEXT:    ret float [[TMP0]]
//
float32_t test_vfmss_lane_f32(float32_t a, float32_t b, float32x2_t c) {
  return vfmss_lane_f32(a, b, c, 1);
}

// UNCONSTRAINED-LABEL: define dso_local <1 x double> @test_vfma_lane_f64(
// UNCONSTRAINED-SAME: <1 x double> noundef [[A:%.*]], <1 x double> noundef [[B:%.*]], <1 x double> noundef [[V:%.*]]) #[[ATTR0]] {
// UNCONSTRAINED-NEXT:  [[ENTRY:.*:]]
// UNCONSTRAINED-NEXT:    [[FMLA2:%.*]] = call <1 x double> @llvm.fma.v1f64(<1 x double> [[B]], <1 x double> [[V]], <1 x double> [[A]])
// UNCONSTRAINED-NEXT:    ret <1 x double> [[FMLA2]]
//
// CONSTRAINED-LABEL: define dso_local <1 x double> @test_vfma_lane_f64(
// CONSTRAINED-SAME: <1 x double> noundef [[A:%.*]], <1 x double> noundef [[B:%.*]], <1 x double> noundef [[V:%.*]]) #[[ATTR0]] {
// CONSTRAINED-NEXT:  [[ENTRY:.*:]]
// CONSTRAINED-NEXT:    [[FMLA2:%.*]] = call <1 x double> @llvm.experimental.constrained.fma.v1f64(<1 x double> [[B]], <1 x double> [[V]], <1 x double> [[A]], metadata !"round.tonearest", metadata !"fpexcept.strict") #[[ATTR2]]
// CONSTRAINED-NEXT:    ret <1 x double> [[FMLA2]]
//
float64x1_t test_vfma_lane_f64(float64x1_t a, float64x1_t b, float64x1_t v) {
  return vfma_lane_f64(a, b, v, 0);
}


// UNCONSTRAINED-LABEL: define dso_local <1 x double> @test_vfms_lane_f64(
// UNCONSTRAINED-SAME: <1 x double> noundef [[A:%.*]], <1 x double> noundef [[B:%.*]], <1 x double> noundef [[V:%.*]]) #[[ATTR0]] {
// UNCONSTRAINED-NEXT:  [[ENTRY:.*:]]
// UNCONSTRAINED-NEXT:    [[FNEG:%.*]] = fneg <1 x double> [[B]]
// UNCONSTRAINED-NEXT:    [[FMLA2:%.*]] = call <1 x double> @llvm.fma.v1f64(<1 x double> [[FNEG]], <1 x double> [[V]], <1 x double> [[A]])
// UNCONSTRAINED-NEXT:    ret <1 x double> [[FMLA2]]
//
// CONSTRAINED-LABEL: define dso_local <1 x double> @test_vfms_lane_f64(
// CONSTRAINED-SAME: <1 x double> noundef [[A:%.*]], <1 x double> noundef [[B:%.*]], <1 x double> noundef [[V:%.*]]) #[[ATTR0]] {
// CONSTRAINED-NEXT:  [[ENTRY:.*:]]
// CONSTRAINED-NEXT:    [[FNEG:%.*]] = fneg <1 x double> [[B]]
// CONSTRAINED-NEXT:    [[FMLA2:%.*]] = call <1 x double> @llvm.experimental.constrained.fma.v1f64(<1 x double> [[FNEG]], <1 x double> [[V]], <1 x double> [[A]], metadata !"round.tonearest", metadata !"fpexcept.strict") #[[ATTR2]]
// CONSTRAINED-NEXT:    ret <1 x double> [[FMLA2]]
//
float64x1_t test_vfms_lane_f64(float64x1_t a, float64x1_t b, float64x1_t v) {
  return vfms_lane_f64(a, b, v, 0);
}


// UNCONSTRAINED-LABEL: define dso_local <1 x double> @test_vfma_laneq_f64(
// UNCONSTRAINED-SAME: <1 x double> noundef [[A:%.*]], <1 x double> noundef [[B:%.*]], <2 x double> noundef [[V:%.*]]) #[[ATTR0]] {
// UNCONSTRAINED-NEXT:  [[ENTRY:.*:]]
// UNCONSTRAINED-NEXT:    [[TMP0:%.*]] = extractelement <1 x double> [[A]], i64 0
// UNCONSTRAINED-NEXT:    [[TMP1:%.*]] = extractelement <1 x double> [[B]], i64 0
// UNCONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x double> [[V]], i64 0
// UNCONSTRAINED-NEXT:    [[TMP2:%.*]] = call double @llvm.fma.f64(double [[TMP1]], double [[EXTRACT]], double [[TMP0]])
// UNCONSTRAINED-NEXT:    [[TMP3:%.*]] = bitcast double [[TMP2]] to <1 x double>
// UNCONSTRAINED-NEXT:    ret <1 x double> [[TMP3]]
//
// CONSTRAINED-LABEL: define dso_local <1 x double> @test_vfma_laneq_f64(
// CONSTRAINED-SAME: <1 x double> noundef [[A:%.*]], <1 x double> noundef [[B:%.*]], <2 x double> noundef [[V:%.*]]) #[[ATTR0]] {
// CONSTRAINED-NEXT:  [[ENTRY:.*:]]
// CONSTRAINED-NEXT:    [[TMP0:%.*]] = extractelement <1 x double> [[A]], i64 0
// CONSTRAINED-NEXT:    [[TMP1:%.*]] = extractelement <1 x double> [[B]], i64 0
// CONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x double> [[V]], i64 0
// CONSTRAINED-NEXT:    [[TMP2:%.*]] = call double @llvm.experimental.constrained.fma.f64(double [[TMP1]], double [[EXTRACT]], double [[TMP0]], metadata !"round.tonearest", metadata !"fpexcept.strict") #[[ATTR2]]
// CONSTRAINED-NEXT:    [[TMP3:%.*]] = bitcast double [[TMP2]] to <1 x double>
// CONSTRAINED-NEXT:    ret <1 x double> [[TMP3]]
//
float64x1_t test_vfma_laneq_f64(float64x1_t a, float64x1_t b, float64x2_t v) {
  return vfma_laneq_f64(a, b, v, 0);
}

// UNCONSTRAINED-LABEL: define dso_local <1 x double> @test_vfms_laneq_f64(
// UNCONSTRAINED-SAME: <1 x double> noundef [[A:%.*]], <1 x double> noundef [[B:%.*]], <2 x double> noundef [[V:%.*]]) #[[ATTR0]] {
// UNCONSTRAINED-NEXT:  [[ENTRY:.*:]]
// UNCONSTRAINED-NEXT:    [[TMP0:%.*]] = extractelement <1 x double> [[A]], i64 0
// UNCONSTRAINED-NEXT:    [[TMP1:%.*]] = extractelement <1 x double> [[B]], i64 0
// UNCONSTRAINED-NEXT:    [[TMP2:%.*]] = fneg double [[TMP1]]
// UNCONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x double> [[V]], i64 0
// UNCONSTRAINED-NEXT:    [[TMP3:%.*]] = call double @llvm.fma.f64(double [[TMP2]], double [[EXTRACT]], double [[TMP0]])
// UNCONSTRAINED-NEXT:    [[TMP4:%.*]] = bitcast double [[TMP3]] to <1 x double>
// UNCONSTRAINED-NEXT:    ret <1 x double> [[TMP4]]
//
// CONSTRAINED-LABEL: define dso_local <1 x double> @test_vfms_laneq_f64(
// CONSTRAINED-SAME: <1 x double> noundef [[A:%.*]], <1 x double> noundef [[B:%.*]], <2 x double> noundef [[V:%.*]]) #[[ATTR0]] {
// CONSTRAINED-NEXT:  [[ENTRY:.*:]]
// CONSTRAINED-NEXT:    [[TMP0:%.*]] = extractelement <1 x double> [[A]], i64 0
// CONSTRAINED-NEXT:    [[TMP1:%.*]] = extractelement <1 x double> [[B]], i64 0
// CONSTRAINED-NEXT:    [[TMP2:%.*]] = fneg double [[TMP1]]
// CONSTRAINED-NEXT:    [[EXTRACT:%.*]] = extractelement <2 x double> [[V]], i64 0
// CONSTRAINED-NEXT:    [[TMP3:%.*]] = call double @llvm.experimental.constrained.fma.f64(double [[TMP2]], double [[EXTRACT]], double [[TMP0]], metadata !"round.tonearest", metadata !"fpexcept.strict") #[[ATTR2]]
// CONSTRAINED-NEXT:    [[TMP4:%.*]] = bitcast double [[TMP3]] to <1 x double>
// CONSTRAINED-NEXT:    ret <1 x double> [[TMP4]]
//
float64x1_t test_vfms_laneq_f64(float64x1_t a, float64x1_t b, float64x2_t v) {
  return vfms_laneq_f64(a, b, v, 0);
}
