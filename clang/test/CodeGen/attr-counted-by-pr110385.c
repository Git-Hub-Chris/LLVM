// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 4
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -Wno-missing-declarations -emit-llvm -o - %s | FileCheck %s

// See #110385
// Based on reproducer from Kees Cook:
// https://lore.kernel.org/all/202409170436.C3C6E7F7A@keescook/

struct variable {
        int a;
        int b;
        int length;
        short array[] __attribute__((counted_by(length)));
};

struct bucket {
        int a;
        struct variable *growable;
        int b;
};

struct bucket2 {
        int a;
        struct variable growable;
};

void init(void * __attribute__((pass_dynamic_object_size(0))));

// CHECK-LABEL: define dso_local void @test1(
// CHECK-SAME: ptr noundef [[FOO:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FOO_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[FOO]], ptr [[FOO_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[FOO_ADDR]], align 8
// CHECK-NEXT:    [[GROWABLE:%.*]] = getelementptr inbounds nuw [[STRUCT_BUCKET:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[GROWABLE]], align 8
// CHECK-NEXT:    [[ARRAY:%.*]] = getelementptr inbounds nuw [[STRUCT_VARIABLE:%.*]], ptr [[TMP1]], i32 0, i32 3
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [0 x i16], ptr [[ARRAY]], i64 0, i64 0
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[FOO_ADDR]], align 8
// CHECK-NEXT:    [[GROWABLE1:%.*]] = getelementptr inbounds nuw [[STRUCT_BUCKET]], ptr [[TMP2]], i32 0, i32 1
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[GROWABLE1]], align 8
// CHECK-NEXT:    [[DOT_COUNTED_BY_GEP:%.*]] = getelementptr inbounds [[STRUCT_VARIABLE]], ptr [[TMP3]], i32 0, i32 2
// CHECK-NEXT:    [[DOT_COUNTED_BY_LOAD:%.*]] = load i32, ptr [[DOT_COUNTED_BY_GEP]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = sext i32 [[DOT_COUNTED_BY_LOAD]] to i64
// CHECK-NEXT:    [[TMP5:%.*]] = mul nsw i64 [[TMP4]], 2
// CHECK-NEXT:    [[TMP6:%.*]] = icmp sgt i64 [[TMP4]], -1
// CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i64 [[TMP5]], i64 0
// CHECK-NEXT:    call void @init(ptr noundef [[ARRAYDECAY]], i64 noundef [[TMP7]])
// CHECK-NEXT:    ret void
//
void test1(struct bucket *foo) {
        init(foo->growable->array);
}

// CHECK-LABEL: define dso_local void @test2(
// CHECK-SAME: ptr noundef [[FOO:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FOO_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[FOO]], ptr [[FOO_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[FOO_ADDR]], align 8
// CHECK-NEXT:    [[GROWABLE:%.*]] = getelementptr inbounds nuw [[STRUCT_BUCKET2:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[ARRAY:%.*]] = getelementptr inbounds nuw [[STRUCT_VARIABLE:%.*]], ptr [[GROWABLE]], i32 0, i32 3
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [0 x i16], ptr [[ARRAY]], i64 0, i64 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[FOO_ADDR]], align 8
// CHECK-NEXT:    [[GROWABLE1:%.*]] = getelementptr inbounds nuw [[STRUCT_BUCKET2]], ptr [[TMP1]], i32 0, i32 1
// CHECK-NEXT:    [[DOT_COUNTED_BY_GEP:%.*]] = getelementptr inbounds [[STRUCT_VARIABLE]], ptr [[GROWABLE1]], i32 0, i32 2
// CHECK-NEXT:    [[DOT_COUNTED_BY_LOAD:%.*]] = load i32, ptr [[DOT_COUNTED_BY_GEP]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = sext i32 [[DOT_COUNTED_BY_LOAD]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = mul nsw i64 [[TMP2]], 2
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP2]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    call void @init(ptr noundef [[ARRAYDECAY]], i64 noundef [[TMP5]])
// CHECK-NEXT:    ret void
//
void test2(struct bucket2 *foo) {
        init(foo->growable.array);
}
