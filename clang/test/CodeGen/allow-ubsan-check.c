// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 4
// RUN: %clang_cc1 -triple x86_64-pc-linux-gnu -emit-llvm -O3 -o - %s -fsanitize=signed-integer-overflow,integer-divide-by-zero,null -mllvm -ubsan-guard-checks | FileCheck %s
// RUN: %clang_cc1 -triple x86_64-pc-linux-gnu -emit-llvm -O3 -o - %s -fsanitize=signed-integer-overflow,integer-divide-by-zero,null -mllvm -ubsan-guard-checks -fsanitize-trap=signed-integer-overflow,integer-divide-by-zero,null | FileCheck %s --check-prefixes=TRAP
// RUN: %clang_cc1 -triple x86_64-pc-linux-gnu -emit-llvm -O3 -o - %s -fsanitize=signed-integer-overflow,integer-divide-by-zero,null -mllvm -ubsan-guard-checks -fsanitize-recover=signed-integer-overflow,integer-divide-by-zero,null | FileCheck %s --check-prefixes=RECOVER


// CHECK-LABEL: define dso_local noundef i32 @div(
// CHECK-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i32 [[Y]], 0, !nosanitize [[META2:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[X]], -2147483648, !nosanitize [[META2]]
// CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[Y]], -1, !nosanitize [[META2]]
// CHECK-NEXT:    [[OR_NOT5:%.*]] = and i1 [[TMP1]], [[TMP2]]
// CHECK-NEXT:    [[DOTNOT3:%.*]] = or i1 [[TMP0]], [[OR_NOT5]]
// CHECK-NEXT:    [[TMP3:%.*]] = tail call i1 @llvm.allow.ubsan.check(i8 3), !nosanitize [[META2]]
// CHECK-NEXT:    [[DOTNOT1:%.*]] = and i1 [[DOTNOT3]], [[TMP3]]
// CHECK-NEXT:    br i1 [[DOTNOT1]], label [[HANDLER_DIVREM_OVERFLOW:%.*]], label [[CONT:%.*]], !prof [[PROF3:![0-9]+]], !nosanitize [[META2]]
// CHECK:       handler.divrem_overflow:
// CHECK-NEXT:    [[TMP4:%.*]] = zext i32 [[X]] to i64, !nosanitize [[META2]]
// CHECK-NEXT:    [[TMP5:%.*]] = zext i32 [[Y]] to i64, !nosanitize [[META2]]
// CHECK-NEXT:    tail call void @__ubsan_handle_divrem_overflow_abort(ptr nonnull @[[GLOB1:[0-9]+]], i64 [[TMP4]], i64 [[TMP5]]) #[[ATTR4:[0-9]+]], !nosanitize [[META2]]
// CHECK-NEXT:    unreachable, !nosanitize [[META2]]
// CHECK:       cont:
// CHECK-NEXT:    [[DIV:%.*]] = sdiv i32 [[X]], [[Y]]
// CHECK-NEXT:    ret i32 [[DIV]]
//
// TRAP-LABEL: define dso_local noundef i32 @div(
// TRAP-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// TRAP-NEXT:  entry:
// TRAP-NEXT:    [[TMP0:%.*]] = icmp eq i32 [[Y]], 0, !nosanitize [[META2:![0-9]+]]
// TRAP-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[X]], -2147483648, !nosanitize [[META2]]
// TRAP-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[Y]], -1, !nosanitize [[META2]]
// TRAP-NEXT:    [[OR_NOT5:%.*]] = and i1 [[TMP1]], [[TMP2]]
// TRAP-NEXT:    [[DOTNOT3:%.*]] = or i1 [[TMP0]], [[OR_NOT5]]
// TRAP-NEXT:    [[TMP3:%.*]] = tail call i1 @llvm.allow.ubsan.check(i8 3), !nosanitize [[META2]]
// TRAP-NEXT:    [[DOTNOT1:%.*]] = and i1 [[DOTNOT3]], [[TMP3]]
// TRAP-NEXT:    br i1 [[DOTNOT1]], label [[TRAP:%.*]], label [[CONT:%.*]], !nosanitize [[META2]]
// TRAP:       trap:
// TRAP-NEXT:    tail call void @llvm.ubsantrap(i8 3) #[[ATTR4:[0-9]+]], !nosanitize [[META2]]
// TRAP-NEXT:    unreachable, !nosanitize [[META2]]
// TRAP:       cont:
// TRAP-NEXT:    [[DIV:%.*]] = sdiv i32 [[X]], [[Y]]
// TRAP-NEXT:    ret i32 [[DIV]]
//
// RECOVER-LABEL: define dso_local noundef i32 @div(
// RECOVER-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// RECOVER-NEXT:  entry:
// RECOVER-NEXT:    [[TMP0:%.*]] = icmp eq i32 [[Y]], 0, !nosanitize [[META2:![0-9]+]]
// RECOVER-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[X]], -2147483648, !nosanitize [[META2]]
// RECOVER-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[Y]], -1, !nosanitize [[META2]]
// RECOVER-NEXT:    [[OR_NOT5:%.*]] = and i1 [[TMP1]], [[TMP2]]
// RECOVER-NEXT:    [[DOTNOT3:%.*]] = or i1 [[TMP0]], [[OR_NOT5]]
// RECOVER-NEXT:    [[TMP3:%.*]] = tail call i1 @llvm.allow.ubsan.check(i8 3), !nosanitize [[META2]]
// RECOVER-NEXT:    [[DOTNOT1:%.*]] = and i1 [[DOTNOT3]], [[TMP3]]
// RECOVER-NEXT:    br i1 [[DOTNOT1]], label [[HANDLER_DIVREM_OVERFLOW:%.*]], label [[CONT:%.*]], !prof [[PROF3:![0-9]+]], !nosanitize [[META2]]
// RECOVER:       handler.divrem_overflow:
// RECOVER-NEXT:    [[TMP4:%.*]] = zext i32 [[X]] to i64, !nosanitize [[META2]]
// RECOVER-NEXT:    [[TMP5:%.*]] = zext i32 [[Y]] to i64, !nosanitize [[META2]]
// RECOVER-NEXT:    tail call void @__ubsan_handle_divrem_overflow(ptr nonnull @[[GLOB1:[0-9]+]], i64 [[TMP4]], i64 [[TMP5]]) #[[ATTR4:[0-9]+]], !nosanitize [[META2]]
// RECOVER-NEXT:    br label [[CONT]], !nosanitize [[META2]]
// RECOVER:       cont:
// RECOVER-NEXT:    [[DIV:%.*]] = sdiv i32 [[X]], [[Y]]
// RECOVER-NEXT:    ret i32 [[DIV]]
//
int div(int x, int y) {
  return x / y;
}

// CHECK-LABEL: define dso_local i32 @null(
// CHECK-SAME: ptr noundef readonly [[X:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[X]], null, !nosanitize [[META2]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i1 @llvm.allow.ubsan.check(i8 22), !nosanitize [[META2]]
// CHECK-NEXT:    [[DOTNOT1:%.*]] = and i1 [[TMP0]], [[TMP1]]
// CHECK-NEXT:    br i1 [[DOTNOT1]], label [[HANDLER_TYPE_MISMATCH:%.*]], label [[CONT:%.*]], !prof [[PROF3]], !nosanitize [[META2]]
// CHECK:       handler.type_mismatch:
// CHECK-NEXT:    tail call void @__ubsan_handle_type_mismatch_v1_abort(ptr nonnull @[[GLOB2:[0-9]+]], i64 0) #[[ATTR4]], !nosanitize [[META2]]
// CHECK-NEXT:    unreachable, !nosanitize [[META2]]
// CHECK:       cont:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[X]], align 4, !tbaa [[TBAA4:![0-9]+]]
// CHECK-NEXT:    ret i32 [[TMP2]]
//
// TRAP-LABEL: define dso_local i32 @null(
// TRAP-SAME: ptr noundef readonly [[X:%.*]]) local_unnamed_addr #[[ATTR0]] {
// TRAP-NEXT:  entry:
// TRAP-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[X]], null, !nosanitize [[META2]]
// TRAP-NEXT:    [[TMP1:%.*]] = tail call i1 @llvm.allow.ubsan.check(i8 22), !nosanitize [[META2]]
// TRAP-NEXT:    [[DOTNOT1:%.*]] = and i1 [[TMP0]], [[TMP1]]
// TRAP-NEXT:    br i1 [[DOTNOT1]], label [[TRAP:%.*]], label [[CONT:%.*]], !nosanitize [[META2]]
// TRAP:       trap:
// TRAP-NEXT:    tail call void @llvm.ubsantrap(i8 22) #[[ATTR4]], !nosanitize [[META2]]
// TRAP-NEXT:    unreachable, !nosanitize [[META2]]
// TRAP:       cont:
// TRAP-NEXT:    [[TMP2:%.*]] = load i32, ptr [[X]], align 4, !tbaa [[TBAA3:![0-9]+]]
// TRAP-NEXT:    ret i32 [[TMP2]]
//
// RECOVER-LABEL: define dso_local i32 @null(
// RECOVER-SAME: ptr noundef readonly [[X:%.*]]) local_unnamed_addr #[[ATTR0]] {
// RECOVER-NEXT:  entry:
// RECOVER-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[X]], null, !nosanitize [[META2]]
// RECOVER-NEXT:    [[TMP1:%.*]] = tail call i1 @llvm.allow.ubsan.check(i8 22), !nosanitize [[META2]]
// RECOVER-NEXT:    [[DOTNOT1:%.*]] = and i1 [[TMP0]], [[TMP1]]
// RECOVER-NEXT:    br i1 [[DOTNOT1]], label [[HANDLER_TYPE_MISMATCH:%.*]], label [[CONT:%.*]], !prof [[PROF3]], !nosanitize [[META2]]
// RECOVER:       handler.type_mismatch:
// RECOVER-NEXT:    tail call void @__ubsan_handle_type_mismatch_v1(ptr nonnull @[[GLOB2:[0-9]+]], i64 0) #[[ATTR4]], !nosanitize [[META2]]
// RECOVER-NEXT:    br label [[CONT]], !nosanitize [[META2]]
// RECOVER:       cont:
// RECOVER-NEXT:    [[TMP2:%.*]] = load i32, ptr [[X]], align 4, !tbaa [[TBAA4:![0-9]+]]
// RECOVER-NEXT:    ret i32 [[TMP2]]
//
int null(int* x) {
  return *x;
}

// CHECK-LABEL: define dso_local noundef i32 @overflow(
// CHECK-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 [[X]], i32 [[Y]]), !nosanitize [[META2]]
// CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { i32, i1 } [[TMP0]], 1, !nosanitize [[META2]]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call i1 @llvm.allow.ubsan.check(i8 0), !nosanitize [[META2]]
// CHECK-NEXT:    [[DOTDEMORGAN:%.*]] = and i1 [[TMP1]], [[TMP2]]
// CHECK-NEXT:    br i1 [[DOTDEMORGAN]], label [[HANDLER_ADD_OVERFLOW:%.*]], label [[CONT:%.*]], !prof [[PROF3]], !nosanitize [[META2]]
// CHECK:       handler.add_overflow:
// CHECK-NEXT:    [[TMP3:%.*]] = zext i32 [[X]] to i64, !nosanitize [[META2]]
// CHECK-NEXT:    [[TMP4:%.*]] = zext i32 [[Y]] to i64, !nosanitize [[META2]]
// CHECK-NEXT:    tail call void @__ubsan_handle_add_overflow_abort(ptr nonnull @[[GLOB3:[0-9]+]], i64 [[TMP3]], i64 [[TMP4]]) #[[ATTR4]], !nosanitize [[META2]]
// CHECK-NEXT:    unreachable, !nosanitize [[META2]]
// CHECK:       cont:
// CHECK-NEXT:    [[TMP5:%.*]] = extractvalue { i32, i1 } [[TMP0]], 0, !nosanitize [[META2]]
// CHECK-NEXT:    ret i32 [[TMP5]]
//
// TRAP-LABEL: define dso_local noundef i32 @overflow(
// TRAP-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]]) local_unnamed_addr #[[ATTR0]] {
// TRAP-NEXT:  entry:
// TRAP-NEXT:    [[TMP0:%.*]] = tail call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 [[X]], i32 [[Y]]), !nosanitize [[META2]]
// TRAP-NEXT:    [[TMP1:%.*]] = extractvalue { i32, i1 } [[TMP0]], 1, !nosanitize [[META2]]
// TRAP-NEXT:    [[TMP2:%.*]] = tail call i1 @llvm.allow.ubsan.check(i8 0), !nosanitize [[META2]]
// TRAP-NEXT:    [[DOTDEMORGAN:%.*]] = and i1 [[TMP1]], [[TMP2]]
// TRAP-NEXT:    br i1 [[DOTDEMORGAN]], label [[TRAP:%.*]], label [[CONT:%.*]], !nosanitize [[META2]]
// TRAP:       trap:
// TRAP-NEXT:    tail call void @llvm.ubsantrap(i8 0) #[[ATTR4]], !nosanitize [[META2]]
// TRAP-NEXT:    unreachable, !nosanitize [[META2]]
// TRAP:       cont:
// TRAP-NEXT:    [[TMP3:%.*]] = extractvalue { i32, i1 } [[TMP0]], 0, !nosanitize [[META2]]
// TRAP-NEXT:    ret i32 [[TMP3]]
//
// RECOVER-LABEL: define dso_local noundef i32 @overflow(
// RECOVER-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]]) local_unnamed_addr #[[ATTR0]] {
// RECOVER-NEXT:  entry:
// RECOVER-NEXT:    [[TMP0:%.*]] = tail call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 [[X]], i32 [[Y]]), !nosanitize [[META2]]
// RECOVER-NEXT:    [[TMP1:%.*]] = extractvalue { i32, i1 } [[TMP0]], 1, !nosanitize [[META2]]
// RECOVER-NEXT:    [[TMP2:%.*]] = tail call i1 @llvm.allow.ubsan.check(i8 0), !nosanitize [[META2]]
// RECOVER-NEXT:    [[DOTDEMORGAN:%.*]] = and i1 [[TMP1]], [[TMP2]]
// RECOVER-NEXT:    br i1 [[DOTDEMORGAN]], label [[HANDLER_ADD_OVERFLOW:%.*]], label [[CONT:%.*]], !prof [[PROF3]], !nosanitize [[META2]]
// RECOVER:       handler.add_overflow:
// RECOVER-NEXT:    [[TMP3:%.*]] = zext i32 [[X]] to i64, !nosanitize [[META2]]
// RECOVER-NEXT:    [[TMP4:%.*]] = zext i32 [[Y]] to i64, !nosanitize [[META2]]
// RECOVER-NEXT:    tail call void @__ubsan_handle_add_overflow(ptr nonnull @[[GLOB3:[0-9]+]], i64 [[TMP3]], i64 [[TMP4]]) #[[ATTR4]], !nosanitize [[META2]]
// RECOVER-NEXT:    br label [[CONT]], !nosanitize [[META2]]
// RECOVER:       cont:
// RECOVER-NEXT:    [[TMP5:%.*]] = extractvalue { i32, i1 } [[TMP0]], 0, !nosanitize [[META2]]
// RECOVER-NEXT:    ret i32 [[TMP5]]
//
int overflow(int x, int y) {
  return x + y;
}
//.
// CHECK: [[META2]] = !{}
// CHECK: [[PROF3]] = !{!"branch_weights", i32 1, i32 1048575}
// CHECK: [[TBAA4]] = !{[[META5:![0-9]+]], [[META5]], i64 0}
// CHECK: [[META5]] = !{!"int", [[META6:![0-9]+]], i64 0}
// CHECK: [[META6]] = !{!"omnipotent char", [[META7:![0-9]+]], i64 0}
// CHECK: [[META7]] = !{!"Simple C/C++ TBAA"}
//.
// TRAP: [[META2]] = !{}
// TRAP: [[TBAA3]] = !{[[META4:![0-9]+]], [[META4]], i64 0}
// TRAP: [[META4]] = !{!"int", [[META5:![0-9]+]], i64 0}
// TRAP: [[META5]] = !{!"omnipotent char", [[META6:![0-9]+]], i64 0}
// TRAP: [[META6]] = !{!"Simple C/C++ TBAA"}
//.
// RECOVER: [[META2]] = !{}
// RECOVER: [[PROF3]] = !{!"branch_weights", i32 1, i32 1048575}
// RECOVER: [[TBAA4]] = !{[[META5:![0-9]+]], [[META5]], i64 0}
// RECOVER: [[META5]] = !{!"int", [[META6:![0-9]+]], i64 0}
// RECOVER: [[META6]] = !{!"omnipotent char", [[META7:![0-9]+]], i64 0}
// RECOVER: [[META7]] = !{!"Simple C/C++ TBAA"}
//.
