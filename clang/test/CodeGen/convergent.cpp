// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --check-globals all --version 5
// RUN: %clang_cc1 -emit-llvm %s -triple x86_64-unknown-linux-gnu -o - | FileCheck %s

class A {
public:
//.
// CHECK: @_ZTV1B = external unnamed_addr constant { [5 x ptr] }, align 8
//.
  [[clang::convergent]] A();
  [[clang::convergent]] virtual ~A();
  [[clang::convergent]] void f();
  [[clang::convergent]] virtual void g();
  [[clang::convergent]] static void f1();
};

class B : public A {
public:
  void g() override;
};

bool bar();
[[clang::convergent]] void f(bool, bool);

// CHECK-LABEL: define dso_local void @_Z3fooiP1AP1B(
// CHECK-SAME: i32 noundef [[I:%.*]], ptr noundef [[AP:%.*]], ptr noundef [[BP:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[AP_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[BP_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[REF_TMP:%.*]] = alloca [[CLASS_ANON:%.*]], align 1
// CHECK-NEXT:    [[A:%.*]] = alloca [[CLASS_A:%.*]], align 8
// CHECK-NEXT:    [[B:%.*]] = alloca [[CLASS_B:%.*]], align 8
// CHECK-NEXT:    [[NEWA:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store i32 [[I]], ptr [[I_ADDR]], align 4
// CHECK-NEXT:    store ptr [[AP]], ptr [[AP_ADDR]], align 8
// CHECK-NEXT:    store ptr [[BP]], ptr [[BP_ADDR]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noundef zeroext i1 @_Z3barv() #[[ATTR6:[0-9]+]]
// CHECK-NEXT:    store i32 4, ptr [[I_ADDR]], align 4
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef zeroext i1 @_Z3barv() #[[ATTR6]]
// CHECK-NEXT:    [[CALL2:%.*]] = call noundef zeroext i1 @_Z3barv() #[[ATTR6]]
// CHECK-NEXT:    [[CALL3:%.*]] = call noundef zeroext i1 @_Z3barv()
// CHECK-NEXT:    [[CALL4:%.*]] = call noundef zeroext i1 @_Z3barv()
// CHECK-NEXT:    call void @_Z1fbb(i1 noundef zeroext [[CALL3]], i1 noundef zeroext [[CALL4]]) #[[ATTR6]]
// CHECK-NEXT:    call void @"_ZZ3fooiP1AP1BENK3$_0clEv"(ptr noundef nonnull align 1 dereferenceable(1) [[REF_TMP]]) #[[ATTR6]]
// CHECK-NEXT:    [[CALL5:%.*]] = call noundef zeroext i1 @_Z3barv() #[[ATTR6]]
// CHECK-NEXT:    br label %[[FOR_COND:.*]]
// CHECK:       [[FOR_COND]]:
// CHECK-NEXT:    [[CALL6:%.*]] = call noundef zeroext i1 @_Z3barv() #[[ATTR6]]
// CHECK-NEXT:    br i1 [[CALL6]], label %[[FOR_BODY:.*]], label %[[FOR_END:.*]]
// CHECK:       [[FOR_BODY]]:
// CHECK-NEXT:    br label %[[FOR_INC:.*]]
// CHECK:       [[FOR_INC]]:
// CHECK-NEXT:    [[CALL7:%.*]] = call noundef zeroext i1 @_Z3barv() #[[ATTR6]]
// CHECK-NEXT:    br label %[[FOR_COND]], !llvm.loop [[LOOP2:![0-9]+]]
// CHECK:       [[FOR_END]]:
// CHECK-NEXT:    call void asm sideeffect "nop", "~{dirflag},~{fpsr},~{flags}"() #[[ATTR7:[0-9]+]], !srcloc [[META4:![0-9]+]]
// CHECK-NEXT:    [[CALL8:%.*]] = call noundef zeroext i1 @_Z3barv()
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[AP_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP0]]) #[[ATTR6]]
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[BP_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE9:%.*]] = load ptr, ptr [[TMP2]], align 8
// CHECK-NEXT:    [[VFN10:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE9]], i64 2
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[VFN10]], align 8
// CHECK-NEXT:    call void [[TMP3]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP2]])
// CHECK-NEXT:    call void @_ZN1AC1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[A]]) #[[ATTR6]]
// CHECK-NEXT:    call void @_ZN1A1fEv(ptr noundef nonnull align 8 dereferenceable(8) [[A]]) #[[ATTR6]]
// CHECK-NEXT:    call void @_ZN1A1gEv(ptr noundef nonnull align 8 dereferenceable(8) [[A]]) #[[ATTR6]]
// CHECK-NEXT:    call void @_ZN1A2f1Ev() #[[ATTR6]]
// CHECK-NEXT:    call void @_ZN1BC1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[B]])
// CHECK-NEXT:    call void @_ZN1B1gEv(ptr noundef nonnull align 8 dereferenceable(8) [[B]])
// CHECK-NEXT:    [[CALL11:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 8) #[[ATTR8:[0-9]+]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[CALL11]], i8 0, i64 8, i1 false)
// CHECK-NEXT:    call void @_ZN1BC1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[CALL11]])
// CHECK-NEXT:    store ptr [[CALL11]], ptr [[NEWA]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[NEWA]], align 8
// CHECK-NEXT:    [[ISNULL:%.*]] = icmp eq ptr [[TMP4]], null
// CHECK-NEXT:    br i1 [[ISNULL]], label %[[DELETE_END:.*]], label %[[DELETE_NOTNULL:.*]]
// CHECK:       [[DELETE_NOTNULL]]:
// CHECK-NEXT:    [[VTABLE12:%.*]] = load ptr, ptr [[TMP4]], align 8
// CHECK-NEXT:    [[VFN13:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE12]], i64 1
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[VFN13]], align 8
// CHECK-NEXT:    call void [[TMP5]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP4]]) #[[ATTR7]]
// CHECK-NEXT:    br label %[[DELETE_END]]
// CHECK:       [[DELETE_END]]:
// CHECK-NEXT:    call void @_ZN1BD1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[B]]) #[[ATTR9:[0-9]+]]
// CHECK-NEXT:    call void @_ZN1AD1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[A]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void foo(int i, A *ap, B *bp) {
  [[clang::convergent]] bar();
  [[clang::convergent]] (i = 4, bar());
  [[clang::convergent]] (void)(bar());
  f(bar(), bar());
  [[clang::convergent]] [] { bar(); bar(); }(); // convergent only applies to the anonymous function call
  [[clang::convergent]] for (bar(); bar(); bar()) {}
  [[clang::convergent]] { asm("nop"); }
  bar();

  ap->g();
  bp->g();

  A a;
  a.f();
  a.g();
  A::f1();

  B b;
  b.g();

  A *newA = new B();
  delete newA;
}
//.
// CHECK: attributes #[[ATTR0]] = { mustprogress noinline nounwind optnone "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #[[ATTR1:[0-9]+]] = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #[[ATTR2:[0-9]+]] = { convergent "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #[[ATTR3:[0-9]+]] = { nobuiltin allocsize(0) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #[[ATTR4:[0-9]+]] = { nocallback nofree nounwind willreturn memory(argmem: write) }
// CHECK: attributes #[[ATTR5:[0-9]+]] = { convergent nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #[[ATTR6]] = { convergent }
// CHECK: attributes #[[ATTR7]] = { convergent nounwind }
// CHECK: attributes #[[ATTR8]] = { builtin allocsize(0) }
// CHECK: attributes #[[ATTR9]] = { nounwind }
//.
// CHECK: [[META0:![0-9]+]] = !{i32 1, !"wchar_size", i32 4}
// CHECK: [[META1:![0-9]+]] = !{!"{{.*}}clang version {{.*}}"}
// CHECK: [[LOOP2]] = distinct !{[[LOOP2]], [[META3:![0-9]+]]}
// CHECK: [[META3]] = !{!"llvm.loop.mustprogress"}
// CHECK: [[META4]] = !{i64 5689}
//.
