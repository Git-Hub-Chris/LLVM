// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 4
// RUN: %clang_cc1 -triple x86_64-linux-gnu -emit-llvm -o - %s \
// RUN: | FileCheck -check-prefix=CHECK %s
// RUN: %clang_cc1 -triple x86_64-linux-gnu -ffast-math -ffp-contract=fast -emit-llvm -o - %s \
// RUN: | FileCheck -check-prefix=CHECK-FAST %s

// Reproducer for issue #87758
// The testcase below verifies that the "fast" flag are set on the calls.

float sqrtf(float x);
float powf(float x, float y);
float fmaf(float x, float y, float z);

#pragma float_control(push)
#pragma float_control(precise, off)
// CHECK-LABEL: define dso_local float @fp_precise_off_libm_calls(
// CHECK-SAME: float noundef [[A:%.*]], float noundef [[B:%.*]], float noundef [[C:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[C_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    store float [[B]], ptr [[B_ADDR]], align 4
// CHECK-NEXT:    store float [[C]], ptr [[C_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = call fast float @llvm.sqrt.f32(float [[TMP0]])
// CHECK-NEXT:    store float [[TMP1]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load float, ptr [[B_ADDR]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = call fast float @llvm.pow.f32(float [[TMP2]], float [[TMP3]])
// CHECK-NEXT:    store float [[TMP4]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = load float, ptr [[B_ADDR]], align 4
// CHECK-NEXT:    [[TMP7:%.*]] = load float, ptr [[C_ADDR]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = call fast float @llvm.fma.f32(float [[TMP5]], float [[TMP6]], float [[TMP7]])
// CHECK-NEXT:    store float [[TMP8]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    ret float [[TMP9]]
//
// CHECK-FAST-LABEL: define dso_local nofpclass(nan inf) float @fp_precise_off_libm_calls(
// CHECK-FAST-SAME: float noundef nofpclass(nan inf) [[A:%.*]], float noundef nofpclass(nan inf) [[B:%.*]], float noundef nofpclass(nan inf) [[C:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-FAST-NEXT:  entry:
// CHECK-FAST-NEXT:    [[A_ADDR:%.*]] = alloca float, align 4
// CHECK-FAST-NEXT:    [[B_ADDR:%.*]] = alloca float, align 4
// CHECK-FAST-NEXT:    [[C_ADDR:%.*]] = alloca float, align 4
// CHECK-FAST-NEXT:    store float [[A]], ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    store float [[B]], ptr [[B_ADDR]], align 4
// CHECK-FAST-NEXT:    store float [[C]], ptr [[C_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP0:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP1:%.*]] = call fast float @llvm.sqrt.f32(float [[TMP0]])
// CHECK-FAST-NEXT:    store float [[TMP1]], ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP2:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP3:%.*]] = load float, ptr [[B_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP4:%.*]] = call fast float @llvm.pow.f32(float [[TMP2]], float [[TMP3]])
// CHECK-FAST-NEXT:    store float [[TMP4]], ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP5:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP6:%.*]] = load float, ptr [[B_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP7:%.*]] = load float, ptr [[C_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP8:%.*]] = call fast float @llvm.fma.f32(float [[TMP5]], float [[TMP6]], float [[TMP7]])
// CHECK-FAST-NEXT:    store float [[TMP8]], ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP9:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    ret float [[TMP9]]
//
float fp_precise_off_libm_calls(float a, float b, float c) {
  a = sqrtf(a);
  a = powf(a,b);
  a = fmaf(a,b,c);
  return a;
}
#pragma float_control(pop)

#pragma float_control(push)
#pragma float_control(precise, on)
// CHECK-LABEL: define dso_local float @fp_precise_on_libm_calls(
// CHECK-SAME: float noundef [[A:%.*]], float noundef [[B:%.*]], float noundef [[C:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[C_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    store float [[B]], ptr [[B_ADDR]], align 4
// CHECK-NEXT:    store float [[C]], ptr [[C_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call float @sqrtf(float noundef [[TMP0]]) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    store float [[CALL]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load float, ptr [[B_ADDR]], align 4
// CHECK-NEXT:    [[CALL1:%.*]] = call float @powf(float noundef [[TMP1]], float noundef [[TMP2]]) #[[ATTR3]]
// CHECK-NEXT:    store float [[CALL1]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = load float, ptr [[B_ADDR]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = load float, ptr [[C_ADDR]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = call float @llvm.fma.f32(float [[TMP3]], float [[TMP4]], float [[TMP5]])
// CHECK-NEXT:    store float [[TMP6]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP7:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    ret float [[TMP7]]
//
// CHECK-FAST-LABEL: define dso_local nofpclass(nan inf) float @fp_precise_on_libm_calls(
// CHECK-FAST-SAME: float noundef nofpclass(nan inf) [[A:%.*]], float noundef nofpclass(nan inf) [[B:%.*]], float noundef nofpclass(nan inf) [[C:%.*]]) #[[ATTR2:[0-9]+]] {
// CHECK-FAST-NEXT:  entry:
// CHECK-FAST-NEXT:    [[A_ADDR:%.*]] = alloca float, align 4
// CHECK-FAST-NEXT:    [[B_ADDR:%.*]] = alloca float, align 4
// CHECK-FAST-NEXT:    [[C_ADDR:%.*]] = alloca float, align 4
// CHECK-FAST-NEXT:    store float [[A]], ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    store float [[B]], ptr [[B_ADDR]], align 4
// CHECK-FAST-NEXT:    store float [[C]], ptr [[C_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP0:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[CALL:%.*]] = call nofpclass(nan inf) float @sqrtf(float noundef nofpclass(nan inf) [[TMP0]]) #[[ATTR4:[0-9]+]]
// CHECK-FAST-NEXT:    store float [[CALL]], ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP1:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP2:%.*]] = load float, ptr [[B_ADDR]], align 4
// CHECK-FAST-NEXT:    [[CALL1:%.*]] = call nofpclass(nan inf) float @powf(float noundef nofpclass(nan inf) [[TMP1]], float noundef nofpclass(nan inf) [[TMP2]]) #[[ATTR4]]
// CHECK-FAST-NEXT:    store float [[CALL1]], ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP3:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP4:%.*]] = load float, ptr [[B_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP5:%.*]] = load float, ptr [[C_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP6:%.*]] = call float @llvm.fma.f32(float [[TMP3]], float [[TMP4]], float [[TMP5]])
// CHECK-FAST-NEXT:    store float [[TMP6]], ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    [[TMP7:%.*]] = load float, ptr [[A_ADDR]], align 4
// CHECK-FAST-NEXT:    ret float [[TMP7]]
//
float fp_precise_on_libm_calls(float a, float b, float c) {
  a = sqrtf(a);
  a = powf(a,b);
  a = fmaf(a,b,c);
  return a;
}
#pragma float_control(pop)
