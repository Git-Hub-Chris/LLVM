// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// REQUIRES: arm-registered-target
// RUN: %clang_cc1 -triple armv8.2a-arm-none-eabi \
// RUN:   -target-feature +neon \
// RUN:   -mfloat-abi hard \
// RUN: -disable-O0-optnone -emit-llvm -o - %s | opt -S -passes=mem2reg,instcombine \
// RUN:  | FileCheck %s

#include <arm_neon.h>

// CHECK-LABEL: define dso_local arm_aapcs_vfpcc <8 x i8> @test_vadd_p8(
// CHECK-SAME: <8 x i8> noundef [[A:%.*]], <8 x i8> noundef [[B:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[TMP0:%.*]] = xor <8 x i8> [[A]], [[B]]
// CHECK-NEXT:    ret <8 x i8> [[TMP0]]
//
poly8x8_t test_vadd_p8(poly8x8_t a, poly8x8_t b) {
  return vadd_p8 (a, b);
}

// CHECK-LABEL: define dso_local arm_aapcs_vfpcc <4 x i16> @test_vadd_p16(
// CHECK-SAME: <4 x i16> noundef [[A:%.*]], <4 x i16> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[TMP0:%.*]] = xor <4 x i16> [[A]], [[B]]
// CHECK-NEXT:    ret <4 x i16> [[TMP0]]
//
poly16x4_t test_vadd_p16(poly16x4_t a, poly16x4_t b) {
  return vadd_p16 (a, b);
}

// CHECK-LABEL: define dso_local arm_aapcs_vfpcc <1 x i64> @test_vadd_p64(
// CHECK-SAME: <1 x i64> noundef [[A:%.*]], <1 x i64> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[TMP0:%.*]] = xor <1 x i64> [[A]], [[B]]
// CHECK-NEXT:    ret <1 x i64> [[TMP0]]
//
poly64x1_t test_vadd_p64(poly64x1_t a, poly64x1_t b) {
  return vadd_p64(a, b);
}

// CHECK-LABEL: define dso_local arm_aapcs_vfpcc <16 x i8> @test_vaddq_p8(
// CHECK-SAME: <16 x i8> noundef [[A:%.*]], <16 x i8> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[TMP0:%.*]] = xor <16 x i8> [[A]], [[B]]
// CHECK-NEXT:    ret <16 x i8> [[TMP0]]
//
poly8x16_t test_vaddq_p8(poly8x16_t a, poly8x16_t b){
  return vaddq_p8(a, b);
}

// CHECK-LABEL: define dso_local arm_aapcs_vfpcc <8 x i16> @test_vaddq_p16(
// CHECK-SAME: <8 x i16> noundef [[A:%.*]], <8 x i16> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[TMP0:%.*]] = xor <8 x i16> [[A]], [[B]]
// CHECK-NEXT:    ret <8 x i16> [[TMP0]]
//
poly16x8_t test_vaddq_p16(poly16x8_t a, poly16x8_t b){
  return vaddq_p16(a, b);
}

// CHECK-LABEL: define dso_local arm_aapcs_vfpcc <2 x i64> @test_vaddq_p64(
// CHECK-SAME: <2 x i64> noundef [[A:%.*]], <2 x i64> noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[TMP0:%.*]] = xor <2 x i64> [[A]], [[B]]
// CHECK-NEXT:    ret <2 x i64> [[TMP0]]
//
poly64x2_t test_vaddq_p64(poly64x2_t a, poly64x2_t b){
  return vaddq_p64(a, b);
}

// TODO: poly128_t not implemented on aarch32
// CHCK-LABEL: @test_vaddq_p128(
// CHCK-NEXT:  entry:
// CHCK-NEXT:    [[TMP0:%.*]] = bitcast i128 [[A:%.*]] to <16 x i8>
// CHCK-NEXT:    [[TMP1:%.*]] = bitcast i128 [[B:%.*]] to <16 x i8>
// CHCK-NEXT:    [[TMP2:%.*]] = xor <16 x i8> [[TMP0]], [[TMP1]]
// CHCK-NEXT:    [[TMP3:%.*]] = bitcast <16 x i8> [[TMP2]] to i128
// CHCK-NEXT:    ret i128 [[TMP3]]
//
//poly128_t test_vaddq_p128 (poly128_t a, poly128_t b){
//  return vaddq_p128(a, b);
