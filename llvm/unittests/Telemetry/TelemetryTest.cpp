//===- llvm/unittest/Telemetry/TelemetryTest.cpp - Telemetry unittests ---===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "llvm/Telemetry/Telemetry.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/JSON.h"
#include "llvm/Support/raw_ostream.h"
#include "gtest/gtest.h"
#include <chrono>
#include <ctime>
#include <vector>

#include <iostream>

namespace llvm {
namespace telemetry {
// Testing parameters.
// These are set by each test to force certain outcomes.
// Since the tests may run in parallel, each test will have
// its own TestContext populated.
struct TestContext {
  // Controlling whether there is vendor plugin.
  // In "real" implementation, the plugin-registration
  // framework will handle the overrides but for tests,
  // we just use a bool flag to decide which function to call.
  bool HasVendorPlugin = false;

  // These two fields contain data emitted by the framework for later
  // verification by the tests.
  std::string Buffer = "";
  std::vector<json::Object> EmittedJsons;

  // The expected Uuid generated by the fake tool.
  std::string ExpectedUuid = "";
};

class JsonSerializer : public Serializer {
public:
  json::Object *getOutputObject() { return Out.get(); }

  llvm::Error init() override {
    if (Started)
      return createStringError("Serializer already in use");
    Started = true;
    Out = std::make_unique<json::Object>();
    return Error::success();
  }

  void write(StringRef KeyName, bool Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, int Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, unsigned int Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, unsigned long Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, long Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, long long Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, unsigned long long Value) override {
    writeHelper(KeyName, Value);
  }
  void write(StringRef KeyName, StringRef Value) override {
    writeHelper(KeyName, Value);
  }

  void beginObject(StringRef KeyName) override {
    Children.push_back(json::Object());
    ChildrenNames.push_back(KeyName.str());
  }

  void endObject() override {
    assert(!Children.empty() && !ChildrenNames.empty());
    json::Value Val = json::Value(std::move(Children.back()));
    std::string Name = ChildrenNames.back();

    Children.pop_back();
    ChildrenNames.pop_back();
    writeHelper(Name, std::move(Val));
  }

  llvm::Error finalize() override {
    if (!Started)
      return createStringError("Serializer not currently in use");
    Started = false;
    return Error::success();
  }

private:
  template <typename T> void writeHelper(StringRef Name, T Value) {
    assert(Started && "serializer not started");
    if (Children.empty())
      Out->try_emplace(Name, Value);
    else
      Children.back().try_emplace(Name, Value);
  }
  bool Started = false;
  std::unique_ptr<json::Object> Out;
  std::vector<json::Object> Children;
  std::vector<std::string> ChildrenNames;
};

class StringSerializer : public Serializer {
public:
  const std::string &getString() { return Buffer; }

  llvm::Error init() override {
    if (Started)
      return createStringError("Serializer already in use");
    Started = true;
    Buffer.clear();
    return Error::success();
  }

  void write(StringRef KeyName, bool Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, int Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, unsigned long long Value) override {
    writeHelper(KeyName, Value);
  }
  void write(StringRef KeyName, StringRef Value) override {
    writeHelper(KeyName, Value);
  }

  void beginObject(StringRef KeyName) override {
    Children.push_back(std::string());
    ChildrenNames.push_back(KeyName.str());
  }

  void endObject() override {
    assert(!Children.empty() && !ChildrenNames.empty());
    std::string ChildBuff = Children.back();
    std::string Name = ChildrenNames.back();
    Children.pop_back();
    ChildrenNames.pop_back();
    writeHelper(Name, ChildBuff);
  }

  llvm::Error finalize() override {
    assert(Children.empty() && ChildrenNames.empty());
    if (!Started)
      return createStringError("Serializer not currently in use");
    Started = false;
    return Error::success();
  }

private:
  template <typename T> void writeHelper(StringRef Name, T Value) {
    assert(Started && "serializer not started");
    if (Children.empty())
      Buffer.append((Name + ":" + llvm::Twine(Value) + "\n").str());
    else
      Children.back().append((Name + ":" + llvm::Twine(Value) + "\n").str());
  }

  bool Started = false;
  std::string Buffer;
  std::vector<std::string> Children;
  std::vector<std::string> ChildrenNames;
};

namespace vendor {
struct VendorConfig : public Config {
  VendorConfig(bool Enable) : Config(Enable) {}
  std::string makeSessionId() override {
    static int seed = 0;
    return std::to_string(seed++);
  }
};

std::shared_ptr<Config> getTelemetryConfig(const TestContext &Ctxt) {
  return std::make_shared<VendorConfig>(/*EnableTelemetry=*/true);
}

class JsonStorageDestination : public Destination {
public:
  JsonStorageDestination(TestContext *Ctxt) : CurrentContext(Ctxt) {}

  Error receiveEntry(const TelemetryInfo *Entry) override {
    if (Error Err = serializer.init())
      return Err;

    Entry->serialize(serializer);
    if (Error Err = serializer.finalize())
      return Err;

    json::Object copied = *serializer.getOutputObject();
    CurrentContext->EmittedJsons.push_back(std::move(copied));

    return Error::success();
  }

  llvm::StringLiteral name() const override { return "JsonDestination"; }

private:
  TestContext *CurrentContext;
  JsonSerializer serializer;
};

struct StartupInfo : public TelemetryInfo {
  std::string ToolName;

  void serialize(Serializer &serializer) const override {
    TelemetryInfo::serialize(serializer);
    serializer.write("ToolName", ToolName);
  }
};

struct ExitInfo : public TelemetryInfo {
  int ExitCode;
  std::string ExitDesc;
  void serialize(Serializer &serializer) const override {
    TelemetryInfo::serialize(serializer);
    serializer.write("ExitCode", ExitCode);
    serializer.write("ExitDesc", ExitDesc);
  }
};

class TestManager : public Manager {
public:
  static std::unique_ptr<TestManager>
  createInstance(Config *Config, TestContext *CurrentContext) {
    if (!Config->EnableTelemetry)
      return nullptr;
    CurrentContext->ExpectedUuid = Config->makeSessionId();
    std::unique_ptr<TestManager> Ret = std::make_unique<TestManager>(
        CurrentContext, CurrentContext->ExpectedUuid);

    // Add a few destinations.
    Ret->addDestination(
        std::make_unique<JsonStorageDestination>(CurrentContext));

    return Ret;
  }

  TestManager(TestContext *Ctxt, std::string Id)
      : CurrentContext(Ctxt), SessionId(Id) {}

  Error dispatch(TelemetryInfo *Entry) override {
    Entry->SessionId = SessionId;
    Error AllErrs = Error::success();
    for (auto &Dest : Destinations) {
      if (Error Err = Dest->receiveEntry(Entry))
        AllErrs = joinErrors(std::move(AllErrs), std::move(Err));
    }
    return AllErrs;
  }

  void addDestination(std::unique_ptr<Destination> Dest) override {
    Destinations.push_back(std::move(Dest));
  }

  std::string getSessionId() { return SessionId; }

  Error atStartup(StartupInfo *Info) { return dispatch(Info); }

  Error atExit(ExitInfo *Info) { return dispatch(Info); }

private:
  TestContext *CurrentContext;
  const std::string SessionId;
  std::vector<std::unique_ptr<Destination>> Destinations;
};

} // namespace vendor

std::shared_ptr<Config> GetTelemetryConfig(const TestContext &Ctxt) {
  if (Ctxt.HasVendorPlugin)
    return vendor::GetTelemetryConfig(Ctxt);

  return std::make_shared<Config>(false);
}

TEST(TelemetryTest, TelemetryEnabled) {
  const std::string ToolName = "TelemetryTestTool";

  // Preset some params
  TestContext Context;
  Context.HasVendorPlugin = true;
  Context.Buffer.clear();
  Context.EmittedJsons.clear();

  std::shared_ptr<Config> Config = GetTelemetryConfig(Context);
  auto Manager = vendor::TestManager::createInstance(Config.get(), &Context);

  EXPECT_STREQ(Manager->getSessionId().c_str(), Context.ExpectedUuid.c_str());

  vendor::StartupInfo S;
  S.ToolName = ToolName;

  Error startupEmitStatus = Manager->atStartup(&S);
  EXPECT_FALSE(startupEmitStatus);
  const json::Object &StartupEntry = Context.EmittedJsons[0];
  json::Object ExpectedStartup(
      {{"SessionId", Context.ExpectedUuid}, {"ToolName", ToolName}});
  EXPECT_EQ(ExpectedStartup, StartupEntry);

  vendor::ExitInfo E;
  E.ExitCode = 0;
  E.ExitDesc = "success";
  Error exitEmitStatus = Manager->atExit(&E);
  EXPECT_FALSE(exitEmitStatus);
  const json::Object &ExitEntry = Context.EmittedJsons[1];
  json::Object ExpectedExit({{"SessionId", Context.ExpectedUuid},
                             {"ExitCode", 0},
                             {"ExitDesc", "success"}});
  EXPECT_EQ(ExpectedExit, ExitEntry);
}

} // namespace telemetry
} // namespace llvm
