//== ----- llvm/CodeGen/GlobalISel/Combiner.h -------------------*- C++ -*-== //
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This contains the base class for all Combiners generated by TableGen.
/// Backends need to create class that inherits from "Combiner" and put all of
/// the TableGen-erated code in there, as it implements the virtual functions.
///
//===----------------------------------------------------------------------===//

#ifndef LLVM_CODEGEN_GLOBALISEL_COMBINER_H
#define LLVM_CODEGEN_GLOBALISEL_COMBINER_H

#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h"
#include "llvm/CodeGen/GlobalISel/GISelChangeObserver.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"

namespace llvm {
class MachineRegisterInfo;
struct CombinerInfo;
class GISelCSEInfo;
class TargetPassConfig;
class MachineFunction;
class MachineIRBuilder;

/// Combiner implementation. This is per-function, so passes need to recreate
/// one of these each time they enter a new function.
///
/// TODO: Is it worth making this module-wide?
class Combiner : public GIMatchTableExecutor {
private:
  class WorkListMaintainer;
  GISelWorkList<512> WorkList;

  // We have a little hack here where keep the owned pointers private, and only
  // expose a reference. This has two purposes:
  //  - Avoid derived classes messing with those pointers.
  //  - Keep the API consistent. CInfo, MF, MRI, etc. are all accessed as
  //  references. Accessing Observer/B as pointers unnecessarily leaks
  //  implementation details into derived classes.
  std::unique_ptr<MachineIRBuilder> Builder;
  std::unique_ptr<WorkListMaintainer> WLObserver;
  std::unique_ptr<GISelObserverWrapper> ObserverWrapper;

  bool HasSetupMF = false;

public:
  /// If CSEInfo is not null, then the Combiner will use CSEInfo as the observer
  /// and also create a CSEMIRBuilder. Pass nullptr if CSE is not needed.
  Combiner(MachineFunction &MF, CombinerInfo &CInfo,
           const TargetPassConfig *TPC, GISelKnownBits *KB,
           GISelCSEInfo *CSEInfo = nullptr);
  virtual ~Combiner();

  virtual bool tryCombineAll(MachineInstr &I) const = 0;

  bool combineMachineInstrs();

  /// Base class for all dynamic MatchDatas definitions, used for type erasure
  /// purposes.
  ///
  /// As derived classes may have non-trivial destructors, we need to be able to
  /// call the destructor through the unique_ptr of the base class.
  ///
  /// There are two ways to achieve this.
  ///   - (Easiest) Make MatchDataBase have a virtual destructor.
  ///   - Use a custom deleter
  ///
  /// We use solution number 2, that way we don't have a vtable in all MatchData
  /// objects (making them more compact), and we can have trivially destructible
  /// MatchDatas, which avoids useless virtual function calls and allows the
  /// compiler/libraries to use faster code (as it knows no destructor needs to
  /// be called).
  ///
  /// This is really a micro-optimization, but MatchData used to be a
  /// performance issue so better safe than sorry.
  struct MatchDataBase {};

  /// If a MatchData instance is active, cast it to Ty and return it.
  /// Otherwise, create a new MatchData instance of type Ty and return it.
  template <typename Ty> Ty &getOrCreateMatchData() const {
    static_assert(std::is_base_of_v<MatchDataBase, Ty>,
                  "Type must derive from MatchDataBase to be allocatable!");
    // Allocate if we have no MatchData active, or if the MatchData that's
    // active is not the one that we want.
    if (!MatchData || Ty::ID != MatchDataID) {
      MatchDataID = Ty::ID;
      MatchData = std::unique_ptr<Ty, MatchDataDeleter>(
          new Ty(), [](MatchDataBase *MD) { delete static_cast<Ty *>(MD); });
    }
    return *static_cast<Ty *>(MatchData.get());
  }

  /// Deallocates the currently active MatchData instance.
  ///
  /// TODO: Can we get away with never actually calling this? The MatchData
  /// instance would then just be deleted by getOrCreateMatchData or when the
  /// Combiner class is deallocated. I'm just a bit scared it'd cause issues
  /// with captured values in some of the lambdas used as MatchInfo.
  void resetMatchData() const { MatchData.reset(); }

private:
  using MatchDataDeleter = void (*)(MatchDataBase *);

  mutable std::unique_ptr<MatchDataBase, MatchDataDeleter> MatchData = {
      nullptr, [](auto *) {}};
  mutable unsigned MatchDataID = unsigned(-1);

protected:
  CombinerInfo &CInfo;
  GISelChangeObserver &Observer;
  MachineIRBuilder &B;
  MachineFunction &MF;
  MachineRegisterInfo &MRI;
  GISelKnownBits *KB;

  const TargetPassConfig *TPC;
  GISelCSEInfo *CSEInfo;
};

} // End namespace llvm.

#endif // LLVM_CODEGEN_GLOBALISEL_COMBINER_H
