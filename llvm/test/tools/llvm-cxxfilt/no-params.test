RUN: llvm-cxxfilt             _Z3fooIiJEEvf _Z3fooIPFcfEET_d _ZN1f2baC2ERKNS_2baIT_EE | FileCheck %s --check-prefix=CHECK-PARAMS
RUN: llvm-cxxfilt          -p _Z3fooIiJEEvf _Z3fooIPFcfEET_d _ZN1f2baC2ERKNS_2baIT_EE | FileCheck %s --check-prefix=CHECK-NO-PARAMS --match-full-lines
RUN: llvm-cxxfilt --no-params _Z3fooIiJEEvf _Z3fooIPFcfEET_d _ZN1f2baC2ERKNS_2baIT_EE | FileCheck %s --check-prefix=CHECK-NO-PARAMS --match-full-lines

# Use a simple valid mangled name to check that -p or --no-params flag omits
# function parameters and the return type.

CHECK-PARAMS: void foo<int>(float)
CHECK-NO-PARAMS: foo<int>

# Check that only the top-level function is impacted by the switch, and that
# nested function types in the encoding (e.g. where a function type is being
# used as a template parameter) still include their parameters.
#
# template <typename T> T foo(double);
# typedef char (*F)(float);
# F foo<F>(double)

CHECK-PARAMS: char (*foo<char (*)(float)>(double))(float)
CHECK-NO-PARAMS: foo<char (*)(float)>

# Use an invalid mangled name broken in the function parameters to check how -p
# or --no-params flag works. If the option is given we should be able to
# demangle function name just fine. If it is not given, demangling will fail
# because of the invalid params.

CHECK-PARAMS: _ZN1f2baC2ERKNS_2baIT_EE
CHECK-NO-PARAMS: f::ba::ba
