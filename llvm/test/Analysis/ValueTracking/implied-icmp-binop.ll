; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -passes=instcombine -S < %s | FileCheck %s

; Tests from PR68799

define i1 @f_and(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @f_and(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret i1 false
;
entry:
  %cmp = icmp ne i32 %x, 0
  %0 = or i32 %x, %y
  %and14 = icmp eq i32 %0, 0
  %and1115 = and i1 %cmp, %and14
  ret i1 %and1115
}

define i1 @f_or(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @f_or(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret i1 true
;
entry:
  %cmp.not = icmp eq i32 %x, 0
  %0 = or i32 %x, %y
  %or14 = icmp ne i32 %0, 0
  %or1115 = or i1 %cmp.not, %or14
  ret i1 %or1115
}

; Tests for more binops

define i1 @f_add(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @f_add(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret i1 false
;
entry:
  %yr = and i32 %y, 7
  %cmp = icmp ult i32 %x, 8
  %0 = add i32 %yr, %x
  %cmp2 = icmp ugt i32 %0, 16
  %and = and i1 %cmp, %cmp2
  ret i1 %and
}

define i1 @f_add_nsw(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @f_add_nsw(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret i1 false
;
entry:
  %yr = and i32 %y, 2147483647
  %cmp = icmp sgt i32 %x, 5
  %0 = add nsw i32 %yr, %x
  %cmp2 = icmp slt i32 %0, 5
  %and = and i1 %cmp, %cmp2
  ret i1 %and
}

define i1 @f_add_nuw(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @f_add_nuw(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret i1 false
;
entry:
  %cmp = icmp ugt i32 %x, 1
  %0 = add nuw i32 %x, %y
  %cmp2 = icmp eq i32 %0, 1
  %and = and i1 %cmp, %cmp2
  ret i1 %and
}

define i1 @f_sub_nsw(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @f_sub_nsw(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[X]], 5
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  %yr = and i32 %y, 2147483647
  %cmp = icmp slt i32 %x, 5
  %0 = sub nsw i32 %x, %yr
  %cmp2 = icmp slt i32 %0, 5
  %and = and i1 %cmp, %cmp2
  ret i1 %and
}

define i1 @f_sub_nuw(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @f_sub_nuw(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret i1 false
;
entry:
  %cmp = icmp ult i32 %x, 5
  %0 = sub nuw i32 %x, %y
  %cmp2 = icmp eq i32 %0, 6
  %and = and i1 %cmp, %cmp2
  ret i1 %and
}

; Negative tests

; non-constant range
define i1 @f_add_nofold1(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: define i1 @f_add_nofold1(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]], i32 [[Z:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[YR:%.*]] = and i32 [[Y]], 7
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[X]], [[Z]]
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[YR]], [[X]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ugt i32 [[TMP0]], 16
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[CMP]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[AND]]
;
entry:
  %yr = and i32 %y, 7
  %cmp = icmp ult i32 %x, %z
  %0 = add i32 %yr, %x
  %cmp2 = icmp ugt i32 %0, 16
  %and = and i1 %cmp, %cmp2
  ret i1 %and
}

define i1 @f_add_nofold2(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: define i1 @f_add_nofold2(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]], i32 [[Z:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[YR:%.*]] = and i32 [[Y]], 7
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[X]], 8
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[YR]], [[X]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ugt i32 [[TMP0]], [[Z]]
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[CMP]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[AND]]
;
entry:
  %yr = and i32 %y, 7
  %cmp = icmp ult i32 %x, 8
  %0 = add i32 %yr, %x
  %cmp2 = icmp ugt i32 %0, %z
  %and = and i1 %cmp, %cmp2
  ret i1 %and
}

; narrower range
define i1 @f_add_nofold3(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @f_add_nofold3(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[YR:%.*]] = and i32 [[Y]], 7
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[X]], 8
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[YR]], [[X]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ugt i32 [[TMP0]], 10
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[CMP]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[AND]]
;
entry:
  %yr = and i32 %y, 7
  %cmp = icmp ult i32 %x, 8
  %0 = add i32 %yr, %x
  %cmp2 = icmp ugt i32 %0, 10
  %and = and i1 %cmp, %cmp2
  ret i1 %and
}

; sub is not commutative
define i1 @f_sub_nsw_nofold(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @f_sub_nsw_nofold(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[YR:%.*]] = and i32 [[Y]], 2147483647
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[X]], 5
; CHECK-NEXT:    [[TMP0:%.*]] = sub nsw i32 [[YR]], [[X]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp slt i32 [[TMP0]], 5
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[CMP]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[AND]]
;
entry:
  %yr = and i32 %y, 2147483647
  %cmp = icmp slt i32 %x, 5
  %0 = sub nsw i32 %yr, %x
  %cmp2 = icmp slt i32 %0, 5
  %and = and i1 %cmp, %cmp2
  ret i1 %and
}

define i1 @pr69038(i32 %a, i32 %b) {
; CHECK-LABEL: define i1 @pr69038(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[A]], 0
; CHECK-NEXT:    ret i1 [[TOBOOL]]
;
  %tobool = icmp ne i32 %a, 0
  %or = or i32 %a, %b
  %tobool1 = icmp ne i32 %or, 0
  %and = and i1 %tobool, %tobool1
  ret i1 %and
}
