; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc < %s | FileCheck %s

target triple = "aarch64-unknown-linux-gnu"

define void @inc_add(i32 %first, i32 %N, ptr %in1, ptr %in2, ptr %out) #0 {
; CHECK-LABEL: inc_add:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:    mov w9, w1
; CHECK-NEXT:  .LBB0_1: // %vector.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ld1w { z0.s }, p0/z, [x2, x8, lsl #2]
; CHECK-NEXT:    ld1w { z1.s }, p0/z, [x3, x8, lsl #2]
; CHECK-NEXT:    fmul z0.s, z0.s, z1.s
; CHECK-NEXT:    st1w { z0.s }, p0, [x4, x8, lsl #2]
; CHECK-NEXT:    incw x8
; CHECK-NEXT:    cmp x9, x8
; CHECK-NEXT:    b.ne .LBB0_1
; CHECK-NEXT:  // %bb.2: // %for.cond.cleanup
; CHECK-NEXT:    ret
entry:
  %wide.trip.count = zext i32 %N to i64
  %0 = tail call i64 @llvm.vscale.i64()
  %1 = shl nuw nsw i64 %0, 2
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %entry ], [ %index.next, %vector.body ]
  %2 = getelementptr inbounds float, ptr %in1, i64 %index
  %wide.load = load <vscale x 4 x float>, ptr %2, align 4
  %3 = getelementptr inbounds float, ptr %in2, i64 %index
  %wide.load16 = load <vscale x 4 x float>, ptr %3, align 4
  %4 = fmul <vscale x 4 x float> %wide.load, %wide.load16
  %5 = getelementptr inbounds float, ptr %out, i64 %index
  store <vscale x 4 x float> %4, ptr %5, align 4
  %index.next = add nuw i64 %index, %1
  %6 = icmp eq i64 %index.next, %wide.trip.count
  br i1 %6, label %for.cond.cleanup, label %vector.body

for.cond.cleanup:
  ret void
}

define void @dec_sub(i32 %first, i32 %N, ptr %in1, ptr %in2, ptr %out) #0 {
; CHECK-LABEL: dec_sub:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ptrue p0.s
; CHECK-NEXT:    rdvl x9, #-1
; CHECK-NEXT:    mov w8, w1
; CHECK-NEXT:    add x11, x9, #4
; CHECK-NEXT:    add x9, x2, x11
; CHECK-NEXT:    add x10, x3, x11
; CHECK-NEXT:    add x11, x4, x11
; CHECK-NEXT:  .LBB1_1: // %vector.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ld1w { z0.s }, p0/z, [x9, x8, lsl #2]
; CHECK-NEXT:    ld1w { z1.s }, p0/z, [x10, x8, lsl #2]
; CHECK-NEXT:    fmul z0.s, z0.s, z1.s
; CHECK-NEXT:    st1w { z0.s }, p0, [x11, x8, lsl #2]
; CHECK-NEXT:    decw x8
; CHECK-NEXT:    cbnz x8, .LBB1_1
; CHECK-NEXT:  // %bb.2: // %for.cond.cleanup
; CHECK-NEXT:    ret
entry:
  %0 = zext i32 %N to i64
  %1 = tail call i64 @llvm.vscale.i64()
  %2 = shl nuw nsw i64 %1, 2
  %3 = sub nsw i64 1, %2
  %invariant.gep = getelementptr float, ptr %in1, i64 %3
  %invariant.gep20 = getelementptr float, ptr %in2, i64 %3
  %invariant.gep22 = getelementptr float, ptr %out, i64 %3
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %entry ], [ %index.next, %vector.body ]
  %offset.idx = sub i64 %0, %index
  %gep = getelementptr float, ptr %invariant.gep, i64 %offset.idx
  %wide.load = load <vscale x 4 x float>, ptr %gep, align 4
  %gep21 = getelementptr float, ptr %invariant.gep20, i64 %offset.idx
  %wide.load16 = load <vscale x 4 x float>, ptr %gep21, align 4
  %4 = fmul <vscale x 4 x float> %wide.load, %wide.load16
  %gep23 = getelementptr float, ptr %invariant.gep22, i64 %offset.idx
  store <vscale x 4 x float> %4, ptr %gep23, align 4
  %index.next = add nuw i64 %index, %2
  %5 = icmp eq i64 %index.next, %0
  br i1 %5, label %for.cond.cleanup, label %vector.body

for.cond.cleanup:
  ret void
}

declare i64 @llvm.vscale.i64()

attributes #0 = { "target-features"="+sve2" }
