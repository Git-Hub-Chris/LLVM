; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s | FileCheck %s
target triple = "arm64-none-linux-gnu"

define float @test_vfmas_lane_f32(float %a, float %b, <2 x float> %c) #0 {
; CHECK-LABEL: test_vfmas_lane_f32:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    // kill: def $d2 killed $d2 def $q2
; CHECK-NEXT:    fmla s0, s1, v2.s[1]
; CHECK-NEXT:    ret
entry:
  %extract = extractelement <2 x float> %c, i64 1
  %0 = call float @llvm.fma.f32(float %b, float %extract, float %a)
  ret float %0
}

define double @test_vfmad_lane_f64(double %a, double %b, <1 x double> %c) #0 {
; CHECK-LABEL: test_vfmad_lane_f64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fmadd d0, d1, d2, d0
; CHECK-NEXT:    ret
entry:
  %extract = extractelement <1 x double> %c, i64 0
  %0 = call double @llvm.fma.f64(double %b, double %extract, double %a)
  ret double %0
}

define double @test_vfmad_laneq_f64(double %a, double %b, <2 x double> %c) #0 {
; CHECK-LABEL: test_vfmad_laneq_f64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fmla d0, d1, v2.d[1]
; CHECK-NEXT:    ret
entry:
  %extract = extractelement <2 x double> %c, i64 1
  %0 = call double @llvm.fma.f64(double %b, double %extract, double %a)
  ret double %0
}

define float @test_vfmss_lane_f32(float %a, float %b, <2 x float> %c) #0 {
; CHECK-LABEL: test_vfmss_lane_f32:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    // kill: def $d2 killed $d2 def $q2
; CHECK-NEXT:    fmls s0, s1, v2.s[1]
; CHECK-NEXT:    ret
entry:
  %fneg = fneg float %b
  %extract = extractelement <2 x float> %c, i64 1
  %0 = call float @llvm.fma.f32(float %fneg, float %extract, float %a)
  ret float %0
}

define <1 x double> @test_vfma_lane_f64(<1 x double> %a, <1 x double> %b, <1 x double> %v) #0 {
; CHECK-LABEL: test_vfma_lane_f64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fmadd d0, d1, d2, d0
; CHECK-NEXT:    ret
entry:
  %fmla2 = call <1 x double> @llvm.fma.v1f64(<1 x double> %b, <1 x double> %v, <1 x double> %a)
  ret <1 x double> %fmla2
}

define <1 x double> @test_vfms_lane_f64(<1 x double> %a, <1 x double> %b, <1 x double> %v) #0 {
; CHECK-LABEL: test_vfms_lane_f64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fmsub d0, d1, d2, d0
; CHECK-NEXT:    ret
entry:
  %fneg = fneg <1 x double> %b
  %fmla2 = call <1 x double> @llvm.fma.v1f64(<1 x double> %fneg, <1 x double> %v, <1 x double> %a)
  ret <1 x double> %fmla2
}

define <1 x double> @test_vfma_laneq_f64(<1 x double> %a, <1 x double> %b, <2 x double> %v) #0 {
; CHECK-LABEL: test_vfma_laneq_f64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fmadd d0, d1, d2, d0
; CHECK-NEXT:    ret
entry:
  %0 = extractelement <1 x double> %a, i64 0
  %1 = extractelement <1 x double> %b, i64 0
  %extract = extractelement <2 x double> %v, i64 0
  %2 = call double @llvm.fma.f64(double %1, double %extract, double %0)
  %3 = bitcast double %2 to <1 x double>
  ret <1 x double> %3
}

define <1 x double> @test_vfms_laneq_f64(<1 x double> %a, <1 x double> %b, <2 x double> %v) #0 {
; CHECK-LABEL: test_vfms_laneq_f64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fmsub d0, d2, d1, d0
; CHECK-NEXT:    ret
entry:
  %0 = extractelement <1 x double> %a, i64 0
  %1 = extractelement <1 x double> %b, i64 0
  %2 = fneg double %1
  %extract = extractelement <2 x double> %v, i64 0
  %3 = call double @llvm.fma.f64(double %2, double %extract, double %0)
  %4 = bitcast double %3 to <1 x double>
  ret <1 x double> %4
}

attributes #0 = { noinline nounwind "no-trapping-math"="true" "target-cpu"="cyclone" "target-features"="+neon" }

