; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc -mtriple=arm-linux-gnueabihf -o - %s 2>&1 | FileCheck %s

; The intent of this test is 3 fold:
; 1. The first asm demonstrates a change in behavior of using sp.
; 2. The second asm is a case the previously would cause register exhaustion
; due to not using sp.
; 3. The third asm demonstrates ARMAsmPrinter::PrintAsmMemoryOperand not
; needing to print an offset when the offset is zero, and that we get the other
; alloca's offset correct.
define void @fail() {
; CHECK-LABEL: fail:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    .save {r4, r5, r6, r7, r8, r9, r10, r11, lr}
; CHECK-NEXT:    push {r4, r5, r6, r7, r8, r9, r10, r11, lr}
; CHECK-NEXT:    .pad #8
; CHECK-NEXT:    sub sp, sp, #8
; CHECK-NEXT:    mov r0, #42
; CHECK-NEXT:    str r0, [sp, #4]
; CHECK-NEXT:    @APP
; CHECK-NEXT:    @ [sp, #4]
; CHECK-NEXT:    @NO_APP
; CHECK-NEXT:    @APP
; CHECK-NEXT:    @ [sp, #4]
; CHECK-NEXT:    @NO_APP
; CHECK-NEXT:    mov r0, #99
; CHECK-NEXT:    str r0, [sp]
; CHECK-NEXT:    @APP
; CHECK-NEXT:    @ [sp]
; CHECK-NEXT:    @NO_APP
; CHECK-NEXT:    add sp, sp, #8
; CHECK-NEXT:    pop {r4, r5, r6, r7, r8, r9, r10, r11, lr}
; CHECK-NEXT:    mov pc, lr
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  store i32 42, ptr %x
  call void asm sideeffect "# $0", "*m,~{r1},~{r2},~{r3},~{r12},~{lr},~{r4},~{r5},~{r6},~{r7},~{r8},~{r9},~{r10},~{r11}"(ptr elementtype(i32) %x)
  call void asm sideeffect "# $0", "*m,~{r0},~{r1},~{r2},~{r3},~{r12},~{lr},~{r4},~{r5},~{r6},~{r7},~{r8},~{r9},~{r10},~{r11}"(ptr elementtype(i32) %x)
  store i32 99, ptr %y
  call void asm sideeffect "# $0", "*m,~{r1},~{r2},~{r3},~{r12},~{lr},~{r4},~{r5},~{r6},~{r7},~{r8},~{r9},~{r10},~{r11}"(ptr elementtype(i32) %y)
  ret void
}
