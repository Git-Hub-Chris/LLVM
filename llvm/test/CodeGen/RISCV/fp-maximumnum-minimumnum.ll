; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc --mtriple=riscv32 --mattr=+f,-d,+zfh < %s | FileCheck %s --check-prefix=RV32FH
; RUN: llc --mtriple=riscv32 --mattr=+d,+zfh < %s | FileCheck %s --check-prefix=RV32DH
; RUN: llc --mtriple=riscv64 --mattr=+f,-d,+zfh < %s | FileCheck %s --check-prefix=RV64FH
; RUN: llc --mtriple=riscv64 --mattr=+d,+zfh < %s | FileCheck %s --check-prefix=RV64DH
; RUN: llc --mtriple=riscv32 --mattr=+d,-zfh < %s | FileCheck %s --check-prefix=RV32DNH
; RUN: llc --mtriple=riscv64 --mattr=+d,-zfh < %s | FileCheck %s --check-prefix=RV64DNH

declare float @llvm.maximumnum.f32(float, float)
declare double @llvm.maximumnum.f64(double, double)
declare float @llvm.minimumnum.f32(float, float)
declare double @llvm.minimumnum.f64(double, double)

define float @maximumnum_float(float %x, float %y) {
; RV32FH-LABEL: maximumnum_float:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    fmax.s fa0, fa0, fa1
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: maximumnum_float:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmax.s fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: maximumnum_float:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    fmax.s fa0, fa0, fa1
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: maximumnum_float:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmax.s fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: maximumnum_float:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmax.s fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: maximumnum_float:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmax.s fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call float @llvm.maximumnum.f32(float %x, float %y)
  ret float %z
}

define float @maximumnum_float_nsz(float %x, float %y) {
; RV32FH-LABEL: maximumnum_float_nsz:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    fmax.s fa0, fa0, fa1
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: maximumnum_float_nsz:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmax.s fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: maximumnum_float_nsz:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    fmax.s fa0, fa0, fa1
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: maximumnum_float_nsz:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmax.s fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: maximumnum_float_nsz:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmax.s fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: maximumnum_float_nsz:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmax.s fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call nsz float @llvm.maximumnum.f32(float %x, float %y)
  ret float %z
}

define float @maximumnum_float_nnan(float %x, float %y) {
; RV32FH-LABEL: maximumnum_float_nnan:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    fmax.s fa0, fa0, fa1
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: maximumnum_float_nnan:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmax.s fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: maximumnum_float_nnan:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    fmax.s fa0, fa0, fa1
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: maximumnum_float_nnan:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmax.s fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: maximumnum_float_nnan:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmax.s fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: maximumnum_float_nnan:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmax.s fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call nnan float @llvm.maximumnum.f32(float %x, float %y)
  ret float %z
}


define double @maximumnum_double(double %x, double %y) {
; RV32FH-LABEL: maximumnum_double:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    addi sp, sp, -16
; RV32FH-NEXT:    .cfi_def_cfa_offset 16
; RV32FH-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32FH-NEXT:    .cfi_offset ra, -4
; RV32FH-NEXT:    call fmaximum_num
; RV32FH-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32FH-NEXT:    addi sp, sp, 16
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: maximumnum_double:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmax.d fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: maximumnum_double:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    addi sp, sp, -16
; RV64FH-NEXT:    .cfi_def_cfa_offset 16
; RV64FH-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64FH-NEXT:    .cfi_offset ra, -8
; RV64FH-NEXT:    call fmaximum_num
; RV64FH-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64FH-NEXT:    addi sp, sp, 16
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: maximumnum_double:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmax.d fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: maximumnum_double:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmax.d fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: maximumnum_double:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmax.d fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call double @llvm.maximumnum.f64(double %x, double %y)
  ret double %z
}

define double @maximumnum_double_nsz(double %x, double %y) {
; RV32FH-LABEL: maximumnum_double_nsz:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    addi sp, sp, -16
; RV32FH-NEXT:    .cfi_def_cfa_offset 16
; RV32FH-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32FH-NEXT:    .cfi_offset ra, -4
; RV32FH-NEXT:    call fmaximum_num
; RV32FH-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32FH-NEXT:    addi sp, sp, 16
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: maximumnum_double_nsz:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmax.d fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: maximumnum_double_nsz:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    addi sp, sp, -16
; RV64FH-NEXT:    .cfi_def_cfa_offset 16
; RV64FH-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64FH-NEXT:    .cfi_offset ra, -8
; RV64FH-NEXT:    call fmaximum_num
; RV64FH-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64FH-NEXT:    addi sp, sp, 16
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: maximumnum_double_nsz:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmax.d fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: maximumnum_double_nsz:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmax.d fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: maximumnum_double_nsz:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmax.d fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call nsz double @llvm.maximumnum.f64(double %x, double %y)
  ret double %z
}

define double @maximumnum_double_nnan(double %x, double %y) {
; RV32FH-LABEL: maximumnum_double_nnan:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    addi sp, sp, -16
; RV32FH-NEXT:    .cfi_def_cfa_offset 16
; RV32FH-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32FH-NEXT:    .cfi_offset ra, -4
; RV32FH-NEXT:    call fmaximum_num
; RV32FH-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32FH-NEXT:    addi sp, sp, 16
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: maximumnum_double_nnan:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmax.d fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: maximumnum_double_nnan:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    addi sp, sp, -16
; RV64FH-NEXT:    .cfi_def_cfa_offset 16
; RV64FH-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64FH-NEXT:    .cfi_offset ra, -8
; RV64FH-NEXT:    call fmaximum_num
; RV64FH-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64FH-NEXT:    addi sp, sp, 16
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: maximumnum_double_nnan:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmax.d fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: maximumnum_double_nnan:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmax.d fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: maximumnum_double_nnan:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmax.d fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call nnan double @llvm.maximumnum.f64(double %x, double %y)
  ret double %z
}

define float @minimumnum_float(float %x, float %y) {
; RV32FH-LABEL: minimumnum_float:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    fmin.s fa0, fa0, fa1
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: minimumnum_float:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmin.s fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: minimumnum_float:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    fmin.s fa0, fa0, fa1
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: minimumnum_float:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmin.s fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: minimumnum_float:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmin.s fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: minimumnum_float:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmin.s fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call float @llvm.minimumnum.f32(float %x, float %y)
  ret float %z
}

define float @minimumnum_float_nsz(float %x, float %y) {
; RV32FH-LABEL: minimumnum_float_nsz:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    fmin.s fa0, fa0, fa1
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: minimumnum_float_nsz:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmin.s fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: minimumnum_float_nsz:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    fmin.s fa0, fa0, fa1
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: minimumnum_float_nsz:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmin.s fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: minimumnum_float_nsz:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmin.s fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: minimumnum_float_nsz:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmin.s fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call nsz float @llvm.minimumnum.f32(float %x, float %y)
  ret float %z
}

define float @minimumnum_float_nnan(float %x, float %y) {
; RV32FH-LABEL: minimumnum_float_nnan:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    fmin.s fa0, fa0, fa1
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: minimumnum_float_nnan:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmin.s fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: minimumnum_float_nnan:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    fmin.s fa0, fa0, fa1
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: minimumnum_float_nnan:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmin.s fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: minimumnum_float_nnan:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmin.s fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: minimumnum_float_nnan:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmin.s fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call nnan float @llvm.minimumnum.f32(float %x, float %y)
  ret float %z
}

define double @minimumnum_double(double %x, double %y) {
; RV32FH-LABEL: minimumnum_double:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    addi sp, sp, -16
; RV32FH-NEXT:    .cfi_def_cfa_offset 16
; RV32FH-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32FH-NEXT:    .cfi_offset ra, -4
; RV32FH-NEXT:    call fminimum_num
; RV32FH-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32FH-NEXT:    addi sp, sp, 16
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: minimumnum_double:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmin.d fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: minimumnum_double:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    addi sp, sp, -16
; RV64FH-NEXT:    .cfi_def_cfa_offset 16
; RV64FH-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64FH-NEXT:    .cfi_offset ra, -8
; RV64FH-NEXT:    call fminimum_num
; RV64FH-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64FH-NEXT:    addi sp, sp, 16
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: minimumnum_double:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmin.d fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: minimumnum_double:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmin.d fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: minimumnum_double:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmin.d fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call double @llvm.minimumnum.f64(double %x, double %y)
  ret double %z
}

define double @minimumnum_double_nsz(double %x, double %y) {
; RV32FH-LABEL: minimumnum_double_nsz:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    addi sp, sp, -16
; RV32FH-NEXT:    .cfi_def_cfa_offset 16
; RV32FH-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32FH-NEXT:    .cfi_offset ra, -4
; RV32FH-NEXT:    call fminimum_num
; RV32FH-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32FH-NEXT:    addi sp, sp, 16
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: minimumnum_double_nsz:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmin.d fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: minimumnum_double_nsz:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    addi sp, sp, -16
; RV64FH-NEXT:    .cfi_def_cfa_offset 16
; RV64FH-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64FH-NEXT:    .cfi_offset ra, -8
; RV64FH-NEXT:    call fminimum_num
; RV64FH-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64FH-NEXT:    addi sp, sp, 16
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: minimumnum_double_nsz:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmin.d fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: minimumnum_double_nsz:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmin.d fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: minimumnum_double_nsz:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmin.d fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call nsz double @llvm.minimumnum.f64(double %x, double %y)
  ret double %z
}

define double @minimumnum_double_nnan(double %x, double %y) {
; RV32FH-LABEL: minimumnum_double_nnan:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    addi sp, sp, -16
; RV32FH-NEXT:    .cfi_def_cfa_offset 16
; RV32FH-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32FH-NEXT:    .cfi_offset ra, -4
; RV32FH-NEXT:    call fminimum_num
; RV32FH-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32FH-NEXT:    addi sp, sp, 16
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: minimumnum_double_nnan:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmin.d fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: minimumnum_double_nnan:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    addi sp, sp, -16
; RV64FH-NEXT:    .cfi_def_cfa_offset 16
; RV64FH-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64FH-NEXT:    .cfi_offset ra, -8
; RV64FH-NEXT:    call fminimum_num
; RV64FH-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64FH-NEXT:    addi sp, sp, 16
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: minimumnum_double_nnan:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmin.d fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: minimumnum_double_nnan:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    fmin.d fa0, fa0, fa1
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: minimumnum_double_nnan:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    fmin.d fa0, fa0, fa1
; RV64DNH-NEXT:    ret
  %z = call nnan double @llvm.minimumnum.f64(double %x, double %y)
  ret double %z
}

define half @minimumnum_half(half %x, half %y) {
; RV32FH-LABEL: minimumnum_half:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    fmin.h fa0, fa0, fa1
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: minimumnum_half:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmin.h fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: minimumnum_half:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    fmin.h fa0, fa0, fa1
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: minimumnum_half:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmin.h fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: minimumnum_half:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    addi sp, sp, -32
; RV32DNH-NEXT:    .cfi_def_cfa_offset 32
; RV32DNH-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32DNH-NEXT:    fsd fs0, 16(sp) # 8-byte Folded Spill
; RV32DNH-NEXT:    fsd fs1, 8(sp) # 8-byte Folded Spill
; RV32DNH-NEXT:    .cfi_offset ra, -4
; RV32DNH-NEXT:    .cfi_offset fs0, -16
; RV32DNH-NEXT:    .cfi_offset fs1, -24
; RV32DNH-NEXT:    fmv.s fs0, fa0
; RV32DNH-NEXT:    fmv.s fa0, fa1
; RV32DNH-NEXT:    call __extendhfsf2
; RV32DNH-NEXT:    fmv.s fs1, fa0
; RV32DNH-NEXT:    fmv.s fa0, fs0
; RV32DNH-NEXT:    call __extendhfsf2
; RV32DNH-NEXT:    fmin.s fa0, fa0, fs1
; RV32DNH-NEXT:    call __truncsfhf2
; RV32DNH-NEXT:    fmv.x.w a0, fa0
; RV32DNH-NEXT:    lui a1, 1048560
; RV32DNH-NEXT:    or a0, a0, a1
; RV32DNH-NEXT:    fmv.w.x fa0, a0
; RV32DNH-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32DNH-NEXT:    fld fs0, 16(sp) # 8-byte Folded Reload
; RV32DNH-NEXT:    fld fs1, 8(sp) # 8-byte Folded Reload
; RV32DNH-NEXT:    addi sp, sp, 32
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: minimumnum_half:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    addi sp, sp, -32
; RV64DNH-NEXT:    .cfi_def_cfa_offset 32
; RV64DNH-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64DNH-NEXT:    fsd fs0, 16(sp) # 8-byte Folded Spill
; RV64DNH-NEXT:    fsd fs1, 8(sp) # 8-byte Folded Spill
; RV64DNH-NEXT:    .cfi_offset ra, -8
; RV64DNH-NEXT:    .cfi_offset fs0, -16
; RV64DNH-NEXT:    .cfi_offset fs1, -24
; RV64DNH-NEXT:    fmv.s fs0, fa0
; RV64DNH-NEXT:    fmv.s fa0, fa1
; RV64DNH-NEXT:    call __extendhfsf2
; RV64DNH-NEXT:    fmv.s fs1, fa0
; RV64DNH-NEXT:    fmv.s fa0, fs0
; RV64DNH-NEXT:    call __extendhfsf2
; RV64DNH-NEXT:    fmin.s fa0, fa0, fs1
; RV64DNH-NEXT:    call __truncsfhf2
; RV64DNH-NEXT:    fmv.x.w a0, fa0
; RV64DNH-NEXT:    lui a1, 1048560
; RV64DNH-NEXT:    or a0, a0, a1
; RV64DNH-NEXT:    fmv.w.x fa0, a0
; RV64DNH-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64DNH-NEXT:    fld fs0, 16(sp) # 8-byte Folded Reload
; RV64DNH-NEXT:    fld fs1, 8(sp) # 8-byte Folded Reload
; RV64DNH-NEXT:    addi sp, sp, 32
; RV64DNH-NEXT:    ret
  %z = call half @llvm.minimumnum.f16(half %x, half %y)
  ret half %z
}

define half @minimumnum_half_nsz(half %x, half %y) {
; RV32FH-LABEL: minimumnum_half_nsz:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    fmin.h fa0, fa0, fa1
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: minimumnum_half_nsz:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmin.h fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: minimumnum_half_nsz:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    fmin.h fa0, fa0, fa1
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: minimumnum_half_nsz:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmin.h fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: minimumnum_half_nsz:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    addi sp, sp, -32
; RV32DNH-NEXT:    .cfi_def_cfa_offset 32
; RV32DNH-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32DNH-NEXT:    fsd fs0, 16(sp) # 8-byte Folded Spill
; RV32DNH-NEXT:    fsd fs1, 8(sp) # 8-byte Folded Spill
; RV32DNH-NEXT:    .cfi_offset ra, -4
; RV32DNH-NEXT:    .cfi_offset fs0, -16
; RV32DNH-NEXT:    .cfi_offset fs1, -24
; RV32DNH-NEXT:    fmv.s fs0, fa0
; RV32DNH-NEXT:    fmv.s fa0, fa1
; RV32DNH-NEXT:    call __extendhfsf2
; RV32DNH-NEXT:    fmv.s fs1, fa0
; RV32DNH-NEXT:    fmv.s fa0, fs0
; RV32DNH-NEXT:    call __extendhfsf2
; RV32DNH-NEXT:    fmin.s fa0, fa0, fs1
; RV32DNH-NEXT:    call __truncsfhf2
; RV32DNH-NEXT:    fmv.x.w a0, fa0
; RV32DNH-NEXT:    lui a1, 1048560
; RV32DNH-NEXT:    or a0, a0, a1
; RV32DNH-NEXT:    fmv.w.x fa0, a0
; RV32DNH-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32DNH-NEXT:    fld fs0, 16(sp) # 8-byte Folded Reload
; RV32DNH-NEXT:    fld fs1, 8(sp) # 8-byte Folded Reload
; RV32DNH-NEXT:    addi sp, sp, 32
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: minimumnum_half_nsz:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    addi sp, sp, -32
; RV64DNH-NEXT:    .cfi_def_cfa_offset 32
; RV64DNH-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64DNH-NEXT:    fsd fs0, 16(sp) # 8-byte Folded Spill
; RV64DNH-NEXT:    fsd fs1, 8(sp) # 8-byte Folded Spill
; RV64DNH-NEXT:    .cfi_offset ra, -8
; RV64DNH-NEXT:    .cfi_offset fs0, -16
; RV64DNH-NEXT:    .cfi_offset fs1, -24
; RV64DNH-NEXT:    fmv.s fs0, fa0
; RV64DNH-NEXT:    fmv.s fa0, fa1
; RV64DNH-NEXT:    call __extendhfsf2
; RV64DNH-NEXT:    fmv.s fs1, fa0
; RV64DNH-NEXT:    fmv.s fa0, fs0
; RV64DNH-NEXT:    call __extendhfsf2
; RV64DNH-NEXT:    fmin.s fa0, fa0, fs1
; RV64DNH-NEXT:    call __truncsfhf2
; RV64DNH-NEXT:    fmv.x.w a0, fa0
; RV64DNH-NEXT:    lui a1, 1048560
; RV64DNH-NEXT:    or a0, a0, a1
; RV64DNH-NEXT:    fmv.w.x fa0, a0
; RV64DNH-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64DNH-NEXT:    fld fs0, 16(sp) # 8-byte Folded Reload
; RV64DNH-NEXT:    fld fs1, 8(sp) # 8-byte Folded Reload
; RV64DNH-NEXT:    addi sp, sp, 32
; RV64DNH-NEXT:    ret
  %z = call nsz half @llvm.minimumnum.f16(half %x, half %y)
  ret half %z
}

define half @minimumnum_half_nnan(half %x, half %y) {
; RV32FH-LABEL: minimumnum_half_nnan:
; RV32FH:       # %bb.0:
; RV32FH-NEXT:    fmin.h fa0, fa0, fa1
; RV32FH-NEXT:    ret
;
; RV32DH-LABEL: minimumnum_half_nnan:
; RV32DH:       # %bb.0:
; RV32DH-NEXT:    fmin.h fa0, fa0, fa1
; RV32DH-NEXT:    ret
;
; RV64FH-LABEL: minimumnum_half_nnan:
; RV64FH:       # %bb.0:
; RV64FH-NEXT:    fmin.h fa0, fa0, fa1
; RV64FH-NEXT:    ret
;
; RV64DH-LABEL: minimumnum_half_nnan:
; RV64DH:       # %bb.0:
; RV64DH-NEXT:    fmin.h fa0, fa0, fa1
; RV64DH-NEXT:    ret
;
; RV32DNH-LABEL: minimumnum_half_nnan:
; RV32DNH:       # %bb.0:
; RV32DNH-NEXT:    addi sp, sp, -32
; RV32DNH-NEXT:    .cfi_def_cfa_offset 32
; RV32DNH-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32DNH-NEXT:    fsd fs0, 16(sp) # 8-byte Folded Spill
; RV32DNH-NEXT:    fsd fs1, 8(sp) # 8-byte Folded Spill
; RV32DNH-NEXT:    .cfi_offset ra, -4
; RV32DNH-NEXT:    .cfi_offset fs0, -16
; RV32DNH-NEXT:    .cfi_offset fs1, -24
; RV32DNH-NEXT:    fmv.s fs0, fa0
; RV32DNH-NEXT:    fmv.s fa0, fa1
; RV32DNH-NEXT:    call __extendhfsf2
; RV32DNH-NEXT:    fmv.s fs1, fa0
; RV32DNH-NEXT:    fmv.s fa0, fs0
; RV32DNH-NEXT:    call __extendhfsf2
; RV32DNH-NEXT:    fmin.s fa0, fa0, fs1
; RV32DNH-NEXT:    call __truncsfhf2
; RV32DNH-NEXT:    fmv.x.w a0, fa0
; RV32DNH-NEXT:    lui a1, 1048560
; RV32DNH-NEXT:    or a0, a0, a1
; RV32DNH-NEXT:    fmv.w.x fa0, a0
; RV32DNH-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32DNH-NEXT:    fld fs0, 16(sp) # 8-byte Folded Reload
; RV32DNH-NEXT:    fld fs1, 8(sp) # 8-byte Folded Reload
; RV32DNH-NEXT:    addi sp, sp, 32
; RV32DNH-NEXT:    ret
;
; RV64DNH-LABEL: minimumnum_half_nnan:
; RV64DNH:       # %bb.0:
; RV64DNH-NEXT:    addi sp, sp, -32
; RV64DNH-NEXT:    .cfi_def_cfa_offset 32
; RV64DNH-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64DNH-NEXT:    fsd fs0, 16(sp) # 8-byte Folded Spill
; RV64DNH-NEXT:    fsd fs1, 8(sp) # 8-byte Folded Spill
; RV64DNH-NEXT:    .cfi_offset ra, -8
; RV64DNH-NEXT:    .cfi_offset fs0, -16
; RV64DNH-NEXT:    .cfi_offset fs1, -24
; RV64DNH-NEXT:    fmv.s fs0, fa0
; RV64DNH-NEXT:    fmv.s fa0, fa1
; RV64DNH-NEXT:    call __extendhfsf2
; RV64DNH-NEXT:    fmv.s fs1, fa0
; RV64DNH-NEXT:    fmv.s fa0, fs0
; RV64DNH-NEXT:    call __extendhfsf2
; RV64DNH-NEXT:    fmin.s fa0, fa0, fs1
; RV64DNH-NEXT:    call __truncsfhf2
; RV64DNH-NEXT:    fmv.x.w a0, fa0
; RV64DNH-NEXT:    lui a1, 1048560
; RV64DNH-NEXT:    or a0, a0, a1
; RV64DNH-NEXT:    fmv.w.x fa0, a0
; RV64DNH-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64DNH-NEXT:    fld fs0, 16(sp) # 8-byte Folded Reload
; RV64DNH-NEXT:    fld fs1, 8(sp) # 8-byte Folded Reload
; RV64DNH-NEXT:    addi sp, sp, 32
; RV64DNH-NEXT:    ret
  %z = call nnan half @llvm.minimumnum.f16(half %x, half %y)
  ret half %z
}

