; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple riscv32 -mattr=+m,+f,+d,+v,+zvfhmin,+zvfbfmin < %s | FileCheck %s --check-prefixes=CHECK,ZVFHMIN64
; RUN: llc -mtriple riscv64 -mattr=+m,+f,+d,+v,+zvfhmin,+zvfbfmin < %s | FileCheck %s --check-prefixes=CHECK,ZVFHMIN32
; RUN: llc -mtriple riscv32 -mattr=+m,+f,+d,+v,+zvfh,+zvfbfmin < %s | FileCheck %s --check-prefixes=CHECK,ZVFH32
; RUN: llc -mtriple riscv64 -mattr=+m,+f,+d,+v,+zvfh,+zvfbfmin < %s | FileCheck %s --check-prefixes=CHECK,ZVFH64

; Tests assume VLEN=128 or vscale_range_min=2.

declare <vscale x 1 x i1> @llvm.vector.splice.nxv1i1(<vscale x 1 x i1>, <vscale x 1 x i1>, i32)

define <vscale x 1 x i1> @splice_nxv1i1_offset_negone(<vscale x 1 x i1> %a, <vscale x 1 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv1i1_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, mf8, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v9, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vslidedown.vx v9, v9, a0
; CHECK-NEXT:    vslideup.vi v9, v8, 1
; CHECK-NEXT:    vand.vi v8, v9, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i1> @llvm.vector.splice.nxv1i1(<vscale x 1 x i1> %a, <vscale x 1 x i1> %b, i32 -1)
  ret <vscale x 1 x i1> %res
}

define <vscale x 1 x i1> @splice_nxv1i1_offset_max(<vscale x 1 x i1> %a, <vscale x 1 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv1i1_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, mf8, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v9, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli zero, a0, e8, mf8, ta, ma
; CHECK-NEXT:    vslidedown.vi v9, v9, 1
; CHECK-NEXT:    vsetvli a1, zero, e8, mf8, ta, ma
; CHECK-NEXT:    vslideup.vx v9, v8, a0
; CHECK-NEXT:    vand.vi v8, v9, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i1> @llvm.vector.splice.nxv1i1(<vscale x 1 x i1> %a, <vscale x 1 x i1> %b, i32 1)
  ret <vscale x 1 x i1> %res
}

declare <vscale x 2 x i1> @llvm.vector.splice.nxv2i1(<vscale x 2 x i1>, <vscale x 2 x i1>, i32)

define <vscale x 2 x i1> @splice_nxv2i1_offset_negone(<vscale x 2 x i1> %a, <vscale x 2 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv2i1_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, mf4, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v9, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vslidedown.vx v9, v9, a0
; CHECK-NEXT:    vslideup.vi v9, v8, 1
; CHECK-NEXT:    vand.vi v8, v9, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i1> @llvm.vector.splice.nxv2i1(<vscale x 2 x i1> %a, <vscale x 2 x i1> %b, i32 -1)
  ret <vscale x 2 x i1> %res
}

define <vscale x 2 x i1> @splice_nxv2i1_offset_max(<vscale x 2 x i1> %a, <vscale x 2 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv2i1_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, mf4, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v9, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -3
; CHECK-NEXT:    vsetvli zero, a0, e8, mf4, ta, ma
; CHECK-NEXT:    vslidedown.vi v9, v9, 3
; CHECK-NEXT:    vsetvli a1, zero, e8, mf4, ta, ma
; CHECK-NEXT:    vslideup.vx v9, v8, a0
; CHECK-NEXT:    vand.vi v8, v9, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i1> @llvm.vector.splice.nxv2i1(<vscale x 2 x i1> %a, <vscale x 2 x i1> %b, i32 3)
  ret <vscale x 2 x i1> %res
}

declare <vscale x 4 x i1> @llvm.vector.splice.nxv4i1(<vscale x 4 x i1>, <vscale x 4 x i1>, i32)

define <vscale x 4 x i1> @splice_nxv4i1_offset_negone(<vscale x 4 x i1> %a, <vscale x 4 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv4i1_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, mf2, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v9, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vslidedown.vx v9, v9, a0
; CHECK-NEXT:    vslideup.vi v9, v8, 1
; CHECK-NEXT:    vand.vi v8, v9, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i1> @llvm.vector.splice.nxv4i1(<vscale x 4 x i1> %a, <vscale x 4 x i1> %b, i32 -1)
  ret <vscale x 4 x i1> %res
}

define <vscale x 4 x i1> @splice_nxv4i1_offset_max(<vscale x 4 x i1> %a, <vscale x 4 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv4i1_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, mf2, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v9, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -7
; CHECK-NEXT:    vsetvli zero, a0, e8, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vi v9, v9, 7
; CHECK-NEXT:    vsetvli a1, zero, e8, mf2, ta, ma
; CHECK-NEXT:    vslideup.vx v9, v8, a0
; CHECK-NEXT:    vand.vi v8, v9, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i1> @llvm.vector.splice.nxv4i1(<vscale x 4 x i1> %a, <vscale x 4 x i1> %b, i32 7)
  ret <vscale x 4 x i1> %res
}

declare <vscale x 8 x i1> @llvm.vector.splice.nxv8i1(<vscale x 8 x i1>, <vscale x 8 x i1>, i32)

define <vscale x 8 x i1> @splice_nxv8i1_offset_negone(<vscale x 8 x i1> %a, <vscale x 8 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv8i1_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, m1, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v9, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vslidedown.vx v9, v9, a0
; CHECK-NEXT:    vslideup.vi v9, v8, 1
; CHECK-NEXT:    vand.vi v8, v9, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i1> @llvm.vector.splice.nxv8i1(<vscale x 8 x i1> %a, <vscale x 8 x i1> %b, i32 -1)
  ret <vscale x 8 x i1> %res
}

define <vscale x 8 x i1> @splice_nxv8i1_offset_max(<vscale x 8 x i1> %a, <vscale x 8 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv8i1_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, m1, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v9, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -15
; CHECK-NEXT:    vsetvli zero, a0, e8, m1, ta, ma
; CHECK-NEXT:    vslidedown.vi v9, v9, 15
; CHECK-NEXT:    vsetvli a1, zero, e8, m1, ta, ma
; CHECK-NEXT:    vslideup.vx v9, v8, a0
; CHECK-NEXT:    vand.vi v8, v9, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i1> @llvm.vector.splice.nxv8i1(<vscale x 8 x i1> %a, <vscale x 8 x i1> %b, i32 15)
  ret <vscale x 8 x i1> %res
}

declare <vscale x 16 x i1> @llvm.vector.splice.nxv16i1(<vscale x 16 x i1>, <vscale x 16 x i1>, i32)

define <vscale x 16 x i1> @splice_nxv16i1_offset_negone(<vscale x 16 x i1> %a, <vscale x 16 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv16i1_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, m2, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v12, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v12, 1
; CHECK-NEXT:    vand.vi v8, v8, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i1> @llvm.vector.splice.nxv16i1(<vscale x 16 x i1> %a, <vscale x 16 x i1> %b, i32 -1)
  ret <vscale x 16 x i1> %res
}

define <vscale x 16 x i1> @splice_nxv16i1_offset_max(<vscale x 16 x i1> %a, <vscale x 16 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv16i1_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, m2, ta, ma
; CHECK-NEXT:    vmv.v.i v10, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v12, v10, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v8, v10, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -31
; CHECK-NEXT:    vsetvli zero, a0, e8, m2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 31
; CHECK-NEXT:    vsetvli a1, zero, e8, m2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v12, a0
; CHECK-NEXT:    vand.vi v8, v8, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i1> @llvm.vector.splice.nxv16i1(<vscale x 16 x i1> %a, <vscale x 16 x i1> %b, i32 31)
  ret <vscale x 16 x i1> %res
}

declare <vscale x 32 x i1> @llvm.vector.splice.nxv32i1(<vscale x 32 x i1>, <vscale x 32 x i1>, i32)

define <vscale x 32 x i1> @splice_nxv32i1_offset_negone(<vscale x 32 x i1> %a, <vscale x 32 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv32i1_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, m4, ta, ma
; CHECK-NEXT:    vmv.v.i v12, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v16, v12, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v8, v12, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v16, 1
; CHECK-NEXT:    vand.vi v8, v8, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i1> @llvm.vector.splice.nxv32i1(<vscale x 32 x i1> %a, <vscale x 32 x i1> %b, i32 -1)
  ret <vscale x 32 x i1> %res
}

define <vscale x 32 x i1> @splice_nxv32i1_offset_max(<vscale x 32 x i1> %a, <vscale x 32 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv32i1_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, zero, e8, m4, ta, ma
; CHECK-NEXT:    vmv.v.i v12, 0
; CHECK-NEXT:    vmerge.vim v16, v12, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -63
; CHECK-NEXT:    li a1, 63
; CHECK-NEXT:    vsetvli zero, a0, e8, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v16, v16, a1
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vsetvli a1, zero, e8, m4, ta, ma
; CHECK-NEXT:    vmerge.vim v8, v12, 1, v0
; CHECK-NEXT:    vslideup.vx v16, v8, a0
; CHECK-NEXT:    vand.vi v8, v16, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i1> @llvm.vector.splice.nxv32i1(<vscale x 32 x i1> %a, <vscale x 32 x i1> %b, i32 63)
  ret <vscale x 32 x i1> %res
}

declare <vscale x 64 x i1> @llvm.vector.splice.nxv64i1(<vscale x 64 x i1>, <vscale x 64 x i1>, i32)

define <vscale x 64 x i1> @splice_nxv64i1_offset_negone(<vscale x 64 x i1> %a, <vscale x 64 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv64i1_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmv1r.v v9, v0
; CHECK-NEXT:    vsetvli a0, zero, e8, m8, ta, ma
; CHECK-NEXT:    vmv.v.i v24, 0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v16, v24, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v9
; CHECK-NEXT:    vmerge.vim v8, v24, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v16, 1
; CHECK-NEXT:    vand.vi v8, v8, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 64 x i1> @llvm.vector.splice.nxv64i1(<vscale x 64 x i1> %a, <vscale x 64 x i1> %b, i32 -1)
  ret <vscale x 64 x i1> %res
}

define <vscale x 64 x i1> @splice_nxv64i1_offset_max(<vscale x 64 x i1> %a, <vscale x 64 x i1> %b) #0 {
; CHECK-LABEL: splice_nxv64i1_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, zero, e8, m8, ta, ma
; CHECK-NEXT:    vmv.v.i v16, 0
; CHECK-NEXT:    vmerge.vim v24, v16, 1, v0
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -127
; CHECK-NEXT:    li a1, 127
; CHECK-NEXT:    vsetvli zero, a0, e8, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v24, v24, a1
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vsetvli a1, zero, e8, m8, ta, ma
; CHECK-NEXT:    vmerge.vim v8, v16, 1, v0
; CHECK-NEXT:    vslideup.vx v24, v8, a0
; CHECK-NEXT:    vand.vi v8, v24, 1
; CHECK-NEXT:    vmsne.vi v0, v8, 0
; CHECK-NEXT:    ret
  %res = call <vscale x 64 x i1> @llvm.vector.splice.nxv64i1(<vscale x 64 x i1> %a, <vscale x 64 x i1> %b, i32 127)
  ret <vscale x 64 x i1> %res
}

declare <vscale x 1 x i8> @llvm.vector.splice.nxv1i8(<vscale x 1 x i8>, <vscale x 1 x i8>, i32)

define <vscale x 1 x i8> @splice_nxv1i8_offset_zero(<vscale x 1 x i8> %a, <vscale x 1 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv1i8_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i8> @llvm.vector.splice.nxv1i8(<vscale x 1 x i8> %a, <vscale x 1 x i8> %b, i32 0)
  ret <vscale x 1 x i8> %res
}

define <vscale x 1 x i8> @splice_nxv1i8_offset_negone(<vscale x 1 x i8> %a, <vscale x 1 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv1i8_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e8, mf8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i8> @llvm.vector.splice.nxv1i8(<vscale x 1 x i8> %a, <vscale x 1 x i8> %b, i32 -1)
  ret <vscale x 1 x i8> %res
}

define <vscale x 1 x i8> @splice_nxv1i8_offset_min(<vscale x 1 x i8> %a, <vscale x 1 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv1i8_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vsetivli zero, 2, e8, mf8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, mf8, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 2
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i8> @llvm.vector.splice.nxv1i8(<vscale x 1 x i8> %a, <vscale x 1 x i8> %b, i32 -2)
  ret <vscale x 1 x i8> %res
}

define <vscale x 1 x i8> @splice_nxv1i8_offset_max(<vscale x 1 x i8> %a, <vscale x 1 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv1i8_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli zero, a0, e8, mf8, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 1
; CHECK-NEXT:    vsetvli a1, zero, e8, mf8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i8> @llvm.vector.splice.nxv1i8(<vscale x 1 x i8> %a, <vscale x 1 x i8> %b, i32 1)
  ret <vscale x 1 x i8> %res
}

declare <vscale x 2 x i8> @llvm.vector.splice.nxv2i8(<vscale x 2 x i8>, <vscale x 2 x i8>, i32)

define <vscale x 2 x i8> @splice_nxv2i8_offset_zero(<vscale x 2 x i8> %a, <vscale x 2 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv2i8_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i8> @llvm.vector.splice.nxv2i8(<vscale x 2 x i8> %a, <vscale x 2 x i8> %b, i32 0)
  ret <vscale x 2 x i8> %res
}

define <vscale x 2 x i8> @splice_nxv2i8_offset_negone(<vscale x 2 x i8> %a, <vscale x 2 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv2i8_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e8, mf4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i8> @llvm.vector.splice.nxv2i8(<vscale x 2 x i8> %a, <vscale x 2 x i8> %b, i32 -1)
  ret <vscale x 2 x i8> %res
}

define <vscale x 2 x i8> @splice_nxv2i8_offset_min(<vscale x 2 x i8> %a, <vscale x 2 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv2i8_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -4
; CHECK-NEXT:    vsetivli zero, 4, e8, mf4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, mf4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 4
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i8> @llvm.vector.splice.nxv2i8(<vscale x 2 x i8> %a, <vscale x 2 x i8> %b, i32 -4)
  ret <vscale x 2 x i8> %res
}

define <vscale x 2 x i8> @splice_nxv2i8_offset_max(<vscale x 2 x i8> %a, <vscale x 2 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv2i8_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -3
; CHECK-NEXT:    vsetvli zero, a0, e8, mf4, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 3
; CHECK-NEXT:    vsetvli a1, zero, e8, mf4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i8> @llvm.vector.splice.nxv2i8(<vscale x 2 x i8> %a, <vscale x 2 x i8> %b, i32 3)
  ret <vscale x 2 x i8> %res
}

declare <vscale x 4 x i8> @llvm.vector.splice.nxv4i8(<vscale x 4 x i8>, <vscale x 4 x i8>, i32)

define <vscale x 4 x i8> @splice_nxv4i8_offset_zero(<vscale x 4 x i8> %a, <vscale x 4 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv4i8_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i8> @llvm.vector.splice.nxv4i8(<vscale x 4 x i8> %a, <vscale x 4 x i8> %b, i32 0)
  ret <vscale x 4 x i8> %res
}

define <vscale x 4 x i8> @splice_nxv4i8_offset_negone(<vscale x 4 x i8> %a, <vscale x 4 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv4i8_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e8, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i8> @llvm.vector.splice.nxv4i8(<vscale x 4 x i8> %a, <vscale x 4 x i8> %b, i32 -1)
  ret <vscale x 4 x i8> %res
}

define <vscale x 4 x i8> @splice_nxv4i8_offset_min(<vscale x 4 x i8> %a, <vscale x 4 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv4i8_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -8
; CHECK-NEXT:    vsetivli zero, 8, e8, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, mf2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 8
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i8> @llvm.vector.splice.nxv4i8(<vscale x 4 x i8> %a, <vscale x 4 x i8> %b, i32 -8)
  ret <vscale x 4 x i8> %res
}

define <vscale x 4 x i8> @splice_nxv4i8_offset_max(<vscale x 4 x i8> %a, <vscale x 4 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv4i8_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -7
; CHECK-NEXT:    vsetvli zero, a0, e8, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 7
; CHECK-NEXT:    vsetvli a1, zero, e8, mf2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i8> @llvm.vector.splice.nxv4i8(<vscale x 4 x i8> %a, <vscale x 4 x i8> %b, i32 7)
  ret <vscale x 4 x i8> %res
}

declare <vscale x 8 x i8> @llvm.vector.splice.nxv8i8(<vscale x 8 x i8>, <vscale x 8 x i8>, i32)

define <vscale x 8 x i8> @splice_nxv8i8_offset_zero(<vscale x 8 x i8> %a, <vscale x 8 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv8i8_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i8> @llvm.vector.splice.nxv8i8(<vscale x 8 x i8> %a, <vscale x 8 x i8> %b, i32 0)
  ret <vscale x 8 x i8> %res
}

define <vscale x 8 x i8> @splice_nxv8i8_offset_negone(<vscale x 8 x i8> %a, <vscale x 8 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv8i8_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e8, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i8> @llvm.vector.splice.nxv8i8(<vscale x 8 x i8> %a, <vscale x 8 x i8> %b, i32 -1)
  ret <vscale x 8 x i8> %res
}

define <vscale x 8 x i8> @splice_nxv8i8_offset_min(<vscale x 8 x i8> %a, <vscale x 8 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv8i8_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -16
; CHECK-NEXT:    vsetivli zero, 16, e8, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, m1, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i8> @llvm.vector.splice.nxv8i8(<vscale x 8 x i8> %a, <vscale x 8 x i8> %b, i32 -16)
  ret <vscale x 8 x i8> %res
}

define <vscale x 8 x i8> @splice_nxv8i8_offset_max(<vscale x 8 x i8> %a, <vscale x 8 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv8i8_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -15
; CHECK-NEXT:    vsetvli zero, a0, e8, m1, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 15
; CHECK-NEXT:    vsetvli a1, zero, e8, m1, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i8> @llvm.vector.splice.nxv8i8(<vscale x 8 x i8> %a, <vscale x 8 x i8> %b, i32 15)
  ret <vscale x 8 x i8> %res
}

declare <vscale x 16 x i8> @llvm.vector.splice.nxv16i8(<vscale x 16 x i8>, <vscale x 16 x i8>, i32)

define <vscale x 16 x i8> @splice_nxv16i8_offset_zero(<vscale x 16 x i8> %a, <vscale x 16 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv16i8_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i8> @llvm.vector.splice.nxv16i8(<vscale x 16 x i8> %a, <vscale x 16 x i8> %b, i32 0)
  ret <vscale x 16 x i8> %res
}

define <vscale x 16 x i8> @splice_nxv16i8_offset_negone(<vscale x 16 x i8> %a, <vscale x 16 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv16i8_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e8, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i8> @llvm.vector.splice.nxv16i8(<vscale x 16 x i8> %a, <vscale x 16 x i8> %b, i32 -1)
  ret <vscale x 16 x i8> %res
}

define <vscale x 16 x i8> @splice_nxv16i8_offset_min(<vscale x 16 x i8> %a, <vscale x 16 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv16i8_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -32
; CHECK-NEXT:    li a1, 32
; CHECK-NEXT:    vsetvli zero, a1, e8, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, m2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v10, a1
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i8> @llvm.vector.splice.nxv16i8(<vscale x 16 x i8> %a, <vscale x 16 x i8> %b, i32 -32)
  ret <vscale x 16 x i8> %res
}

define <vscale x 16 x i8> @splice_nxv16i8_offset_max(<vscale x 16 x i8> %a, <vscale x 16 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv16i8_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -31
; CHECK-NEXT:    vsetvli zero, a0, e8, m2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 31
; CHECK-NEXT:    vsetvli a1, zero, e8, m2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v10, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i8> @llvm.vector.splice.nxv16i8(<vscale x 16 x i8> %a, <vscale x 16 x i8> %b, i32 31)
  ret <vscale x 16 x i8> %res
}

declare <vscale x 32 x i8> @llvm.vector.splice.nxv32i8(<vscale x 32 x i8>, <vscale x 32 x i8>, i32)

define <vscale x 32 x i8> @splice_nxv32i8_offset_zero(<vscale x 32 x i8> %a, <vscale x 32 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv32i8_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i8> @llvm.vector.splice.nxv32i8(<vscale x 32 x i8> %a, <vscale x 32 x i8> %b, i32 0)
  ret <vscale x 32 x i8> %res
}

define <vscale x 32 x i8> @splice_nxv32i8_offset_negone(<vscale x 32 x i8> %a, <vscale x 32 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv32i8_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e8, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i8> @llvm.vector.splice.nxv32i8(<vscale x 32 x i8> %a, <vscale x 32 x i8> %b, i32 -1)
  ret <vscale x 32 x i8> %res
}

define <vscale x 32 x i8> @splice_nxv32i8_offset_min(<vscale x 32 x i8> %a, <vscale x 32 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv32i8_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -64
; CHECK-NEXT:    li a1, 64
; CHECK-NEXT:    vsetvli zero, a1, e8, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, m4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v12, a1
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i8> @llvm.vector.splice.nxv32i8(<vscale x 32 x i8> %a, <vscale x 32 x i8> %b, i32 -64)
  ret <vscale x 32 x i8> %res
}

define <vscale x 32 x i8> @splice_nxv32i8_offset_max(<vscale x 32 x i8> %a, <vscale x 32 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv32i8_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -63
; CHECK-NEXT:    li a1, 63
; CHECK-NEXT:    vsetvli zero, a0, e8, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a1
; CHECK-NEXT:    vsetvli a1, zero, e8, m4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v12, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i8> @llvm.vector.splice.nxv32i8(<vscale x 32 x i8> %a, <vscale x 32 x i8> %b, i32 63)
  ret <vscale x 32 x i8> %res
}

declare <vscale x 64 x i8> @llvm.vector.splice.nxv64i8(<vscale x 64 x i8>, <vscale x 64 x i8>, i32)

define <vscale x 64 x i8> @splice_nxv64i8_offset_zero(<vscale x 64 x i8> %a, <vscale x 64 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv64i8_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 64 x i8> @llvm.vector.splice.nxv64i8(<vscale x 64 x i8> %a, <vscale x 64 x i8> %b, i32 0)
  ret <vscale x 64 x i8> %res
}

define <vscale x 64 x i8> @splice_nxv64i8_offset_negone(<vscale x 64 x i8> %a, <vscale x 64 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv64i8_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e8, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, m8, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v16, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 64 x i8> @llvm.vector.splice.nxv64i8(<vscale x 64 x i8> %a, <vscale x 64 x i8> %b, i32 -1)
  ret <vscale x 64 x i8> %res
}

define <vscale x 64 x i8> @splice_nxv64i8_offset_min(<vscale x 64 x i8> %a, <vscale x 64 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv64i8_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -128
; CHECK-NEXT:    li a1, 128
; CHECK-NEXT:    vsetvli zero, a1, e8, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e8, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a1
; CHECK-NEXT:    ret
  %res = call <vscale x 64 x i8> @llvm.vector.splice.nxv64i8(<vscale x 64 x i8> %a, <vscale x 64 x i8> %b, i32 -128)
  ret <vscale x 64 x i8> %res
}

define <vscale x 64 x i8> @splice_nxv64i8_offset_max(<vscale x 64 x i8> %a, <vscale x 64 x i8> %b) #0 {
; CHECK-LABEL: splice_nxv64i8_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -127
; CHECK-NEXT:    li a1, 127
; CHECK-NEXT:    vsetvli zero, a0, e8, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a1
; CHECK-NEXT:    vsetvli a1, zero, e8, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 64 x i8> @llvm.vector.splice.nxv64i8(<vscale x 64 x i8> %a, <vscale x 64 x i8> %b, i32 127)
  ret <vscale x 64 x i8> %res
}

declare <vscale x 1 x i16> @llvm.vector.splice.nxv1i16(<vscale x 1 x i16>, <vscale x 1 x i16>, i32)

define <vscale x 1 x i16> @splice_nxv1i16_offset_zero(<vscale x 1 x i16> %a, <vscale x 1 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv1i16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i16> @llvm.vector.splice.nxv1i16(<vscale x 1 x i16> %a, <vscale x 1 x i16> %b, i32 0)
  ret <vscale x 1 x i16> %res
}

define <vscale x 1 x i16> @splice_nxv1i16_offset_negone(<vscale x 1 x i16> %a, <vscale x 1 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv1i16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i16> @llvm.vector.splice.nxv1i16(<vscale x 1 x i16> %a, <vscale x 1 x i16> %b, i32 -1)
  ret <vscale x 1 x i16> %res
}

define <vscale x 1 x i16> @splice_nxv1i16_offset_min(<vscale x 1 x i16> %a, <vscale x 1 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv1i16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vsetivli zero, 2, e16, mf4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e16, mf4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 2
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i16> @llvm.vector.splice.nxv1i16(<vscale x 1 x i16> %a, <vscale x 1 x i16> %b, i32 -2)
  ret <vscale x 1 x i16> %res
}

define <vscale x 1 x i16> @splice_nxv1i16_offset_max(<vscale x 1 x i16> %a, <vscale x 1 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv1i16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli zero, a0, e16, mf4, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 1
; CHECK-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i16> @llvm.vector.splice.nxv1i16(<vscale x 1 x i16> %a, <vscale x 1 x i16> %b, i32 1)
  ret <vscale x 1 x i16> %res
}

declare <vscale x 2 x i16> @llvm.vector.splice.nxv2i16(<vscale x 2 x i16>, <vscale x 2 x i16>, i32)

define <vscale x 2 x i16> @splice_nxv2i16_offset_zero(<vscale x 2 x i16> %a, <vscale x 2 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv2i16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i16> @llvm.vector.splice.nxv2i16(<vscale x 2 x i16> %a, <vscale x 2 x i16> %b, i32 0)
  ret <vscale x 2 x i16> %res
}

define <vscale x 2 x i16> @splice_nxv2i16_offset_negone(<vscale x 2 x i16> %a, <vscale x 2 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv2i16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i16> @llvm.vector.splice.nxv2i16(<vscale x 2 x i16> %a, <vscale x 2 x i16> %b, i32 -1)
  ret <vscale x 2 x i16> %res
}

define <vscale x 2 x i16> @splice_nxv2i16_offset_min(<vscale x 2 x i16> %a, <vscale x 2 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv2i16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -4
; CHECK-NEXT:    vsetivli zero, 4, e16, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e16, mf2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 4
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i16> @llvm.vector.splice.nxv2i16(<vscale x 2 x i16> %a, <vscale x 2 x i16> %b, i32 -4)
  ret <vscale x 2 x i16> %res
}

define <vscale x 2 x i16> @splice_nxv2i16_offset_max(<vscale x 2 x i16> %a, <vscale x 2 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv2i16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -3
; CHECK-NEXT:    vsetvli zero, a0, e16, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 3
; CHECK-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i16> @llvm.vector.splice.nxv2i16(<vscale x 2 x i16> %a, <vscale x 2 x i16> %b, i32 3)
  ret <vscale x 2 x i16> %res
}

declare <vscale x 4 x i16> @llvm.vector.splice.nxv4i16(<vscale x 4 x i16>, <vscale x 4 x i16>, i32)

define <vscale x 4 x i16> @splice_nxv4i16_offset_zero(<vscale x 4 x i16> %a, <vscale x 4 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv4i16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i16> @llvm.vector.splice.nxv4i16(<vscale x 4 x i16> %a, <vscale x 4 x i16> %b, i32 0)
  ret <vscale x 4 x i16> %res
}

define <vscale x 4 x i16> @splice_nxv4i16_offset_negone(<vscale x 4 x i16> %a, <vscale x 4 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv4i16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e16, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i16> @llvm.vector.splice.nxv4i16(<vscale x 4 x i16> %a, <vscale x 4 x i16> %b, i32 -1)
  ret <vscale x 4 x i16> %res
}

define <vscale x 4 x i16> @splice_nxv4i16_offset_min(<vscale x 4 x i16> %a, <vscale x 4 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv4i16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -8
; CHECK-NEXT:    vsetivli zero, 8, e16, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e16, m1, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 8
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i16> @llvm.vector.splice.nxv4i16(<vscale x 4 x i16> %a, <vscale x 4 x i16> %b, i32 -8)
  ret <vscale x 4 x i16> %res
}

define <vscale x 4 x i16> @splice_nxv4i16_offset_max(<vscale x 4 x i16> %a, <vscale x 4 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv4i16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -7
; CHECK-NEXT:    vsetvli zero, a0, e16, m1, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 7
; CHECK-NEXT:    vsetvli a1, zero, e16, m1, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i16> @llvm.vector.splice.nxv4i16(<vscale x 4 x i16> %a, <vscale x 4 x i16> %b, i32 7)
  ret <vscale x 4 x i16> %res
}

declare <vscale x 8 x i16> @llvm.vector.splice.nxv8i16(<vscale x 8 x i16>, <vscale x 8 x i16>, i32)

define <vscale x 8 x i16> @splice_nxv8i16_offset_zero(<vscale x 8 x i16> %a, <vscale x 8 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv8i16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i16> @llvm.vector.splice.nxv8i16(<vscale x 8 x i16> %a, <vscale x 8 x i16> %b, i32 0)
  ret <vscale x 8 x i16> %res
}

define <vscale x 8 x i16> @splice_nxv8i16_offset_negone(<vscale x 8 x i16> %a, <vscale x 8 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv8i16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e16, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e16, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i16> @llvm.vector.splice.nxv8i16(<vscale x 8 x i16> %a, <vscale x 8 x i16> %b, i32 -1)
  ret <vscale x 8 x i16> %res
}

define <vscale x 8 x i16> @splice_nxv8i16_offset_min(<vscale x 8 x i16> %a, <vscale x 8 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv8i16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -16
; CHECK-NEXT:    vsetivli zero, 16, e16, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e16, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i16> @llvm.vector.splice.nxv8i16(<vscale x 8 x i16> %a, <vscale x 8 x i16> %b, i32 -16)
  ret <vscale x 8 x i16> %res
}

define <vscale x 8 x i16> @splice_nxv8i16_offset_max(<vscale x 8 x i16> %a, <vscale x 8 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv8i16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -15
; CHECK-NEXT:    vsetvli zero, a0, e16, m2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 15
; CHECK-NEXT:    vsetvli a1, zero, e16, m2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v10, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i16> @llvm.vector.splice.nxv8i16(<vscale x 8 x i16> %a, <vscale x 8 x i16> %b, i32 15)
  ret <vscale x 8 x i16> %res
}

declare <vscale x 16 x i16> @llvm.vector.splice.nxv16i16(<vscale x 16 x i16>, <vscale x 16 x i16>, i32)

define <vscale x 16 x i16> @splice_nxv16i16_offset_zero(<vscale x 16 x i16> %a, <vscale x 16 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv16i16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i16> @llvm.vector.splice.nxv16i16(<vscale x 16 x i16> %a, <vscale x 16 x i16> %b, i32 0)
  ret <vscale x 16 x i16> %res
}

define <vscale x 16 x i16> @splice_nxv16i16_offset_negone(<vscale x 16 x i16> %a, <vscale x 16 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv16i16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e16, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e16, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i16> @llvm.vector.splice.nxv16i16(<vscale x 16 x i16> %a, <vscale x 16 x i16> %b, i32 -1)
  ret <vscale x 16 x i16> %res
}

define <vscale x 16 x i16> @splice_nxv16i16_offset_min(<vscale x 16 x i16> %a, <vscale x 16 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv16i16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -32
; CHECK-NEXT:    li a1, 32
; CHECK-NEXT:    vsetvli zero, a1, e16, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e16, m4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v12, a1
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i16> @llvm.vector.splice.nxv16i16(<vscale x 16 x i16> %a, <vscale x 16 x i16> %b, i32 -32)
  ret <vscale x 16 x i16> %res
}

define <vscale x 16 x i16> @splice_nxv16i16_offset_max(<vscale x 16 x i16> %a, <vscale x 16 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv16i16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -31
; CHECK-NEXT:    vsetvli zero, a0, e16, m4, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 31
; CHECK-NEXT:    vsetvli a1, zero, e16, m4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v12, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i16> @llvm.vector.splice.nxv16i16(<vscale x 16 x i16> %a, <vscale x 16 x i16> %b, i32 31)
  ret <vscale x 16 x i16> %res
}

declare <vscale x 32 x i16> @llvm.vector.splice.nxv32i16(<vscale x 32 x i16>, <vscale x 32 x i16>, i32)

define <vscale x 32 x i16> @splice_nxv32i16_offset_zero(<vscale x 32 x i16> %a, <vscale x 32 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv32i16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i16> @llvm.vector.splice.nxv32i16(<vscale x 32 x i16> %a, <vscale x 32 x i16> %b, i32 0)
  ret <vscale x 32 x i16> %res
}

define <vscale x 32 x i16> @splice_nxv32i16_offset_negone(<vscale x 32 x i16> %a, <vscale x 32 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv32i16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e16, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e16, m8, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v16, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i16> @llvm.vector.splice.nxv32i16(<vscale x 32 x i16> %a, <vscale x 32 x i16> %b, i32 -1)
  ret <vscale x 32 x i16> %res
}

define <vscale x 32 x i16> @splice_nxv32i16_offset_min(<vscale x 32 x i16> %a, <vscale x 32 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv32i16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -64
; CHECK-NEXT:    li a1, 64
; CHECK-NEXT:    vsetvli zero, a1, e16, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e16, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a1
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i16> @llvm.vector.splice.nxv32i16(<vscale x 32 x i16> %a, <vscale x 32 x i16> %b, i32 -64)
  ret <vscale x 32 x i16> %res
}

define <vscale x 32 x i16> @splice_nxv32i16_offset_max(<vscale x 32 x i16> %a, <vscale x 32 x i16> %b) #0 {
; CHECK-LABEL: splice_nxv32i16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -63
; CHECK-NEXT:    li a1, 63
; CHECK-NEXT:    vsetvli zero, a0, e16, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a1
; CHECK-NEXT:    vsetvli a1, zero, e16, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x i16> @llvm.vector.splice.nxv32i16(<vscale x 32 x i16> %a, <vscale x 32 x i16> %b, i32 63)
  ret <vscale x 32 x i16> %res
}

declare <vscale x 1 x i32> @llvm.vector.splice.nxv1i32(<vscale x 1 x i32>, <vscale x 1 x i32>, i32)

define <vscale x 1 x i32> @splice_nxv1i32_offset_zero(<vscale x 1 x i32> %a, <vscale x 1 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv1i32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i32> @llvm.vector.splice.nxv1i32(<vscale x 1 x i32> %a, <vscale x 1 x i32> %b, i32 0)
  ret <vscale x 1 x i32> %res
}

define <vscale x 1 x i32> @splice_nxv1i32_offset_negone(<vscale x 1 x i32> %a, <vscale x 1 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv1i32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e32, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i32> @llvm.vector.splice.nxv1i32(<vscale x 1 x i32> %a, <vscale x 1 x i32> %b, i32 -1)
  ret <vscale x 1 x i32> %res
}

define <vscale x 1 x i32> @splice_nxv1i32_offset_min(<vscale x 1 x i32> %a, <vscale x 1 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv1i32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vsetivli zero, 2, e32, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, mf2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 2
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i32> @llvm.vector.splice.nxv1i32(<vscale x 1 x i32> %a, <vscale x 1 x i32> %b, i32 -2)
  ret <vscale x 1 x i32> %res
}

define <vscale x 1 x i32> @splice_nxv1i32_offset_max(<vscale x 1 x i32> %a, <vscale x 1 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv1i32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli zero, a0, e32, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 1
; CHECK-NEXT:    vsetvli a1, zero, e32, mf2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i32> @llvm.vector.splice.nxv1i32(<vscale x 1 x i32> %a, <vscale x 1 x i32> %b, i32 1)
  ret <vscale x 1 x i32> %res
}

declare <vscale x 2 x i32> @llvm.vector.splice.nxv2i32(<vscale x 2 x i32>, <vscale x 2 x i32>, i32)

define <vscale x 2 x i32> @splice_nxv2i32_offset_zero(<vscale x 2 x i32> %a, <vscale x 2 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv2i32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i32> @llvm.vector.splice.nxv2i32(<vscale x 2 x i32> %a, <vscale x 2 x i32> %b, i32 0)
  ret <vscale x 2 x i32> %res
}

define <vscale x 2 x i32> @splice_nxv2i32_offset_negone(<vscale x 2 x i32> %a, <vscale x 2 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv2i32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e32, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i32> @llvm.vector.splice.nxv2i32(<vscale x 2 x i32> %a, <vscale x 2 x i32> %b, i32 -1)
  ret <vscale x 2 x i32> %res
}

define <vscale x 2 x i32> @splice_nxv2i32_offset_min(<vscale x 2 x i32> %a, <vscale x 2 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv2i32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -4
; CHECK-NEXT:    vsetivli zero, 4, e32, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m1, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 4
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i32> @llvm.vector.splice.nxv2i32(<vscale x 2 x i32> %a, <vscale x 2 x i32> %b, i32 -4)
  ret <vscale x 2 x i32> %res
}

define <vscale x 2 x i32> @splice_nxv2i32_offset_max(<vscale x 2 x i32> %a, <vscale x 2 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv2i32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -3
; CHECK-NEXT:    vsetvli zero, a0, e32, m1, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 3
; CHECK-NEXT:    vsetvli a1, zero, e32, m1, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i32> @llvm.vector.splice.nxv2i32(<vscale x 2 x i32> %a, <vscale x 2 x i32> %b, i32 3)
  ret <vscale x 2 x i32> %res
}

declare <vscale x 4 x i32> @llvm.vector.splice.nxv4i32(<vscale x 4 x i32>, <vscale x 4 x i32>, i32)

define <vscale x 4 x i32> @splice_nxv4i32_offset_zero(<vscale x 4 x i32> %a, <vscale x 4 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv4i32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i32> @llvm.vector.splice.nxv4i32(<vscale x 4 x i32> %a, <vscale x 4 x i32> %b, i32 0)
  ret <vscale x 4 x i32> %res
}

define <vscale x 4 x i32> @splice_nxv4i32_offset_negone(<vscale x 4 x i32> %a, <vscale x 4 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv4i32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e32, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i32> @llvm.vector.splice.nxv4i32(<vscale x 4 x i32> %a, <vscale x 4 x i32> %b, i32 -1)
  ret <vscale x 4 x i32> %res
}

define <vscale x 4 x i32> @splice_nxv4i32_offset_min(<vscale x 4 x i32> %a, <vscale x 4 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv4i32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -8
; CHECK-NEXT:    vsetivli zero, 8, e32, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 8
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i32> @llvm.vector.splice.nxv4i32(<vscale x 4 x i32> %a, <vscale x 4 x i32> %b, i32 -8)
  ret <vscale x 4 x i32> %res
}

define <vscale x 4 x i32> @splice_nxv4i32_offset_max(<vscale x 4 x i32> %a, <vscale x 4 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv4i32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -7
; CHECK-NEXT:    vsetvli zero, a0, e32, m2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 7
; CHECK-NEXT:    vsetvli a1, zero, e32, m2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v10, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i32> @llvm.vector.splice.nxv4i32(<vscale x 4 x i32> %a, <vscale x 4 x i32> %b, i32 7)
  ret <vscale x 4 x i32> %res
}

declare <vscale x 8 x i32> @llvm.vector.splice.nxv8i32(<vscale x 8 x i32>, <vscale x 8 x i32>, i32)

define <vscale x 8 x i32> @splice_nxv8i32_offset_zero(<vscale x 8 x i32> %a, <vscale x 8 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv8i32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i32> @llvm.vector.splice.nxv8i32(<vscale x 8 x i32> %a, <vscale x 8 x i32> %b, i32 0)
  ret <vscale x 8 x i32> %res
}

define <vscale x 8 x i32> @splice_nxv8i32_offset_negone(<vscale x 8 x i32> %a, <vscale x 8 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv8i32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e32, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i32> @llvm.vector.splice.nxv8i32(<vscale x 8 x i32> %a, <vscale x 8 x i32> %b, i32 -1)
  ret <vscale x 8 x i32> %res
}

define <vscale x 8 x i32> @splice_nxv8i32_offset_min(<vscale x 8 x i32> %a, <vscale x 8 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv8i32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -16
; CHECK-NEXT:    vsetivli zero, 16, e32, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i32> @llvm.vector.splice.nxv8i32(<vscale x 8 x i32> %a, <vscale x 8 x i32> %b, i32 -16)
  ret <vscale x 8 x i32> %res
}

define <vscale x 8 x i32> @splice_nxv8i32_offset_max(<vscale x 8 x i32> %a, <vscale x 8 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv8i32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -15
; CHECK-NEXT:    vsetvli zero, a0, e32, m4, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 15
; CHECK-NEXT:    vsetvli a1, zero, e32, m4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v12, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i32> @llvm.vector.splice.nxv8i32(<vscale x 8 x i32> %a, <vscale x 8 x i32> %b, i32 15)
  ret <vscale x 8 x i32> %res
}

declare <vscale x 16 x i32> @llvm.vector.splice.nxv16i32(<vscale x 16 x i32>, <vscale x 16 x i32>, i32)

define <vscale x 16 x i32> @splice_nxv16i32_offset_zero(<vscale x 16 x i32> %a, <vscale x 16 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv16i32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i32> @llvm.vector.splice.nxv16i32(<vscale x 16 x i32> %a, <vscale x 16 x i32> %b, i32 0)
  ret <vscale x 16 x i32> %res
}

define <vscale x 16 x i32> @splice_nxv16i32_offset_negone(<vscale x 16 x i32> %a, <vscale x 16 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv16i32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e32, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m8, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v16, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i32> @llvm.vector.splice.nxv16i32(<vscale x 16 x i32> %a, <vscale x 16 x i32> %b, i32 -1)
  ret <vscale x 16 x i32> %res
}

define <vscale x 16 x i32> @splice_nxv16i32_offset_min(<vscale x 16 x i32> %a, <vscale x 16 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv16i32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -32
; CHECK-NEXT:    li a1, 32
; CHECK-NEXT:    vsetvli zero, a1, e32, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a1
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i32> @llvm.vector.splice.nxv16i32(<vscale x 16 x i32> %a, <vscale x 16 x i32> %b, i32 -32)
  ret <vscale x 16 x i32> %res
}

define <vscale x 16 x i32> @splice_nxv16i32_offset_max(<vscale x 16 x i32> %a, <vscale x 16 x i32> %b) #0 {
; CHECK-LABEL: splice_nxv16i32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -31
; CHECK-NEXT:    vsetvli zero, a0, e32, m8, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 31
; CHECK-NEXT:    vsetvli a1, zero, e32, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x i32> @llvm.vector.splice.nxv16i32(<vscale x 16 x i32> %a, <vscale x 16 x i32> %b, i32 31)
  ret <vscale x 16 x i32> %res
}

declare <vscale x 1 x i64> @llvm.vector.splice.nxv1i64(<vscale x 1 x i64>, <vscale x 1 x i64>, i32)

define <vscale x 1 x i64> @splice_nxv1i64_offset_zero(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv1i64_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i64> @llvm.vector.splice.nxv1i64(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b, i32 0)
  ret <vscale x 1 x i64> %res
}

define <vscale x 1 x i64> @splice_nxv1i64_offset_negone(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv1i64_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e64, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i64> @llvm.vector.splice.nxv1i64(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b, i32 -1)
  ret <vscale x 1 x i64> %res
}

define <vscale x 1 x i64> @splice_nxv1i64_offset_min(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv1i64_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vsetivli zero, 2, e64, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m1, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 2
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i64> @llvm.vector.splice.nxv1i64(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b, i32 -2)
  ret <vscale x 1 x i64> %res
}

define <vscale x 1 x i64> @splice_nxv1i64_offset_max(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv1i64_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli zero, a0, e64, m1, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 1
; CHECK-NEXT:    vsetvli a1, zero, e64, m1, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x i64> @llvm.vector.splice.nxv1i64(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b, i32 1)
  ret <vscale x 1 x i64> %res
}

declare <vscale x 2 x i64> @llvm.vector.splice.nxv2i64(<vscale x 2 x i64>, <vscale x 2 x i64>, i32)

define <vscale x 2 x i64> @splice_nxv2i64_offset_zero(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv2i64_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i64> @llvm.vector.splice.nxv2i64(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b, i32 0)
  ret <vscale x 2 x i64> %res
}

define <vscale x 2 x i64> @splice_nxv2i64_offset_negone(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv2i64_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e64, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i64> @llvm.vector.splice.nxv2i64(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b, i32 -1)
  ret <vscale x 2 x i64> %res
}

define <vscale x 2 x i64> @splice_nxv2i64_offset_min(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv2i64_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -4
; CHECK-NEXT:    vsetivli zero, 4, e64, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 4
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i64> @llvm.vector.splice.nxv2i64(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b, i32 -4)
  ret <vscale x 2 x i64> %res
}

define <vscale x 2 x i64> @splice_nxv2i64_offset_max(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv2i64_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -3
; CHECK-NEXT:    vsetvli zero, a0, e64, m2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 3
; CHECK-NEXT:    vsetvli a1, zero, e64, m2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v10, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x i64> @llvm.vector.splice.nxv2i64(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b, i32 3)
  ret <vscale x 2 x i64> %res
}

declare <vscale x 4 x i64> @llvm.vector.splice.nxv4i64(<vscale x 4 x i64>, <vscale x 4 x i64>, i32)

define <vscale x 4 x i64> @splice_nxv4i64_offset_zero(<vscale x 4 x i64> %a, <vscale x 4 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv4i64_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i64> @llvm.vector.splice.nxv4i64(<vscale x 4 x i64> %a, <vscale x 4 x i64> %b, i32 0)
  ret <vscale x 4 x i64> %res
}

define <vscale x 4 x i64> @splice_nxv4i64_offset_negone(<vscale x 4 x i64> %a, <vscale x 4 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv4i64_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e64, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i64> @llvm.vector.splice.nxv4i64(<vscale x 4 x i64> %a, <vscale x 4 x i64> %b, i32 -1)
  ret <vscale x 4 x i64> %res
}

define <vscale x 4 x i64> @splice_nxv4i64_offset_min(<vscale x 4 x i64> %a, <vscale x 4 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv4i64_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -8
; CHECK-NEXT:    vsetivli zero, 8, e64, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 8
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i64> @llvm.vector.splice.nxv4i64(<vscale x 4 x i64> %a, <vscale x 4 x i64> %b, i32 -8)
  ret <vscale x 4 x i64> %res
}

define <vscale x 4 x i64> @splice_nxv4i64_offset_max(<vscale x 4 x i64> %a, <vscale x 4 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv4i64_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -7
; CHECK-NEXT:    vsetvli zero, a0, e64, m4, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 7
; CHECK-NEXT:    vsetvli a1, zero, e64, m4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v12, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x i64> @llvm.vector.splice.nxv4i64(<vscale x 4 x i64> %a, <vscale x 4 x i64> %b, i32 7)
  ret <vscale x 4 x i64> %res
}

declare <vscale x 8 x i64> @llvm.vector.splice.nxv8i64(<vscale x 8 x i64>, <vscale x 8 x i64>, i32)

define <vscale x 8 x i64> @splice_nxv8i64_offset_zero(<vscale x 8 x i64> %a, <vscale x 8 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv8i64_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i64> @llvm.vector.splice.nxv8i64(<vscale x 8 x i64> %a, <vscale x 8 x i64> %b, i32 0)
  ret <vscale x 8 x i64> %res
}

define <vscale x 8 x i64> @splice_nxv8i64_offset_negone(<vscale x 8 x i64> %a, <vscale x 8 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv8i64_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e64, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m8, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v16, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i64> @llvm.vector.splice.nxv8i64(<vscale x 8 x i64> %a, <vscale x 8 x i64> %b, i32 -1)
  ret <vscale x 8 x i64> %res
}

define <vscale x 8 x i64> @splice_nxv8i64_offset_min(<vscale x 8 x i64> %a, <vscale x 8 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv8i64_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -16
; CHECK-NEXT:    vsetivli zero, 16, e64, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m8, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v16, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i64> @llvm.vector.splice.nxv8i64(<vscale x 8 x i64> %a, <vscale x 8 x i64> %b, i32 -16)
  ret <vscale x 8 x i64> %res
}

define <vscale x 8 x i64> @splice_nxv8i64_offset_max(<vscale x 8 x i64> %a, <vscale x 8 x i64> %b) #0 {
; CHECK-LABEL: splice_nxv8i64_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -15
; CHECK-NEXT:    vsetvli zero, a0, e64, m8, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 15
; CHECK-NEXT:    vsetvli a1, zero, e64, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x i64> @llvm.vector.splice.nxv8i64(<vscale x 8 x i64> %a, <vscale x 8 x i64> %b, i32 15)
  ret <vscale x 8 x i64> %res
}

declare <vscale x 1 x bfloat> @llvm.vector.splice.nxv1bf16(<vscale x 1 x bfloat>, <vscale x 1 x bfloat>, i32)

define <vscale x 1 x bfloat> @splice_nxv1bf16_offset_zero(<vscale x 1 x bfloat> %a, <vscale x 1 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv1bf16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x bfloat> @llvm.vector.splice.nxv1bf16(<vscale x 1 x bfloat> %a, <vscale x 1 x bfloat> %b, i32 0)
  ret <vscale x 1 x bfloat> %res
}

define <vscale x 1 x bfloat> @splice_nxv1bf16_offset_negone(<vscale x 1 x bfloat> %a, <vscale x 1 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv1bf16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; CHECK-NEXT:    vse16.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    srli a1, a1, 2
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    vse16.v v9, (a0)
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vle16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x bfloat> @llvm.vector.splice.nxv1bf16(<vscale x 1 x bfloat> %a, <vscale x 1 x bfloat> %b, i32 -1)
  ret <vscale x 1 x bfloat> %res
}

define <vscale x 1 x bfloat> @splice_nxv1bf16_offset_min(<vscale x 1 x bfloat> %a, <vscale x 1 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv1bf16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; CHECK-NEXT:    vse16.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    srli a1, a1, 2
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    li a2, 4
; CHECK-NEXT:    vse16.v v9, (a0)
; CHECK-NEXT:    bltu a1, a2, .LBB104_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    li a1, 4
; CHECK-NEXT:  .LBB104_2:
; CHECK-NEXT:    sub a0, a0, a1
; CHECK-NEXT:    vle16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x bfloat> @llvm.vector.splice.nxv1bf16(<vscale x 1 x bfloat> %a, <vscale x 1 x bfloat> %b, i32 -2)
  ret <vscale x 1 x bfloat> %res
}

define <vscale x 1 x bfloat> @splice_nxv1bf16_offset_max(<vscale x 1 x bfloat> %a, <vscale x 1 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv1bf16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; CHECK-NEXT:    vse16.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    srli a2, a1, 2
; CHECK-NEXT:    add a2, a0, a2
; CHECK-NEXT:    srli a1, a1, 3
; CHECK-NEXT:    addi a1, a1, -1
; CHECK-NEXT:    li a3, 1
; CHECK-NEXT:    vse16.v v9, (a2)
; CHECK-NEXT:    bltu a1, a3, .LBB105_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    li a1, 1
; CHECK-NEXT:  .LBB105_2:
; CHECK-NEXT:    slli a1, a1, 1
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    vle16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x bfloat> @llvm.vector.splice.nxv1bf16(<vscale x 1 x bfloat> %a, <vscale x 1 x bfloat> %b, i32 1)
  ret <vscale x 1 x bfloat> %res
}

declare <vscale x 2 x bfloat> @llvm.vector.splice.nxv2bf16(<vscale x 2 x bfloat>, <vscale x 2 x bfloat>, i32)

define <vscale x 2 x bfloat> @splice_nxv2bf16_offset_zero(<vscale x 2 x bfloat> %a, <vscale x 2 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv2bf16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x bfloat> @llvm.vector.splice.nxv2bf16(<vscale x 2 x bfloat> %a, <vscale x 2 x bfloat> %b, i32 0)
  ret <vscale x 2 x bfloat> %res
}

define <vscale x 2 x bfloat> @splice_nxv2bf16_offset_negone(<vscale x 2 x bfloat> %a, <vscale x 2 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv2bf16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; CHECK-NEXT:    vse16.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    srli a1, a1, 1
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    vse16.v v9, (a0)
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vle16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x bfloat> @llvm.vector.splice.nxv2bf16(<vscale x 2 x bfloat> %a, <vscale x 2 x bfloat> %b, i32 -1)
  ret <vscale x 2 x bfloat> %res
}

define <vscale x 2 x bfloat> @splice_nxv2bf16_offset_min(<vscale x 2 x bfloat> %a, <vscale x 2 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv2bf16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; CHECK-NEXT:    vse16.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    srli a1, a1, 1
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    li a2, 8
; CHECK-NEXT:    vse16.v v9, (a0)
; CHECK-NEXT:    bltu a1, a2, .LBB108_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    li a1, 8
; CHECK-NEXT:  .LBB108_2:
; CHECK-NEXT:    sub a0, a0, a1
; CHECK-NEXT:    vle16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x bfloat> @llvm.vector.splice.nxv2bf16(<vscale x 2 x bfloat> %a, <vscale x 2 x bfloat> %b, i32 -4)
  ret <vscale x 2 x bfloat> %res
}

define <vscale x 2 x bfloat> @splice_nxv2bf16_offset_max(<vscale x 2 x bfloat> %a, <vscale x 2 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv2bf16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; CHECK-NEXT:    vse16.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    srli a2, a1, 1
; CHECK-NEXT:    add a2, a0, a2
; CHECK-NEXT:    srli a1, a1, 2
; CHECK-NEXT:    addi a1, a1, -1
; CHECK-NEXT:    li a3, 3
; CHECK-NEXT:    vse16.v v9, (a2)
; CHECK-NEXT:    bltu a1, a3, .LBB109_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    li a1, 3
; CHECK-NEXT:  .LBB109_2:
; CHECK-NEXT:    slli a1, a1, 1
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    vle16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x bfloat> @llvm.vector.splice.nxv2bf16(<vscale x 2 x bfloat> %a, <vscale x 2 x bfloat> %b, i32 3)
  ret <vscale x 2 x bfloat> %res
}

declare <vscale x 4 x bfloat> @llvm.vector.splice.nxv4bf16(<vscale x 4 x bfloat>, <vscale x 4 x bfloat>, i32)

define <vscale x 4 x bfloat> @splice_nxv4bf16_offset_zero(<vscale x 4 x bfloat> %a, <vscale x 4 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv4bf16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x bfloat> @llvm.vector.splice.nxv4bf16(<vscale x 4 x bfloat> %a, <vscale x 4 x bfloat> %b, i32 0)
  ret <vscale x 4 x bfloat> %res
}

define <vscale x 4 x bfloat> @splice_nxv4bf16_offset_negone(<vscale x 4 x bfloat> %a, <vscale x 4 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv4bf16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x02, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 2 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vs1r.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    vs1r.v v9, (a0)
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vl1re16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x bfloat> @llvm.vector.splice.nxv4bf16(<vscale x 4 x bfloat> %a, <vscale x 4 x bfloat> %b, i32 -1)
  ret <vscale x 4 x bfloat> %res
}

define <vscale x 4 x bfloat> @splice_nxv4bf16_offset_min(<vscale x 4 x bfloat> %a, <vscale x 4 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv4bf16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x02, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 2 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vs1r.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    li a2, 16
; CHECK-NEXT:    vs1r.v v9, (a0)
; CHECK-NEXT:    bltu a1, a2, .LBB112_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    li a1, 16
; CHECK-NEXT:  .LBB112_2:
; CHECK-NEXT:    sub a0, a0, a1
; CHECK-NEXT:    vl1re16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x bfloat> @llvm.vector.splice.nxv4bf16(<vscale x 4 x bfloat> %a, <vscale x 4 x bfloat> %b, i32 -8)
  ret <vscale x 4 x bfloat> %res
}

define <vscale x 4 x bfloat> @splice_nxv4bf16_offset_max(<vscale x 4 x bfloat> %a, <vscale x 4 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv4bf16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x02, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 2 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vs1r.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    add a2, a0, a1
; CHECK-NEXT:    srli a1, a1, 1
; CHECK-NEXT:    addi a1, a1, -1
; CHECK-NEXT:    li a3, 7
; CHECK-NEXT:    vs1r.v v9, (a2)
; CHECK-NEXT:    bltu a1, a3, .LBB113_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    li a1, 7
; CHECK-NEXT:  .LBB113_2:
; CHECK-NEXT:    slli a1, a1, 1
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    vl1re16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x bfloat> @llvm.vector.splice.nxv4bf16(<vscale x 4 x bfloat> %a, <vscale x 4 x bfloat> %b, i32 7)
  ret <vscale x 4 x bfloat> %res
}

declare <vscale x 8 x bfloat> @llvm.vector.splice.nxv8bf16(<vscale x 8 x bfloat>, <vscale x 8 x bfloat>, i32)

define <vscale x 8 x bfloat> @splice_nxv8bf16_offset_zero(<vscale x 8 x bfloat> %a, <vscale x 8 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv8bf16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x bfloat> @llvm.vector.splice.nxv8bf16(<vscale x 8 x bfloat> %a, <vscale x 8 x bfloat> %b, i32 0)
  ret <vscale x 8 x bfloat> %res
}

define <vscale x 8 x bfloat> @splice_nxv8bf16_offset_negone(<vscale x 8 x bfloat> %a, <vscale x 8 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv8bf16_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x04, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 4 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vs2r.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    slli a1, a1, 1
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    vs2r.v v10, (a0)
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vl2re16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x bfloat> @llvm.vector.splice.nxv8bf16(<vscale x 8 x bfloat> %a, <vscale x 8 x bfloat> %b, i32 -1)
  ret <vscale x 8 x bfloat> %res
}

define <vscale x 8 x bfloat> @splice_nxv8bf16_offset_min(<vscale x 8 x bfloat> %a, <vscale x 8 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv8bf16_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x04, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 4 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vs2r.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    slli a1, a1, 1
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    li a2, 32
; CHECK-NEXT:    vs2r.v v10, (a0)
; CHECK-NEXT:    bltu a1, a2, .LBB116_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    li a1, 32
; CHECK-NEXT:  .LBB116_2:
; CHECK-NEXT:    sub a0, a0, a1
; CHECK-NEXT:    vl2re16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x bfloat> @llvm.vector.splice.nxv8bf16(<vscale x 8 x bfloat> %a, <vscale x 8 x bfloat> %b, i32 -16)
  ret <vscale x 8 x bfloat> %res
}

define <vscale x 8 x bfloat> @splice_nxv8bf16_offset_max(<vscale x 8 x bfloat> %a, <vscale x 8 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv8bf16_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x04, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 4 * vlenb
; CHECK-NEXT:    addi a0, sp, 16
; CHECK-NEXT:    vs2r.v v8, (a0)
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    slli a2, a1, 1
; CHECK-NEXT:    add a2, a0, a2
; CHECK-NEXT:    addi a1, a1, -1
; CHECK-NEXT:    li a3, 15
; CHECK-NEXT:    vs2r.v v10, (a2)
; CHECK-NEXT:    bltu a1, a3, .LBB117_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    li a1, 15
; CHECK-NEXT:  .LBB117_2:
; CHECK-NEXT:    slli a1, a1, 1
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    vl2re16.v v8, (a0)
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 2
; CHECK-NEXT:    add sp, sp, a0
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x bfloat> @llvm.vector.splice.nxv8bf16(<vscale x 8 x bfloat> %a, <vscale x 8 x bfloat> %b, i32 15)
  ret <vscale x 8 x bfloat> %res
}

declare <vscale x 16 x bfloat> @llvm.vector.splice.nxv16bf16(<vscale x 16 x bfloat>, <vscale x 16 x bfloat>, i32)

define <vscale x 16 x bfloat> @splice_nxv16bf16_offset_zero(<vscale x 16 x bfloat> %a, <vscale x 16 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv16bf16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x bfloat> @llvm.vector.splice.nxv16bf16(<vscale x 16 x bfloat> %a, <vscale x 16 x bfloat> %b, i32 0)
  ret <vscale x 16 x bfloat> %res
}

define <vscale x 16 x bfloat> @splice_nxv16bf16_offset_negone(<vscale x 16 x bfloat> %a, <vscale x 16 x bfloat> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv16bf16_offset_negone:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -48
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN64-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 48
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 3
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -32
; ZVFHMIN64-NEXT:    addi a0, sp, 32
; ZVFHMIN64-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 2
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vs4r.v v12, (a0)
; ZVFHMIN64-NEXT:    addi a0, a0, -2
; ZVFHMIN64-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -48
; ZVFHMIN64-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 48
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv16bf16_offset_negone:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -48
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN32-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 48
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 3
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -32
; ZVFHMIN32-NEXT:    addi a0, sp, 32
; ZVFHMIN32-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 2
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vs4r.v v12, (a0)
; ZVFHMIN32-NEXT:    addi a0, a0, -2
; ZVFHMIN32-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -48
; ZVFHMIN32-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 48
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv16bf16_offset_negone:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    addi sp, sp, -48
; ZVFH32-NEXT:    .cfi_def_cfa_offset 48
; ZVFH32-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    .cfi_offset ra, -4
; ZVFH32-NEXT:    .cfi_offset s0, -8
; ZVFH32-NEXT:    addi s0, sp, 48
; ZVFH32-NEXT:    .cfi_def_cfa s0, 0
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 3
; ZVFH32-NEXT:    sub sp, sp, a0
; ZVFH32-NEXT:    andi sp, sp, -32
; ZVFH32-NEXT:    addi a0, sp, 32
; ZVFH32-NEXT:    vs4r.v v8, (a0)
; ZVFH32-NEXT:    csrr a1, vlenb
; ZVFH32-NEXT:    slli a1, a1, 2
; ZVFH32-NEXT:    add a0, a0, a1
; ZVFH32-NEXT:    vs4r.v v12, (a0)
; ZVFH32-NEXT:    addi a0, a0, -2
; ZVFH32-NEXT:    vl4re16.v v8, (a0)
; ZVFH32-NEXT:    addi sp, s0, -48
; ZVFH32-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    addi sp, sp, 48
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv16bf16_offset_negone:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    addi sp, sp, -48
; ZVFH64-NEXT:    .cfi_def_cfa_offset 48
; ZVFH64-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    .cfi_offset ra, -8
; ZVFH64-NEXT:    .cfi_offset s0, -16
; ZVFH64-NEXT:    addi s0, sp, 48
; ZVFH64-NEXT:    .cfi_def_cfa s0, 0
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 3
; ZVFH64-NEXT:    sub sp, sp, a0
; ZVFH64-NEXT:    andi sp, sp, -32
; ZVFH64-NEXT:    addi a0, sp, 32
; ZVFH64-NEXT:    vs4r.v v8, (a0)
; ZVFH64-NEXT:    csrr a1, vlenb
; ZVFH64-NEXT:    slli a1, a1, 2
; ZVFH64-NEXT:    add a0, a0, a1
; ZVFH64-NEXT:    vs4r.v v12, (a0)
; ZVFH64-NEXT:    addi a0, a0, -2
; ZVFH64-NEXT:    vl4re16.v v8, (a0)
; ZVFH64-NEXT:    addi sp, s0, -48
; ZVFH64-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    addi sp, sp, 48
; ZVFH64-NEXT:    ret
  %res = call <vscale x 16 x bfloat> @llvm.vector.splice.nxv16bf16(<vscale x 16 x bfloat> %a, <vscale x 16 x bfloat> %b, i32 -1)
  ret <vscale x 16 x bfloat> %res
}

define <vscale x 16 x bfloat> @splice_nxv16bf16_offset_min(<vscale x 16 x bfloat> %a, <vscale x 16 x bfloat> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv16bf16_offset_min:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -48
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN64-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 48
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 3
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -32
; ZVFHMIN64-NEXT:    addi a0, sp, 32
; ZVFHMIN64-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 2
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    li a2, 64
; ZVFHMIN64-NEXT:    vs4r.v v12, (a0)
; ZVFHMIN64-NEXT:    bltu a1, a2, .LBB120_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 64
; ZVFHMIN64-NEXT:  .LBB120_2:
; ZVFHMIN64-NEXT:    sub a0, a0, a1
; ZVFHMIN64-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -48
; ZVFHMIN64-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 48
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv16bf16_offset_min:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -48
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN32-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 48
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 3
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -32
; ZVFHMIN32-NEXT:    addi a0, sp, 32
; ZVFHMIN32-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 2
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    li a2, 64
; ZVFHMIN32-NEXT:    vs4r.v v12, (a0)
; ZVFHMIN32-NEXT:    bltu a1, a2, .LBB120_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 64
; ZVFHMIN32-NEXT:  .LBB120_2:
; ZVFHMIN32-NEXT:    sub a0, a0, a1
; ZVFHMIN32-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -48
; ZVFHMIN32-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 48
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv16bf16_offset_min:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    addi sp, sp, -48
; ZVFH32-NEXT:    .cfi_def_cfa_offset 48
; ZVFH32-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    .cfi_offset ra, -4
; ZVFH32-NEXT:    .cfi_offset s0, -8
; ZVFH32-NEXT:    addi s0, sp, 48
; ZVFH32-NEXT:    .cfi_def_cfa s0, 0
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 3
; ZVFH32-NEXT:    sub sp, sp, a0
; ZVFH32-NEXT:    andi sp, sp, -32
; ZVFH32-NEXT:    addi a0, sp, 32
; ZVFH32-NEXT:    vs4r.v v8, (a0)
; ZVFH32-NEXT:    csrr a1, vlenb
; ZVFH32-NEXT:    slli a1, a1, 2
; ZVFH32-NEXT:    add a0, a0, a1
; ZVFH32-NEXT:    li a2, 64
; ZVFH32-NEXT:    vs4r.v v12, (a0)
; ZVFH32-NEXT:    bltu a1, a2, .LBB120_2
; ZVFH32-NEXT:  # %bb.1:
; ZVFH32-NEXT:    li a1, 64
; ZVFH32-NEXT:  .LBB120_2:
; ZVFH32-NEXT:    sub a0, a0, a1
; ZVFH32-NEXT:    vl4re16.v v8, (a0)
; ZVFH32-NEXT:    addi sp, s0, -48
; ZVFH32-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    addi sp, sp, 48
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv16bf16_offset_min:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    addi sp, sp, -48
; ZVFH64-NEXT:    .cfi_def_cfa_offset 48
; ZVFH64-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    .cfi_offset ra, -8
; ZVFH64-NEXT:    .cfi_offset s0, -16
; ZVFH64-NEXT:    addi s0, sp, 48
; ZVFH64-NEXT:    .cfi_def_cfa s0, 0
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 3
; ZVFH64-NEXT:    sub sp, sp, a0
; ZVFH64-NEXT:    andi sp, sp, -32
; ZVFH64-NEXT:    addi a0, sp, 32
; ZVFH64-NEXT:    vs4r.v v8, (a0)
; ZVFH64-NEXT:    csrr a1, vlenb
; ZVFH64-NEXT:    slli a1, a1, 2
; ZVFH64-NEXT:    add a0, a0, a1
; ZVFH64-NEXT:    li a2, 64
; ZVFH64-NEXT:    vs4r.v v12, (a0)
; ZVFH64-NEXT:    bltu a1, a2, .LBB120_2
; ZVFH64-NEXT:  # %bb.1:
; ZVFH64-NEXT:    li a1, 64
; ZVFH64-NEXT:  .LBB120_2:
; ZVFH64-NEXT:    sub a0, a0, a1
; ZVFH64-NEXT:    vl4re16.v v8, (a0)
; ZVFH64-NEXT:    addi sp, s0, -48
; ZVFH64-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    addi sp, sp, 48
; ZVFH64-NEXT:    ret
  %res = call <vscale x 16 x bfloat> @llvm.vector.splice.nxv16bf16(<vscale x 16 x bfloat> %a, <vscale x 16 x bfloat> %b, i32 -32)
  ret <vscale x 16 x bfloat> %res
}

define <vscale x 16 x bfloat> @splice_nxv16bf16_offset_max(<vscale x 16 x bfloat> %a, <vscale x 16 x bfloat> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv16bf16_offset_max:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -48
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN64-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 48
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 3
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -32
; ZVFHMIN64-NEXT:    addi a0, sp, 32
; ZVFHMIN64-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a2, a1, 2
; ZVFHMIN64-NEXT:    add a2, a0, a2
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    addi a1, a1, -1
; ZVFHMIN64-NEXT:    li a3, 31
; ZVFHMIN64-NEXT:    vs4r.v v12, (a2)
; ZVFHMIN64-NEXT:    bltu a1, a3, .LBB121_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 31
; ZVFHMIN64-NEXT:  .LBB121_2:
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -48
; ZVFHMIN64-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 48
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv16bf16_offset_max:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -48
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN32-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 48
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 3
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -32
; ZVFHMIN32-NEXT:    addi a0, sp, 32
; ZVFHMIN32-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a2, a1, 2
; ZVFHMIN32-NEXT:    add a2, a0, a2
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    addi a1, a1, -1
; ZVFHMIN32-NEXT:    li a3, 31
; ZVFHMIN32-NEXT:    vs4r.v v12, (a2)
; ZVFHMIN32-NEXT:    bltu a1, a3, .LBB121_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 31
; ZVFHMIN32-NEXT:  .LBB121_2:
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -48
; ZVFHMIN32-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 48
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv16bf16_offset_max:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    addi sp, sp, -48
; ZVFH32-NEXT:    .cfi_def_cfa_offset 48
; ZVFH32-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    .cfi_offset ra, -4
; ZVFH32-NEXT:    .cfi_offset s0, -8
; ZVFH32-NEXT:    addi s0, sp, 48
; ZVFH32-NEXT:    .cfi_def_cfa s0, 0
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 3
; ZVFH32-NEXT:    sub sp, sp, a0
; ZVFH32-NEXT:    andi sp, sp, -32
; ZVFH32-NEXT:    addi a0, sp, 32
; ZVFH32-NEXT:    vs4r.v v8, (a0)
; ZVFH32-NEXT:    csrr a1, vlenb
; ZVFH32-NEXT:    slli a2, a1, 2
; ZVFH32-NEXT:    add a2, a0, a2
; ZVFH32-NEXT:    slli a1, a1, 1
; ZVFH32-NEXT:    addi a1, a1, -1
; ZVFH32-NEXT:    li a3, 31
; ZVFH32-NEXT:    vs4r.v v12, (a2)
; ZVFH32-NEXT:    bltu a1, a3, .LBB121_2
; ZVFH32-NEXT:  # %bb.1:
; ZVFH32-NEXT:    li a1, 31
; ZVFH32-NEXT:  .LBB121_2:
; ZVFH32-NEXT:    slli a1, a1, 1
; ZVFH32-NEXT:    add a0, a0, a1
; ZVFH32-NEXT:    vl4re16.v v8, (a0)
; ZVFH32-NEXT:    addi sp, s0, -48
; ZVFH32-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    addi sp, sp, 48
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv16bf16_offset_max:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    addi sp, sp, -48
; ZVFH64-NEXT:    .cfi_def_cfa_offset 48
; ZVFH64-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    .cfi_offset ra, -8
; ZVFH64-NEXT:    .cfi_offset s0, -16
; ZVFH64-NEXT:    addi s0, sp, 48
; ZVFH64-NEXT:    .cfi_def_cfa s0, 0
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 3
; ZVFH64-NEXT:    sub sp, sp, a0
; ZVFH64-NEXT:    andi sp, sp, -32
; ZVFH64-NEXT:    addi a0, sp, 32
; ZVFH64-NEXT:    vs4r.v v8, (a0)
; ZVFH64-NEXT:    csrr a1, vlenb
; ZVFH64-NEXT:    slli a2, a1, 2
; ZVFH64-NEXT:    add a2, a0, a2
; ZVFH64-NEXT:    slli a1, a1, 1
; ZVFH64-NEXT:    addi a1, a1, -1
; ZVFH64-NEXT:    li a3, 31
; ZVFH64-NEXT:    vs4r.v v12, (a2)
; ZVFH64-NEXT:    bltu a1, a3, .LBB121_2
; ZVFH64-NEXT:  # %bb.1:
; ZVFH64-NEXT:    li a1, 31
; ZVFH64-NEXT:  .LBB121_2:
; ZVFH64-NEXT:    slli a1, a1, 1
; ZVFH64-NEXT:    add a0, a0, a1
; ZVFH64-NEXT:    vl4re16.v v8, (a0)
; ZVFH64-NEXT:    addi sp, s0, -48
; ZVFH64-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    addi sp, sp, 48
; ZVFH64-NEXT:    ret
  %res = call <vscale x 16 x bfloat> @llvm.vector.splice.nxv16bf16(<vscale x 16 x bfloat> %a, <vscale x 16 x bfloat> %b, i32 31)
  ret <vscale x 16 x bfloat> %res
}

declare <vscale x 32 x bfloat> @llvm.vector.splice.nxv32bf16(<vscale x 32 x bfloat>, <vscale x 32 x bfloat>, i32)

define <vscale x 32 x bfloat> @splice_nxv32bf16_offset_zero(<vscale x 32 x bfloat> %a, <vscale x 32 x bfloat> %b) #0 {
; CHECK-LABEL: splice_nxv32bf16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x bfloat> @llvm.vector.splice.nxv32bf16(<vscale x 32 x bfloat> %a, <vscale x 32 x bfloat> %b, i32 0)
  ret <vscale x 32 x bfloat> %res
}

define <vscale x 32 x bfloat> @splice_nxv32bf16_offset_negone(<vscale x 32 x bfloat> %a, <vscale x 32 x bfloat> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv32bf16_offset_negone:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -80
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN64-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 80
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 4
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -64
; ZVFHMIN64-NEXT:    addi a0, sp, 64
; ZVFHMIN64-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 3
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vs8r.v v16, (a0)
; ZVFHMIN64-NEXT:    addi a0, a0, -2
; ZVFHMIN64-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -80
; ZVFHMIN64-NEXT:    lw ra, 76(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 72(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 80
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv32bf16_offset_negone:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -80
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN32-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 80
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 4
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -64
; ZVFHMIN32-NEXT:    addi a0, sp, 64
; ZVFHMIN32-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 3
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vs8r.v v16, (a0)
; ZVFHMIN32-NEXT:    addi a0, a0, -2
; ZVFHMIN32-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -80
; ZVFHMIN32-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 80
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv32bf16_offset_negone:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    addi sp, sp, -80
; ZVFH32-NEXT:    .cfi_def_cfa_offset 80
; ZVFH32-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    .cfi_offset ra, -4
; ZVFH32-NEXT:    .cfi_offset s0, -8
; ZVFH32-NEXT:    addi s0, sp, 80
; ZVFH32-NEXT:    .cfi_def_cfa s0, 0
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 4
; ZVFH32-NEXT:    sub sp, sp, a0
; ZVFH32-NEXT:    andi sp, sp, -64
; ZVFH32-NEXT:    addi a0, sp, 64
; ZVFH32-NEXT:    vs8r.v v8, (a0)
; ZVFH32-NEXT:    csrr a1, vlenb
; ZVFH32-NEXT:    slli a1, a1, 3
; ZVFH32-NEXT:    add a0, a0, a1
; ZVFH32-NEXT:    vs8r.v v16, (a0)
; ZVFH32-NEXT:    addi a0, a0, -2
; ZVFH32-NEXT:    vl8re16.v v8, (a0)
; ZVFH32-NEXT:    addi sp, s0, -80
; ZVFH32-NEXT:    lw ra, 76(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    lw s0, 72(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    addi sp, sp, 80
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv32bf16_offset_negone:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    addi sp, sp, -80
; ZVFH64-NEXT:    .cfi_def_cfa_offset 80
; ZVFH64-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    .cfi_offset ra, -8
; ZVFH64-NEXT:    .cfi_offset s0, -16
; ZVFH64-NEXT:    addi s0, sp, 80
; ZVFH64-NEXT:    .cfi_def_cfa s0, 0
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 4
; ZVFH64-NEXT:    sub sp, sp, a0
; ZVFH64-NEXT:    andi sp, sp, -64
; ZVFH64-NEXT:    addi a0, sp, 64
; ZVFH64-NEXT:    vs8r.v v8, (a0)
; ZVFH64-NEXT:    csrr a1, vlenb
; ZVFH64-NEXT:    slli a1, a1, 3
; ZVFH64-NEXT:    add a0, a0, a1
; ZVFH64-NEXT:    vs8r.v v16, (a0)
; ZVFH64-NEXT:    addi a0, a0, -2
; ZVFH64-NEXT:    vl8re16.v v8, (a0)
; ZVFH64-NEXT:    addi sp, s0, -80
; ZVFH64-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    addi sp, sp, 80
; ZVFH64-NEXT:    ret
  %res = call <vscale x 32 x bfloat> @llvm.vector.splice.nxv32bf16(<vscale x 32 x bfloat> %a, <vscale x 32 x bfloat> %b, i32 -1)
  ret <vscale x 32 x bfloat> %res
}

define <vscale x 32 x bfloat> @splice_nxv32bf16_offset_min(<vscale x 32 x bfloat> %a, <vscale x 32 x bfloat> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv32bf16_offset_min:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -80
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN64-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 80
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 4
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -64
; ZVFHMIN64-NEXT:    addi a0, sp, 64
; ZVFHMIN64-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 3
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    li a2, 128
; ZVFHMIN64-NEXT:    vs8r.v v16, (a0)
; ZVFHMIN64-NEXT:    bltu a1, a2, .LBB124_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 128
; ZVFHMIN64-NEXT:  .LBB124_2:
; ZVFHMIN64-NEXT:    sub a0, a0, a1
; ZVFHMIN64-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -80
; ZVFHMIN64-NEXT:    lw ra, 76(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 72(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 80
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv32bf16_offset_min:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -80
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN32-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 80
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 4
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -64
; ZVFHMIN32-NEXT:    addi a0, sp, 64
; ZVFHMIN32-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 3
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    li a2, 128
; ZVFHMIN32-NEXT:    vs8r.v v16, (a0)
; ZVFHMIN32-NEXT:    bltu a1, a2, .LBB124_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 128
; ZVFHMIN32-NEXT:  .LBB124_2:
; ZVFHMIN32-NEXT:    sub a0, a0, a1
; ZVFHMIN32-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -80
; ZVFHMIN32-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 80
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv32bf16_offset_min:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    addi sp, sp, -80
; ZVFH32-NEXT:    .cfi_def_cfa_offset 80
; ZVFH32-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    .cfi_offset ra, -4
; ZVFH32-NEXT:    .cfi_offset s0, -8
; ZVFH32-NEXT:    addi s0, sp, 80
; ZVFH32-NEXT:    .cfi_def_cfa s0, 0
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 4
; ZVFH32-NEXT:    sub sp, sp, a0
; ZVFH32-NEXT:    andi sp, sp, -64
; ZVFH32-NEXT:    addi a0, sp, 64
; ZVFH32-NEXT:    vs8r.v v8, (a0)
; ZVFH32-NEXT:    csrr a1, vlenb
; ZVFH32-NEXT:    slli a1, a1, 3
; ZVFH32-NEXT:    add a0, a0, a1
; ZVFH32-NEXT:    li a2, 128
; ZVFH32-NEXT:    vs8r.v v16, (a0)
; ZVFH32-NEXT:    bltu a1, a2, .LBB124_2
; ZVFH32-NEXT:  # %bb.1:
; ZVFH32-NEXT:    li a1, 128
; ZVFH32-NEXT:  .LBB124_2:
; ZVFH32-NEXT:    sub a0, a0, a1
; ZVFH32-NEXT:    vl8re16.v v8, (a0)
; ZVFH32-NEXT:    addi sp, s0, -80
; ZVFH32-NEXT:    lw ra, 76(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    lw s0, 72(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    addi sp, sp, 80
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv32bf16_offset_min:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    addi sp, sp, -80
; ZVFH64-NEXT:    .cfi_def_cfa_offset 80
; ZVFH64-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    .cfi_offset ra, -8
; ZVFH64-NEXT:    .cfi_offset s0, -16
; ZVFH64-NEXT:    addi s0, sp, 80
; ZVFH64-NEXT:    .cfi_def_cfa s0, 0
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 4
; ZVFH64-NEXT:    sub sp, sp, a0
; ZVFH64-NEXT:    andi sp, sp, -64
; ZVFH64-NEXT:    addi a0, sp, 64
; ZVFH64-NEXT:    vs8r.v v8, (a0)
; ZVFH64-NEXT:    csrr a1, vlenb
; ZVFH64-NEXT:    slli a1, a1, 3
; ZVFH64-NEXT:    add a0, a0, a1
; ZVFH64-NEXT:    li a2, 128
; ZVFH64-NEXT:    vs8r.v v16, (a0)
; ZVFH64-NEXT:    bltu a1, a2, .LBB124_2
; ZVFH64-NEXT:  # %bb.1:
; ZVFH64-NEXT:    li a1, 128
; ZVFH64-NEXT:  .LBB124_2:
; ZVFH64-NEXT:    sub a0, a0, a1
; ZVFH64-NEXT:    vl8re16.v v8, (a0)
; ZVFH64-NEXT:    addi sp, s0, -80
; ZVFH64-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    addi sp, sp, 80
; ZVFH64-NEXT:    ret
  %res = call <vscale x 32 x bfloat> @llvm.vector.splice.nxv32bf16(<vscale x 32 x bfloat> %a, <vscale x 32 x bfloat> %b, i32 -64)
  ret <vscale x 32 x bfloat> %res
}

define <vscale x 32 x bfloat> @splice_nxv32bf16_offset_max(<vscale x 32 x bfloat> %a, <vscale x 32 x bfloat> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv32bf16_offset_max:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -80
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN64-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 80
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 4
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -64
; ZVFHMIN64-NEXT:    addi a0, sp, 64
; ZVFHMIN64-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a2, a1, 3
; ZVFHMIN64-NEXT:    add a2, a0, a2
; ZVFHMIN64-NEXT:    slli a1, a1, 2
; ZVFHMIN64-NEXT:    addi a1, a1, -1
; ZVFHMIN64-NEXT:    li a3, 63
; ZVFHMIN64-NEXT:    vs8r.v v16, (a2)
; ZVFHMIN64-NEXT:    bltu a1, a3, .LBB125_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 63
; ZVFHMIN64-NEXT:  .LBB125_2:
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -80
; ZVFHMIN64-NEXT:    lw ra, 76(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 72(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 80
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv32bf16_offset_max:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -80
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN32-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 80
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 4
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -64
; ZVFHMIN32-NEXT:    addi a0, sp, 64
; ZVFHMIN32-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a2, a1, 3
; ZVFHMIN32-NEXT:    add a2, a0, a2
; ZVFHMIN32-NEXT:    slli a1, a1, 2
; ZVFHMIN32-NEXT:    addi a1, a1, -1
; ZVFHMIN32-NEXT:    li a3, 63
; ZVFHMIN32-NEXT:    vs8r.v v16, (a2)
; ZVFHMIN32-NEXT:    bltu a1, a3, .LBB125_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 63
; ZVFHMIN32-NEXT:  .LBB125_2:
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -80
; ZVFHMIN32-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 80
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv32bf16_offset_max:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    addi sp, sp, -80
; ZVFH32-NEXT:    .cfi_def_cfa_offset 80
; ZVFH32-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; ZVFH32-NEXT:    .cfi_offset ra, -4
; ZVFH32-NEXT:    .cfi_offset s0, -8
; ZVFH32-NEXT:    addi s0, sp, 80
; ZVFH32-NEXT:    .cfi_def_cfa s0, 0
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 4
; ZVFH32-NEXT:    sub sp, sp, a0
; ZVFH32-NEXT:    andi sp, sp, -64
; ZVFH32-NEXT:    addi a0, sp, 64
; ZVFH32-NEXT:    vs8r.v v8, (a0)
; ZVFH32-NEXT:    csrr a1, vlenb
; ZVFH32-NEXT:    slli a2, a1, 3
; ZVFH32-NEXT:    add a2, a0, a2
; ZVFH32-NEXT:    slli a1, a1, 2
; ZVFH32-NEXT:    addi a1, a1, -1
; ZVFH32-NEXT:    li a3, 63
; ZVFH32-NEXT:    vs8r.v v16, (a2)
; ZVFH32-NEXT:    bltu a1, a3, .LBB125_2
; ZVFH32-NEXT:  # %bb.1:
; ZVFH32-NEXT:    li a1, 63
; ZVFH32-NEXT:  .LBB125_2:
; ZVFH32-NEXT:    slli a1, a1, 1
; ZVFH32-NEXT:    add a0, a0, a1
; ZVFH32-NEXT:    vl8re16.v v8, (a0)
; ZVFH32-NEXT:    addi sp, s0, -80
; ZVFH32-NEXT:    lw ra, 76(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    lw s0, 72(sp) # 4-byte Folded Reload
; ZVFH32-NEXT:    addi sp, sp, 80
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv32bf16_offset_max:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    addi sp, sp, -80
; ZVFH64-NEXT:    .cfi_def_cfa_offset 80
; ZVFH64-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
; ZVFH64-NEXT:    .cfi_offset ra, -8
; ZVFH64-NEXT:    .cfi_offset s0, -16
; ZVFH64-NEXT:    addi s0, sp, 80
; ZVFH64-NEXT:    .cfi_def_cfa s0, 0
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 4
; ZVFH64-NEXT:    sub sp, sp, a0
; ZVFH64-NEXT:    andi sp, sp, -64
; ZVFH64-NEXT:    addi a0, sp, 64
; ZVFH64-NEXT:    vs8r.v v8, (a0)
; ZVFH64-NEXT:    csrr a1, vlenb
; ZVFH64-NEXT:    slli a2, a1, 3
; ZVFH64-NEXT:    add a2, a0, a2
; ZVFH64-NEXT:    slli a1, a1, 2
; ZVFH64-NEXT:    addi a1, a1, -1
; ZVFH64-NEXT:    li a3, 63
; ZVFH64-NEXT:    vs8r.v v16, (a2)
; ZVFH64-NEXT:    bltu a1, a3, .LBB125_2
; ZVFH64-NEXT:  # %bb.1:
; ZVFH64-NEXT:    li a1, 63
; ZVFH64-NEXT:  .LBB125_2:
; ZVFH64-NEXT:    slli a1, a1, 1
; ZVFH64-NEXT:    add a0, a0, a1
; ZVFH64-NEXT:    vl8re16.v v8, (a0)
; ZVFH64-NEXT:    addi sp, s0, -80
; ZVFH64-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
; ZVFH64-NEXT:    addi sp, sp, 80
; ZVFH64-NEXT:    ret
  %res = call <vscale x 32 x bfloat> @llvm.vector.splice.nxv32bf16(<vscale x 32 x bfloat> %a, <vscale x 32 x bfloat> %b, i32 63)
  ret <vscale x 32 x bfloat> %res
}

declare <vscale x 1 x half> @llvm.vector.splice.nxv1f16(<vscale x 1 x half>, <vscale x 1 x half>, i32)

define <vscale x 1 x half> @splice_nxv1f16_offset_zero(<vscale x 1 x half> %a, <vscale x 1 x half> %b) #0 {
; CHECK-LABEL: splice_nxv1f16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x half> @llvm.vector.splice.nxv1f16(<vscale x 1 x half> %a, <vscale x 1 x half> %b, i32 0)
  ret <vscale x 1 x half> %res
}

define <vscale x 1 x half> @splice_nxv1f16_offset_negone(<vscale x 1 x half> %a, <vscale x 1 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv1f16_offset_negone:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFHMIN64-NEXT:    vse16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    srli a1, a1, 2
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vse16.v v9, (a0)
; ZVFHMIN64-NEXT:    addi a0, a0, -2
; ZVFHMIN64-NEXT:    vle16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv1f16_offset_negone:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFHMIN32-NEXT:    vse16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    srli a1, a1, 2
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vse16.v v9, (a0)
; ZVFHMIN32-NEXT:    addi a0, a0, -2
; ZVFHMIN32-NEXT:    vle16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv1f16_offset_negone:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    srli a0, a0, 3
; ZVFH32-NEXT:    addi a0, a0, -1
; ZVFH32-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vslideup.vi v8, v9, 1
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv1f16_offset_negone:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    srli a0, a0, 3
; ZVFH64-NEXT:    addi a0, a0, -1
; ZVFH64-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vslideup.vi v8, v9, 1
; ZVFH64-NEXT:    ret
  %res = call <vscale x 1 x half> @llvm.vector.splice.nxv1f16(<vscale x 1 x half> %a, <vscale x 1 x half> %b, i32 -1)
  ret <vscale x 1 x half> %res
}

define <vscale x 1 x half> @splice_nxv1f16_offset_min(<vscale x 1 x half> %a, <vscale x 1 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv1f16_offset_min:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFHMIN64-NEXT:    vse16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    srli a1, a1, 2
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    li a2, 4
; ZVFHMIN64-NEXT:    vse16.v v9, (a0)
; ZVFHMIN64-NEXT:    bltu a1, a2, .LBB128_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 4
; ZVFHMIN64-NEXT:  .LBB128_2:
; ZVFHMIN64-NEXT:    sub a0, a0, a1
; ZVFHMIN64-NEXT:    vle16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv1f16_offset_min:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFHMIN32-NEXT:    vse16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    srli a1, a1, 2
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    li a2, 4
; ZVFHMIN32-NEXT:    vse16.v v9, (a0)
; ZVFHMIN32-NEXT:    bltu a1, a2, .LBB128_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 4
; ZVFHMIN32-NEXT:  .LBB128_2:
; ZVFHMIN32-NEXT:    sub a0, a0, a1
; ZVFHMIN32-NEXT:    vle16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv1f16_offset_min:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    srli a0, a0, 3
; ZVFH32-NEXT:    addi a0, a0, -2
; ZVFH32-NEXT:    vsetivli zero, 2, e16, mf4, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vsetvli a0, zero, e16, mf4, ta, ma
; ZVFH32-NEXT:    vslideup.vi v8, v9, 2
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv1f16_offset_min:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    srli a0, a0, 3
; ZVFH64-NEXT:    addi a0, a0, -2
; ZVFH64-NEXT:    vsetivli zero, 2, e16, mf4, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vsetvli a0, zero, e16, mf4, ta, ma
; ZVFH64-NEXT:    vslideup.vi v8, v9, 2
; ZVFH64-NEXT:    ret
  %res = call <vscale x 1 x half> @llvm.vector.splice.nxv1f16(<vscale x 1 x half> %a, <vscale x 1 x half> %b, i32 -2)
  ret <vscale x 1 x half> %res
}

define <vscale x 1 x half> @splice_nxv1f16_offset_max(<vscale x 1 x half> %a, <vscale x 1 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv1f16_offset_max:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFHMIN64-NEXT:    vse16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    srli a2, a1, 2
; ZVFHMIN64-NEXT:    add a2, a0, a2
; ZVFHMIN64-NEXT:    srli a1, a1, 3
; ZVFHMIN64-NEXT:    addi a1, a1, -1
; ZVFHMIN64-NEXT:    li a3, 1
; ZVFHMIN64-NEXT:    vse16.v v9, (a2)
; ZVFHMIN64-NEXT:    bltu a1, a3, .LBB129_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 1
; ZVFHMIN64-NEXT:  .LBB129_2:
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vle16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv1f16_offset_max:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFHMIN32-NEXT:    vse16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    srli a2, a1, 2
; ZVFHMIN32-NEXT:    add a2, a0, a2
; ZVFHMIN32-NEXT:    srli a1, a1, 3
; ZVFHMIN32-NEXT:    addi a1, a1, -1
; ZVFHMIN32-NEXT:    li a3, 1
; ZVFHMIN32-NEXT:    vse16.v v9, (a2)
; ZVFHMIN32-NEXT:    bltu a1, a3, .LBB129_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 1
; ZVFHMIN32-NEXT:  .LBB129_2:
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vle16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv1f16_offset_max:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    srli a0, a0, 3
; ZVFH32-NEXT:    addi a0, a0, -1
; ZVFH32-NEXT:    vsetvli zero, a0, e16, mf4, ta, ma
; ZVFH32-NEXT:    vslidedown.vi v8, v8, 1
; ZVFH32-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFH32-NEXT:    vslideup.vx v8, v9, a0
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv1f16_offset_max:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    srli a0, a0, 3
; ZVFH64-NEXT:    addi a0, a0, -1
; ZVFH64-NEXT:    vsetvli zero, a0, e16, mf4, ta, ma
; ZVFH64-NEXT:    vslidedown.vi v8, v8, 1
; ZVFH64-NEXT:    vsetvli a1, zero, e16, mf4, ta, ma
; ZVFH64-NEXT:    vslideup.vx v8, v9, a0
; ZVFH64-NEXT:    ret
  %res = call <vscale x 1 x half> @llvm.vector.splice.nxv1f16(<vscale x 1 x half> %a, <vscale x 1 x half> %b, i32 1)
  ret <vscale x 1 x half> %res
}

declare <vscale x 2 x half> @llvm.vector.splice.nxv2f16(<vscale x 2 x half>, <vscale x 2 x half>, i32)

define <vscale x 2 x half> @splice_nxv2f16_offset_zero(<vscale x 2 x half> %a, <vscale x 2 x half> %b) #0 {
; CHECK-LABEL: splice_nxv2f16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x half> @llvm.vector.splice.nxv2f16(<vscale x 2 x half> %a, <vscale x 2 x half> %b, i32 0)
  ret <vscale x 2 x half> %res
}

define <vscale x 2 x half> @splice_nxv2f16_offset_negone(<vscale x 2 x half> %a, <vscale x 2 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv2f16_offset_negone:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFHMIN64-NEXT:    vse16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    srli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vse16.v v9, (a0)
; ZVFHMIN64-NEXT:    addi a0, a0, -2
; ZVFHMIN64-NEXT:    vle16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv2f16_offset_negone:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFHMIN32-NEXT:    vse16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    srli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vse16.v v9, (a0)
; ZVFHMIN32-NEXT:    addi a0, a0, -2
; ZVFHMIN32-NEXT:    vle16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv2f16_offset_negone:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    srli a0, a0, 2
; ZVFH32-NEXT:    addi a0, a0, -1
; ZVFH32-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vslideup.vi v8, v9, 1
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv2f16_offset_negone:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    srli a0, a0, 2
; ZVFH64-NEXT:    addi a0, a0, -1
; ZVFH64-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vslideup.vi v8, v9, 1
; ZVFH64-NEXT:    ret
  %res = call <vscale x 2 x half> @llvm.vector.splice.nxv2f16(<vscale x 2 x half> %a, <vscale x 2 x half> %b, i32 -1)
  ret <vscale x 2 x half> %res
}

define <vscale x 2 x half> @splice_nxv2f16_offset_min(<vscale x 2 x half> %a, <vscale x 2 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv2f16_offset_min:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFHMIN64-NEXT:    vse16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    srli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    li a2, 8
; ZVFHMIN64-NEXT:    vse16.v v9, (a0)
; ZVFHMIN64-NEXT:    bltu a1, a2, .LBB132_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 8
; ZVFHMIN64-NEXT:  .LBB132_2:
; ZVFHMIN64-NEXT:    sub a0, a0, a1
; ZVFHMIN64-NEXT:    vle16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv2f16_offset_min:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFHMIN32-NEXT:    vse16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    srli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    li a2, 8
; ZVFHMIN32-NEXT:    vse16.v v9, (a0)
; ZVFHMIN32-NEXT:    bltu a1, a2, .LBB132_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 8
; ZVFHMIN32-NEXT:  .LBB132_2:
; ZVFHMIN32-NEXT:    sub a0, a0, a1
; ZVFHMIN32-NEXT:    vle16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv2f16_offset_min:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    srli a0, a0, 2
; ZVFH32-NEXT:    addi a0, a0, -4
; ZVFH32-NEXT:    vsetivli zero, 4, e16, mf2, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vsetvli a0, zero, e16, mf2, ta, ma
; ZVFH32-NEXT:    vslideup.vi v8, v9, 4
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv2f16_offset_min:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    srli a0, a0, 2
; ZVFH64-NEXT:    addi a0, a0, -4
; ZVFH64-NEXT:    vsetivli zero, 4, e16, mf2, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vsetvli a0, zero, e16, mf2, ta, ma
; ZVFH64-NEXT:    vslideup.vi v8, v9, 4
; ZVFH64-NEXT:    ret
  %res = call <vscale x 2 x half> @llvm.vector.splice.nxv2f16(<vscale x 2 x half> %a, <vscale x 2 x half> %b, i32 -4)
  ret <vscale x 2 x half> %res
}

define <vscale x 2 x half> @splice_nxv2f16_offset_max(<vscale x 2 x half> %a, <vscale x 2 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv2f16_offset_max:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFHMIN64-NEXT:    vse16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    srli a2, a1, 1
; ZVFHMIN64-NEXT:    add a2, a0, a2
; ZVFHMIN64-NEXT:    srli a1, a1, 2
; ZVFHMIN64-NEXT:    addi a1, a1, -1
; ZVFHMIN64-NEXT:    li a3, 3
; ZVFHMIN64-NEXT:    vse16.v v9, (a2)
; ZVFHMIN64-NEXT:    bltu a1, a3, .LBB133_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 3
; ZVFHMIN64-NEXT:  .LBB133_2:
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vle16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv2f16_offset_max:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 1 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFHMIN32-NEXT:    vse16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    srli a2, a1, 1
; ZVFHMIN32-NEXT:    add a2, a0, a2
; ZVFHMIN32-NEXT:    srli a1, a1, 2
; ZVFHMIN32-NEXT:    addi a1, a1, -1
; ZVFHMIN32-NEXT:    li a3, 3
; ZVFHMIN32-NEXT:    vse16.v v9, (a2)
; ZVFHMIN32-NEXT:    bltu a1, a3, .LBB133_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 3
; ZVFHMIN32-NEXT:  .LBB133_2:
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vle16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv2f16_offset_max:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    srli a0, a0, 2
; ZVFH32-NEXT:    addi a0, a0, -3
; ZVFH32-NEXT:    vsetvli zero, a0, e16, mf2, ta, ma
; ZVFH32-NEXT:    vslidedown.vi v8, v8, 3
; ZVFH32-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFH32-NEXT:    vslideup.vx v8, v9, a0
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv2f16_offset_max:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    srli a0, a0, 2
; ZVFH64-NEXT:    addi a0, a0, -3
; ZVFH64-NEXT:    vsetvli zero, a0, e16, mf2, ta, ma
; ZVFH64-NEXT:    vslidedown.vi v8, v8, 3
; ZVFH64-NEXT:    vsetvli a1, zero, e16, mf2, ta, ma
; ZVFH64-NEXT:    vslideup.vx v8, v9, a0
; ZVFH64-NEXT:    ret
  %res = call <vscale x 2 x half> @llvm.vector.splice.nxv2f16(<vscale x 2 x half> %a, <vscale x 2 x half> %b, i32 3)
  ret <vscale x 2 x half> %res
}

declare <vscale x 4 x half> @llvm.vector.splice.nxv4f16(<vscale x 4 x half>, <vscale x 4 x half>, i32)

define <vscale x 4 x half> @splice_nxv4f16_offset_zero(<vscale x 4 x half> %a, <vscale x 4 x half> %b) #0 {
; CHECK-LABEL: splice_nxv4f16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x half> @llvm.vector.splice.nxv4f16(<vscale x 4 x half> %a, <vscale x 4 x half> %b, i32 0)
  ret <vscale x 4 x half> %res
}

define <vscale x 4 x half> @splice_nxv4f16_offset_negone(<vscale x 4 x half> %a, <vscale x 4 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv4f16_offset_negone:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 1
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x02, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 2 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vs1r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vs1r.v v9, (a0)
; ZVFHMIN64-NEXT:    addi a0, a0, -2
; ZVFHMIN64-NEXT:    vl1re16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 1
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv4f16_offset_negone:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 1
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x02, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 2 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vs1r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vs1r.v v9, (a0)
; ZVFHMIN32-NEXT:    addi a0, a0, -2
; ZVFHMIN32-NEXT:    vl1re16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 1
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv4f16_offset_negone:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    srli a0, a0, 1
; ZVFH32-NEXT:    addi a0, a0, -1
; ZVFH32-NEXT:    vsetvli a1, zero, e16, m1, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vslideup.vi v8, v9, 1
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv4f16_offset_negone:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    srli a0, a0, 1
; ZVFH64-NEXT:    addi a0, a0, -1
; ZVFH64-NEXT:    vsetvli a1, zero, e16, m1, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vslideup.vi v8, v9, 1
; ZVFH64-NEXT:    ret
  %res = call <vscale x 4 x half> @llvm.vector.splice.nxv4f16(<vscale x 4 x half> %a, <vscale x 4 x half> %b, i32 -1)
  ret <vscale x 4 x half> %res
}

define <vscale x 4 x half> @splice_nxv4f16_offset_min(<vscale x 4 x half> %a, <vscale x 4 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv4f16_offset_min:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 1
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x02, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 2 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vs1r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    li a2, 16
; ZVFHMIN64-NEXT:    vs1r.v v9, (a0)
; ZVFHMIN64-NEXT:    bltu a1, a2, .LBB136_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 16
; ZVFHMIN64-NEXT:  .LBB136_2:
; ZVFHMIN64-NEXT:    sub a0, a0, a1
; ZVFHMIN64-NEXT:    vl1re16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 1
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv4f16_offset_min:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 1
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x02, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 2 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vs1r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    li a2, 16
; ZVFHMIN32-NEXT:    vs1r.v v9, (a0)
; ZVFHMIN32-NEXT:    bltu a1, a2, .LBB136_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 16
; ZVFHMIN32-NEXT:  .LBB136_2:
; ZVFHMIN32-NEXT:    sub a0, a0, a1
; ZVFHMIN32-NEXT:    vl1re16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 1
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv4f16_offset_min:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    srli a0, a0, 1
; ZVFH32-NEXT:    addi a0, a0, -8
; ZVFH32-NEXT:    vsetivli zero, 8, e16, m1, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vsetvli a0, zero, e16, m1, ta, ma
; ZVFH32-NEXT:    vslideup.vi v8, v9, 8
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv4f16_offset_min:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    srli a0, a0, 1
; ZVFH64-NEXT:    addi a0, a0, -8
; ZVFH64-NEXT:    vsetivli zero, 8, e16, m1, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vsetvli a0, zero, e16, m1, ta, ma
; ZVFH64-NEXT:    vslideup.vi v8, v9, 8
; ZVFH64-NEXT:    ret
  %res = call <vscale x 4 x half> @llvm.vector.splice.nxv4f16(<vscale x 4 x half> %a, <vscale x 4 x half> %b, i32 -8)
  ret <vscale x 4 x half> %res
}

define <vscale x 4 x half> @splice_nxv4f16_offset_max(<vscale x 4 x half> %a, <vscale x 4 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv4f16_offset_max:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 1
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x02, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 2 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vs1r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    add a2, a0, a1
; ZVFHMIN64-NEXT:    srli a1, a1, 1
; ZVFHMIN64-NEXT:    addi a1, a1, -1
; ZVFHMIN64-NEXT:    li a3, 7
; ZVFHMIN64-NEXT:    vs1r.v v9, (a2)
; ZVFHMIN64-NEXT:    bltu a1, a3, .LBB137_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 7
; ZVFHMIN64-NEXT:  .LBB137_2:
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vl1re16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 1
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv4f16_offset_max:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 1
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x02, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 2 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vs1r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    add a2, a0, a1
; ZVFHMIN32-NEXT:    srli a1, a1, 1
; ZVFHMIN32-NEXT:    addi a1, a1, -1
; ZVFHMIN32-NEXT:    li a3, 7
; ZVFHMIN32-NEXT:    vs1r.v v9, (a2)
; ZVFHMIN32-NEXT:    bltu a1, a3, .LBB137_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 7
; ZVFHMIN32-NEXT:  .LBB137_2:
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vl1re16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 1
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv4f16_offset_max:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    srli a0, a0, 1
; ZVFH32-NEXT:    addi a0, a0, -7
; ZVFH32-NEXT:    vsetvli zero, a0, e16, m1, ta, ma
; ZVFH32-NEXT:    vslidedown.vi v8, v8, 7
; ZVFH32-NEXT:    vsetvli a1, zero, e16, m1, ta, ma
; ZVFH32-NEXT:    vslideup.vx v8, v9, a0
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv4f16_offset_max:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    srli a0, a0, 1
; ZVFH64-NEXT:    addi a0, a0, -7
; ZVFH64-NEXT:    vsetvli zero, a0, e16, m1, ta, ma
; ZVFH64-NEXT:    vslidedown.vi v8, v8, 7
; ZVFH64-NEXT:    vsetvli a1, zero, e16, m1, ta, ma
; ZVFH64-NEXT:    vslideup.vx v8, v9, a0
; ZVFH64-NEXT:    ret
  %res = call <vscale x 4 x half> @llvm.vector.splice.nxv4f16(<vscale x 4 x half> %a, <vscale x 4 x half> %b, i32 7)
  ret <vscale x 4 x half> %res
}

declare <vscale x 8 x half> @llvm.vector.splice.nxv8f16(<vscale x 8 x half>, <vscale x 8 x half>, i32)

define <vscale x 8 x half> @splice_nxv8f16_offset_zero(<vscale x 8 x half> %a, <vscale x 8 x half> %b) #0 {
; CHECK-LABEL: splice_nxv8f16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x half> @llvm.vector.splice.nxv8f16(<vscale x 8 x half> %a, <vscale x 8 x half> %b, i32 0)
  ret <vscale x 8 x half> %res
}

define <vscale x 8 x half> @splice_nxv8f16_offset_negone(<vscale x 8 x half> %a, <vscale x 8 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv8f16_offset_negone:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 2
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x04, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 4 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vs2r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vs2r.v v10, (a0)
; ZVFHMIN64-NEXT:    addi a0, a0, -2
; ZVFHMIN64-NEXT:    vl2re16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 2
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv8f16_offset_negone:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 2
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x04, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 4 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vs2r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vs2r.v v10, (a0)
; ZVFHMIN32-NEXT:    addi a0, a0, -2
; ZVFHMIN32-NEXT:    vl2re16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 2
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv8f16_offset_negone:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    addi a0, a0, -1
; ZVFH32-NEXT:    vsetivli zero, 1, e16, m2, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vsetvli a0, zero, e16, m2, ta, ma
; ZVFH32-NEXT:    vslideup.vi v8, v10, 1
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv8f16_offset_negone:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    addi a0, a0, -1
; ZVFH64-NEXT:    vsetivli zero, 1, e16, m2, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vsetvli a0, zero, e16, m2, ta, ma
; ZVFH64-NEXT:    vslideup.vi v8, v10, 1
; ZVFH64-NEXT:    ret
  %res = call <vscale x 8 x half> @llvm.vector.splice.nxv8f16(<vscale x 8 x half> %a, <vscale x 8 x half> %b, i32 -1)
  ret <vscale x 8 x half> %res
}

define <vscale x 8 x half> @splice_nxv8f16_offset_min(<vscale x 8 x half> %a, <vscale x 8 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv8f16_offset_min:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 2
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x04, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 4 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vs2r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    li a2, 32
; ZVFHMIN64-NEXT:    vs2r.v v10, (a0)
; ZVFHMIN64-NEXT:    bltu a1, a2, .LBB140_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 32
; ZVFHMIN64-NEXT:  .LBB140_2:
; ZVFHMIN64-NEXT:    sub a0, a0, a1
; ZVFHMIN64-NEXT:    vl2re16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 2
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv8f16_offset_min:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 2
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x04, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 4 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vs2r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    li a2, 32
; ZVFHMIN32-NEXT:    vs2r.v v10, (a0)
; ZVFHMIN32-NEXT:    bltu a1, a2, .LBB140_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 32
; ZVFHMIN32-NEXT:  .LBB140_2:
; ZVFHMIN32-NEXT:    sub a0, a0, a1
; ZVFHMIN32-NEXT:    vl2re16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 2
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv8f16_offset_min:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    addi a0, a0, -16
; ZVFH32-NEXT:    vsetivli zero, 16, e16, m2, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vsetvli a0, zero, e16, m2, ta, ma
; ZVFH32-NEXT:    vslideup.vi v8, v10, 16
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv8f16_offset_min:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    addi a0, a0, -16
; ZVFH64-NEXT:    vsetivli zero, 16, e16, m2, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vsetvli a0, zero, e16, m2, ta, ma
; ZVFH64-NEXT:    vslideup.vi v8, v10, 16
; ZVFH64-NEXT:    ret
  %res = call <vscale x 8 x half> @llvm.vector.splice.nxv8f16(<vscale x 8 x half> %a, <vscale x 8 x half> %b, i32 -16)
  ret <vscale x 8 x half> %res
}

define <vscale x 8 x half> @splice_nxv8f16_offset_max(<vscale x 8 x half> %a, <vscale x 8 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv8f16_offset_max:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -16
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 2
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x04, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 4 * vlenb
; ZVFHMIN64-NEXT:    addi a0, sp, 16
; ZVFHMIN64-NEXT:    vs2r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a2, a1, 1
; ZVFHMIN64-NEXT:    add a2, a0, a2
; ZVFHMIN64-NEXT:    addi a1, a1, -1
; ZVFHMIN64-NEXT:    li a3, 15
; ZVFHMIN64-NEXT:    vs2r.v v10, (a2)
; ZVFHMIN64-NEXT:    bltu a1, a3, .LBB141_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 15
; ZVFHMIN64-NEXT:  .LBB141_2:
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vl2re16.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 2
; ZVFHMIN64-NEXT:    add sp, sp, a0
; ZVFHMIN64-NEXT:    addi sp, sp, 16
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv8f16_offset_max:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -16
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 16
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 2
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x04, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 16 + 4 * vlenb
; ZVFHMIN32-NEXT:    addi a0, sp, 16
; ZVFHMIN32-NEXT:    vs2r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a2, a1, 1
; ZVFHMIN32-NEXT:    add a2, a0, a2
; ZVFHMIN32-NEXT:    addi a1, a1, -1
; ZVFHMIN32-NEXT:    li a3, 15
; ZVFHMIN32-NEXT:    vs2r.v v10, (a2)
; ZVFHMIN32-NEXT:    bltu a1, a3, .LBB141_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 15
; ZVFHMIN32-NEXT:  .LBB141_2:
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vl2re16.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 2
; ZVFHMIN32-NEXT:    add sp, sp, a0
; ZVFHMIN32-NEXT:    addi sp, sp, 16
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv8f16_offset_max:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    addi a0, a0, -15
; ZVFH32-NEXT:    vsetvli zero, a0, e16, m2, ta, ma
; ZVFH32-NEXT:    vslidedown.vi v8, v8, 15
; ZVFH32-NEXT:    vsetvli a1, zero, e16, m2, ta, ma
; ZVFH32-NEXT:    vslideup.vx v8, v10, a0
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv8f16_offset_max:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    addi a0, a0, -15
; ZVFH64-NEXT:    vsetvli zero, a0, e16, m2, ta, ma
; ZVFH64-NEXT:    vslidedown.vi v8, v8, 15
; ZVFH64-NEXT:    vsetvli a1, zero, e16, m2, ta, ma
; ZVFH64-NEXT:    vslideup.vx v8, v10, a0
; ZVFH64-NEXT:    ret
  %res = call <vscale x 8 x half> @llvm.vector.splice.nxv8f16(<vscale x 8 x half> %a, <vscale x 8 x half> %b, i32 15)
  ret <vscale x 8 x half> %res
}

declare <vscale x 16 x half> @llvm.vector.splice.nxv16f16(<vscale x 16 x half>, <vscale x 16 x half>, i32)

define <vscale x 16 x half> @splice_nxv16f16_offset_zero(<vscale x 16 x half> %a, <vscale x 16 x half> %b) #0 {
; CHECK-LABEL: splice_nxv16f16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x half> @llvm.vector.splice.nxv16f16(<vscale x 16 x half> %a, <vscale x 16 x half> %b, i32 0)
  ret <vscale x 16 x half> %res
}

define <vscale x 16 x half> @splice_nxv16f16_offset_negone(<vscale x 16 x half> %a, <vscale x 16 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv16f16_offset_negone:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -48
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN64-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 48
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 3
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -32
; ZVFHMIN64-NEXT:    addi a0, sp, 32
; ZVFHMIN64-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 2
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vs4r.v v12, (a0)
; ZVFHMIN64-NEXT:    addi a0, a0, -2
; ZVFHMIN64-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -48
; ZVFHMIN64-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 48
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv16f16_offset_negone:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -48
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN32-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 48
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 3
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -32
; ZVFHMIN32-NEXT:    addi a0, sp, 32
; ZVFHMIN32-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 2
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vs4r.v v12, (a0)
; ZVFHMIN32-NEXT:    addi a0, a0, -2
; ZVFHMIN32-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -48
; ZVFHMIN32-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 48
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv16f16_offset_negone:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 1
; ZVFH32-NEXT:    addi a0, a0, -1
; ZVFH32-NEXT:    vsetivli zero, 1, e16, m4, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vsetvli a0, zero, e16, m4, ta, ma
; ZVFH32-NEXT:    vslideup.vi v8, v12, 1
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv16f16_offset_negone:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 1
; ZVFH64-NEXT:    addi a0, a0, -1
; ZVFH64-NEXT:    vsetivli zero, 1, e16, m4, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vsetvli a0, zero, e16, m4, ta, ma
; ZVFH64-NEXT:    vslideup.vi v8, v12, 1
; ZVFH64-NEXT:    ret
  %res = call <vscale x 16 x half> @llvm.vector.splice.nxv16f16(<vscale x 16 x half> %a, <vscale x 16 x half> %b, i32 -1)
  ret <vscale x 16 x half> %res
}

define <vscale x 16 x half> @splice_nxv16f16_offset_min(<vscale x 16 x half> %a, <vscale x 16 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv16f16_offset_min:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -48
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN64-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 48
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 3
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -32
; ZVFHMIN64-NEXT:    addi a0, sp, 32
; ZVFHMIN64-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 2
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    li a2, 64
; ZVFHMIN64-NEXT:    vs4r.v v12, (a0)
; ZVFHMIN64-NEXT:    bltu a1, a2, .LBB144_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 64
; ZVFHMIN64-NEXT:  .LBB144_2:
; ZVFHMIN64-NEXT:    sub a0, a0, a1
; ZVFHMIN64-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -48
; ZVFHMIN64-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 48
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv16f16_offset_min:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -48
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN32-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 48
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 3
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -32
; ZVFHMIN32-NEXT:    addi a0, sp, 32
; ZVFHMIN32-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 2
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    li a2, 64
; ZVFHMIN32-NEXT:    vs4r.v v12, (a0)
; ZVFHMIN32-NEXT:    bltu a1, a2, .LBB144_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 64
; ZVFHMIN32-NEXT:  .LBB144_2:
; ZVFHMIN32-NEXT:    sub a0, a0, a1
; ZVFHMIN32-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -48
; ZVFHMIN32-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 48
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv16f16_offset_min:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 1
; ZVFH32-NEXT:    addi a0, a0, -32
; ZVFH32-NEXT:    li a1, 32
; ZVFH32-NEXT:    vsetvli zero, a1, e16, m4, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vsetvli a0, zero, e16, m4, ta, ma
; ZVFH32-NEXT:    vslideup.vx v8, v12, a1
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv16f16_offset_min:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 1
; ZVFH64-NEXT:    addi a0, a0, -32
; ZVFH64-NEXT:    li a1, 32
; ZVFH64-NEXT:    vsetvli zero, a1, e16, m4, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vsetvli a0, zero, e16, m4, ta, ma
; ZVFH64-NEXT:    vslideup.vx v8, v12, a1
; ZVFH64-NEXT:    ret
  %res = call <vscale x 16 x half> @llvm.vector.splice.nxv16f16(<vscale x 16 x half> %a, <vscale x 16 x half> %b, i32 -32)
  ret <vscale x 16 x half> %res
}

define <vscale x 16 x half> @splice_nxv16f16_offset_max(<vscale x 16 x half> %a, <vscale x 16 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv16f16_offset_max:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -48
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN64-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 48
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 3
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -32
; ZVFHMIN64-NEXT:    addi a0, sp, 32
; ZVFHMIN64-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a2, a1, 2
; ZVFHMIN64-NEXT:    add a2, a0, a2
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    addi a1, a1, -1
; ZVFHMIN64-NEXT:    li a3, 31
; ZVFHMIN64-NEXT:    vs4r.v v12, (a2)
; ZVFHMIN64-NEXT:    bltu a1, a3, .LBB145_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 31
; ZVFHMIN64-NEXT:  .LBB145_2:
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -48
; ZVFHMIN64-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 48
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv16f16_offset_max:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -48
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 48
; ZVFHMIN32-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 48
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 3
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -32
; ZVFHMIN32-NEXT:    addi a0, sp, 32
; ZVFHMIN32-NEXT:    vs4r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a2, a1, 2
; ZVFHMIN32-NEXT:    add a2, a0, a2
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    addi a1, a1, -1
; ZVFHMIN32-NEXT:    li a3, 31
; ZVFHMIN32-NEXT:    vs4r.v v12, (a2)
; ZVFHMIN32-NEXT:    bltu a1, a3, .LBB145_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 31
; ZVFHMIN32-NEXT:  .LBB145_2:
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vl4re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -48
; ZVFHMIN32-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 48
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv16f16_offset_max:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 1
; ZVFH32-NEXT:    addi a0, a0, -31
; ZVFH32-NEXT:    vsetvli zero, a0, e16, m4, ta, ma
; ZVFH32-NEXT:    vslidedown.vi v8, v8, 31
; ZVFH32-NEXT:    vsetvli a1, zero, e16, m4, ta, ma
; ZVFH32-NEXT:    vslideup.vx v8, v12, a0
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv16f16_offset_max:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 1
; ZVFH64-NEXT:    addi a0, a0, -31
; ZVFH64-NEXT:    vsetvli zero, a0, e16, m4, ta, ma
; ZVFH64-NEXT:    vslidedown.vi v8, v8, 31
; ZVFH64-NEXT:    vsetvli a1, zero, e16, m4, ta, ma
; ZVFH64-NEXT:    vslideup.vx v8, v12, a0
; ZVFH64-NEXT:    ret
  %res = call <vscale x 16 x half> @llvm.vector.splice.nxv16f16(<vscale x 16 x half> %a, <vscale x 16 x half> %b, i32 31)
  ret <vscale x 16 x half> %res
}

declare <vscale x 32 x half> @llvm.vector.splice.nxv32f16(<vscale x 32 x half>, <vscale x 32 x half>, i32)

define <vscale x 32 x half> @splice_nxv32f16_offset_zero(<vscale x 32 x half> %a, <vscale x 32 x half> %b) #0 {
; CHECK-LABEL: splice_nxv32f16_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 32 x half> @llvm.vector.splice.nxv32f16(<vscale x 32 x half> %a, <vscale x 32 x half> %b, i32 0)
  ret <vscale x 32 x half> %res
}

define <vscale x 32 x half> @splice_nxv32f16_offset_negone(<vscale x 32 x half> %a, <vscale x 32 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv32f16_offset_negone:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -80
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN64-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 80
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 4
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -64
; ZVFHMIN64-NEXT:    addi a0, sp, 64
; ZVFHMIN64-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 3
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vs8r.v v16, (a0)
; ZVFHMIN64-NEXT:    addi a0, a0, -2
; ZVFHMIN64-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -80
; ZVFHMIN64-NEXT:    lw ra, 76(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 72(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 80
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv32f16_offset_negone:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -80
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN32-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 80
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 4
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -64
; ZVFHMIN32-NEXT:    addi a0, sp, 64
; ZVFHMIN32-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 3
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vs8r.v v16, (a0)
; ZVFHMIN32-NEXT:    addi a0, a0, -2
; ZVFHMIN32-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -80
; ZVFHMIN32-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 80
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv32f16_offset_negone:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 2
; ZVFH32-NEXT:    addi a0, a0, -1
; ZVFH32-NEXT:    vsetivli zero, 1, e16, m8, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vsetvli a0, zero, e16, m8, ta, ma
; ZVFH32-NEXT:    vslideup.vi v8, v16, 1
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv32f16_offset_negone:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 2
; ZVFH64-NEXT:    addi a0, a0, -1
; ZVFH64-NEXT:    vsetivli zero, 1, e16, m8, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vsetvli a0, zero, e16, m8, ta, ma
; ZVFH64-NEXT:    vslideup.vi v8, v16, 1
; ZVFH64-NEXT:    ret
  %res = call <vscale x 32 x half> @llvm.vector.splice.nxv32f16(<vscale x 32 x half> %a, <vscale x 32 x half> %b, i32 -1)
  ret <vscale x 32 x half> %res
}

define <vscale x 32 x half> @splice_nxv32f16_offset_min(<vscale x 32 x half> %a, <vscale x 32 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv32f16_offset_min:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -80
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN64-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 80
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 4
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -64
; ZVFHMIN64-NEXT:    addi a0, sp, 64
; ZVFHMIN64-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a1, a1, 3
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    li a2, 128
; ZVFHMIN64-NEXT:    vs8r.v v16, (a0)
; ZVFHMIN64-NEXT:    bltu a1, a2, .LBB148_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 128
; ZVFHMIN64-NEXT:  .LBB148_2:
; ZVFHMIN64-NEXT:    sub a0, a0, a1
; ZVFHMIN64-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -80
; ZVFHMIN64-NEXT:    lw ra, 76(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 72(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 80
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv32f16_offset_min:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -80
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN32-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 80
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 4
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -64
; ZVFHMIN32-NEXT:    addi a0, sp, 64
; ZVFHMIN32-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a1, a1, 3
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    li a2, 128
; ZVFHMIN32-NEXT:    vs8r.v v16, (a0)
; ZVFHMIN32-NEXT:    bltu a1, a2, .LBB148_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 128
; ZVFHMIN32-NEXT:  .LBB148_2:
; ZVFHMIN32-NEXT:    sub a0, a0, a1
; ZVFHMIN32-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -80
; ZVFHMIN32-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 80
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv32f16_offset_min:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 2
; ZVFH32-NEXT:    addi a0, a0, -64
; ZVFH32-NEXT:    li a1, 64
; ZVFH32-NEXT:    vsetvli zero, a1, e16, m8, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH32-NEXT:    vsetvli a0, zero, e16, m8, ta, ma
; ZVFH32-NEXT:    vslideup.vx v8, v16, a1
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv32f16_offset_min:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 2
; ZVFH64-NEXT:    addi a0, a0, -64
; ZVFH64-NEXT:    li a1, 64
; ZVFH64-NEXT:    vsetvli zero, a1, e16, m8, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a0
; ZVFH64-NEXT:    vsetvli a0, zero, e16, m8, ta, ma
; ZVFH64-NEXT:    vslideup.vx v8, v16, a1
; ZVFH64-NEXT:    ret
  %res = call <vscale x 32 x half> @llvm.vector.splice.nxv32f16(<vscale x 32 x half> %a, <vscale x 32 x half> %b, i32 -64)
  ret <vscale x 32 x half> %res
}

define <vscale x 32 x half> @splice_nxv32f16_offset_max(<vscale x 32 x half> %a, <vscale x 32 x half> %b) #0 {
; ZVFHMIN64-LABEL: splice_nxv32f16_offset_max:
; ZVFHMIN64:       # %bb.0:
; ZVFHMIN64-NEXT:    addi sp, sp, -80
; ZVFHMIN64-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN64-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; ZVFHMIN64-NEXT:    .cfi_offset ra, -4
; ZVFHMIN64-NEXT:    .cfi_offset s0, -8
; ZVFHMIN64-NEXT:    addi s0, sp, 80
; ZVFHMIN64-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN64-NEXT:    csrr a0, vlenb
; ZVFHMIN64-NEXT:    slli a0, a0, 4
; ZVFHMIN64-NEXT:    sub sp, sp, a0
; ZVFHMIN64-NEXT:    andi sp, sp, -64
; ZVFHMIN64-NEXT:    addi a0, sp, 64
; ZVFHMIN64-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN64-NEXT:    csrr a1, vlenb
; ZVFHMIN64-NEXT:    slli a2, a1, 3
; ZVFHMIN64-NEXT:    add a2, a0, a2
; ZVFHMIN64-NEXT:    slli a1, a1, 2
; ZVFHMIN64-NEXT:    addi a1, a1, -1
; ZVFHMIN64-NEXT:    li a3, 63
; ZVFHMIN64-NEXT:    vs8r.v v16, (a2)
; ZVFHMIN64-NEXT:    bltu a1, a3, .LBB149_2
; ZVFHMIN64-NEXT:  # %bb.1:
; ZVFHMIN64-NEXT:    li a1, 63
; ZVFHMIN64-NEXT:  .LBB149_2:
; ZVFHMIN64-NEXT:    slli a1, a1, 1
; ZVFHMIN64-NEXT:    add a0, a0, a1
; ZVFHMIN64-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN64-NEXT:    addi sp, s0, -80
; ZVFHMIN64-NEXT:    lw ra, 76(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    lw s0, 72(sp) # 4-byte Folded Reload
; ZVFHMIN64-NEXT:    addi sp, sp, 80
; ZVFHMIN64-NEXT:    ret
;
; ZVFHMIN32-LABEL: splice_nxv32f16_offset_max:
; ZVFHMIN32:       # %bb.0:
; ZVFHMIN32-NEXT:    addi sp, sp, -80
; ZVFHMIN32-NEXT:    .cfi_def_cfa_offset 80
; ZVFHMIN32-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
; ZVFHMIN32-NEXT:    .cfi_offset ra, -8
; ZVFHMIN32-NEXT:    .cfi_offset s0, -16
; ZVFHMIN32-NEXT:    addi s0, sp, 80
; ZVFHMIN32-NEXT:    .cfi_def_cfa s0, 0
; ZVFHMIN32-NEXT:    csrr a0, vlenb
; ZVFHMIN32-NEXT:    slli a0, a0, 4
; ZVFHMIN32-NEXT:    sub sp, sp, a0
; ZVFHMIN32-NEXT:    andi sp, sp, -64
; ZVFHMIN32-NEXT:    addi a0, sp, 64
; ZVFHMIN32-NEXT:    vs8r.v v8, (a0)
; ZVFHMIN32-NEXT:    csrr a1, vlenb
; ZVFHMIN32-NEXT:    slli a2, a1, 3
; ZVFHMIN32-NEXT:    add a2, a0, a2
; ZVFHMIN32-NEXT:    slli a1, a1, 2
; ZVFHMIN32-NEXT:    addi a1, a1, -1
; ZVFHMIN32-NEXT:    li a3, 63
; ZVFHMIN32-NEXT:    vs8r.v v16, (a2)
; ZVFHMIN32-NEXT:    bltu a1, a3, .LBB149_2
; ZVFHMIN32-NEXT:  # %bb.1:
; ZVFHMIN32-NEXT:    li a1, 63
; ZVFHMIN32-NEXT:  .LBB149_2:
; ZVFHMIN32-NEXT:    slli a1, a1, 1
; ZVFHMIN32-NEXT:    add a0, a0, a1
; ZVFHMIN32-NEXT:    vl8re16.v v8, (a0)
; ZVFHMIN32-NEXT:    addi sp, s0, -80
; ZVFHMIN32-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
; ZVFHMIN32-NEXT:    addi sp, sp, 80
; ZVFHMIN32-NEXT:    ret
;
; ZVFH32-LABEL: splice_nxv32f16_offset_max:
; ZVFH32:       # %bb.0:
; ZVFH32-NEXT:    csrr a0, vlenb
; ZVFH32-NEXT:    slli a0, a0, 2
; ZVFH32-NEXT:    addi a0, a0, -63
; ZVFH32-NEXT:    li a1, 63
; ZVFH32-NEXT:    vsetvli zero, a0, e16, m8, ta, ma
; ZVFH32-NEXT:    vslidedown.vx v8, v8, a1
; ZVFH32-NEXT:    vsetvli a1, zero, e16, m8, ta, ma
; ZVFH32-NEXT:    vslideup.vx v8, v16, a0
; ZVFH32-NEXT:    ret
;
; ZVFH64-LABEL: splice_nxv32f16_offset_max:
; ZVFH64:       # %bb.0:
; ZVFH64-NEXT:    csrr a0, vlenb
; ZVFH64-NEXT:    slli a0, a0, 2
; ZVFH64-NEXT:    addi a0, a0, -63
; ZVFH64-NEXT:    li a1, 63
; ZVFH64-NEXT:    vsetvli zero, a0, e16, m8, ta, ma
; ZVFH64-NEXT:    vslidedown.vx v8, v8, a1
; ZVFH64-NEXT:    vsetvli a1, zero, e16, m8, ta, ma
; ZVFH64-NEXT:    vslideup.vx v8, v16, a0
; ZVFH64-NEXT:    ret
  %res = call <vscale x 32 x half> @llvm.vector.splice.nxv32f16(<vscale x 32 x half> %a, <vscale x 32 x half> %b, i32 63)
  ret <vscale x 32 x half> %res
}

declare <vscale x 1 x float> @llvm.vector.splice.nxv1f32(<vscale x 1 x float>, <vscale x 1 x float>, i32)

define <vscale x 1 x float> @splice_nxv1f32_offset_zero(<vscale x 1 x float> %a, <vscale x 1 x float> %b) #0 {
; CHECK-LABEL: splice_nxv1f32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x float> @llvm.vector.splice.nxv1f32(<vscale x 1 x float> %a, <vscale x 1 x float> %b, i32 0)
  ret <vscale x 1 x float> %res
}

define <vscale x 1 x float> @splice_nxv1f32_offset_negone(<vscale x 1 x float> %a, <vscale x 1 x float> %b) #0 {
; CHECK-LABEL: splice_nxv1f32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e32, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x float> @llvm.vector.splice.nxv1f32(<vscale x 1 x float> %a, <vscale x 1 x float> %b, i32 -1)
  ret <vscale x 1 x float> %res
}

define <vscale x 1 x float> @splice_nxv1f32_offset_min(<vscale x 1 x float> %a, <vscale x 1 x float> %b) #0 {
; CHECK-LABEL: splice_nxv1f32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vsetivli zero, 2, e32, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, mf2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 2
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x float> @llvm.vector.splice.nxv1f32(<vscale x 1 x float> %a, <vscale x 1 x float> %b, i32 -2)
  ret <vscale x 1 x float> %res
}

define <vscale x 1 x float> @splice_nxv1f32_offset_max(<vscale x 1 x float> %a, <vscale x 1 x float> %b) #0 {
; CHECK-LABEL: splice_nxv1f32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli zero, a0, e32, mf2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 1
; CHECK-NEXT:    vsetvli a1, zero, e32, mf2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x float> @llvm.vector.splice.nxv1f32(<vscale x 1 x float> %a, <vscale x 1 x float> %b, i32 1)
  ret <vscale x 1 x float> %res
}

declare <vscale x 2 x float> @llvm.vector.splice.nxv2f32(<vscale x 2 x float>, <vscale x 2 x float>, i32)

define <vscale x 2 x float> @splice_nxv2f32_offset_zero(<vscale x 2 x float> %a, <vscale x 2 x float> %b) #0 {
; CHECK-LABEL: splice_nxv2f32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x float> @llvm.vector.splice.nxv2f32(<vscale x 2 x float> %a, <vscale x 2 x float> %b, i32 0)
  ret <vscale x 2 x float> %res
}

define <vscale x 2 x float> @splice_nxv2f32_offset_negone(<vscale x 2 x float> %a, <vscale x 2 x float> %b) #0 {
; CHECK-LABEL: splice_nxv2f32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e32, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x float> @llvm.vector.splice.nxv2f32(<vscale x 2 x float> %a, <vscale x 2 x float> %b, i32 -1)
  ret <vscale x 2 x float> %res
}

define <vscale x 2 x float> @splice_nxv2f32_offset_min(<vscale x 2 x float> %a, <vscale x 2 x float> %b) #0 {
; CHECK-LABEL: splice_nxv2f32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -4
; CHECK-NEXT:    vsetivli zero, 4, e32, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m1, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 4
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x float> @llvm.vector.splice.nxv2f32(<vscale x 2 x float> %a, <vscale x 2 x float> %b, i32 -4)
  ret <vscale x 2 x float> %res
}

define <vscale x 2 x float> @splice_nxv2f32_offset_max(<vscale x 2 x float> %a, <vscale x 2 x float> %b) #0 {
; CHECK-LABEL: splice_nxv2f32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -3
; CHECK-NEXT:    vsetvli zero, a0, e32, m1, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 3
; CHECK-NEXT:    vsetvli a1, zero, e32, m1, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x float> @llvm.vector.splice.nxv2f32(<vscale x 2 x float> %a, <vscale x 2 x float> %b, i32 3)
  ret <vscale x 2 x float> %res
}

declare <vscale x 4 x float> @llvm.vector.splice.nxv4f32(<vscale x 4 x float>, <vscale x 4 x float>, i32)

define <vscale x 4 x float> @splice_nxv4f32_offset_zero(<vscale x 4 x float> %a, <vscale x 4 x float> %b) #0 {
; CHECK-LABEL: splice_nxv4f32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x float> @llvm.vector.splice.nxv4f32(<vscale x 4 x float> %a, <vscale x 4 x float> %b, i32 0)
  ret <vscale x 4 x float> %res
}

define <vscale x 4 x float> @splice_nxv4f32_offset_negone(<vscale x 4 x float> %a, <vscale x 4 x float> %b) #0 {
; CHECK-LABEL: splice_nxv4f32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e32, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x float> @llvm.vector.splice.nxv4f32(<vscale x 4 x float> %a, <vscale x 4 x float> %b, i32 -1)
  ret <vscale x 4 x float> %res
}

define <vscale x 4 x float> @splice_nxv4f32_offset_min(<vscale x 4 x float> %a, <vscale x 4 x float> %b) #0 {
; CHECK-LABEL: splice_nxv4f32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -8
; CHECK-NEXT:    vsetivli zero, 8, e32, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 8
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x float> @llvm.vector.splice.nxv4f32(<vscale x 4 x float> %a, <vscale x 4 x float> %b, i32 -8)
  ret <vscale x 4 x float> %res
}

define <vscale x 4 x float> @splice_nxv4f32_offset_max(<vscale x 4 x float> %a, <vscale x 4 x float> %b) #0 {
; CHECK-LABEL: splice_nxv4f32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -7
; CHECK-NEXT:    vsetvli zero, a0, e32, m2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 7
; CHECK-NEXT:    vsetvli a1, zero, e32, m2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v10, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x float> @llvm.vector.splice.nxv4f32(<vscale x 4 x float> %a, <vscale x 4 x float> %b, i32 7)
  ret <vscale x 4 x float> %res
}

declare <vscale x 8 x float> @llvm.vector.splice.nxv8f32(<vscale x 8 x float>, <vscale x 8 x float>, i32)

define <vscale x 8 x float> @splice_nxv8f32_offset_zero(<vscale x 8 x float> %a, <vscale x 8 x float> %b) #0 {
; CHECK-LABEL: splice_nxv8f32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x float> @llvm.vector.splice.nxv8f32(<vscale x 8 x float> %a, <vscale x 8 x float> %b, i32 0)
  ret <vscale x 8 x float> %res
}

define <vscale x 8 x float> @splice_nxv8f32_offset_negone(<vscale x 8 x float> %a, <vscale x 8 x float> %b) #0 {
; CHECK-LABEL: splice_nxv8f32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e32, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x float> @llvm.vector.splice.nxv8f32(<vscale x 8 x float> %a, <vscale x 8 x float> %b, i32 -1)
  ret <vscale x 8 x float> %res
}

define <vscale x 8 x float> @splice_nxv8f32_offset_min(<vscale x 8 x float> %a, <vscale x 8 x float> %b) #0 {
; CHECK-LABEL: splice_nxv8f32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -16
; CHECK-NEXT:    vsetivli zero, 16, e32, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x float> @llvm.vector.splice.nxv8f32(<vscale x 8 x float> %a, <vscale x 8 x float> %b, i32 -16)
  ret <vscale x 8 x float> %res
}

define <vscale x 8 x float> @splice_nxv8f32_offset_max(<vscale x 8 x float> %a, <vscale x 8 x float> %b) #0 {
; CHECK-LABEL: splice_nxv8f32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -15
; CHECK-NEXT:    vsetvli zero, a0, e32, m4, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 15
; CHECK-NEXT:    vsetvli a1, zero, e32, m4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v12, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x float> @llvm.vector.splice.nxv8f32(<vscale x 8 x float> %a, <vscale x 8 x float> %b, i32 15)
  ret <vscale x 8 x float> %res
}

declare <vscale x 16 x float> @llvm.vector.splice.nxv16f32(<vscale x 16 x float>, <vscale x 16 x float>, i32)

define <vscale x 16 x float> @splice_nxv16f32_offset_zero(<vscale x 16 x float> %a, <vscale x 16 x float> %b) #0 {
; CHECK-LABEL: splice_nxv16f32_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x float> @llvm.vector.splice.nxv16f32(<vscale x 16 x float> %a, <vscale x 16 x float> %b, i32 0)
  ret <vscale x 16 x float> %res
}

define <vscale x 16 x float> @splice_nxv16f32_offset_negone(<vscale x 16 x float> %a, <vscale x 16 x float> %b) #0 {
; CHECK-LABEL: splice_nxv16f32_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e32, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m8, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v16, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x float> @llvm.vector.splice.nxv16f32(<vscale x 16 x float> %a, <vscale x 16 x float> %b, i32 -1)
  ret <vscale x 16 x float> %res
}

define <vscale x 16 x float> @splice_nxv16f32_offset_min(<vscale x 16 x float> %a, <vscale x 16 x float> %b) #0 {
; CHECK-LABEL: splice_nxv16f32_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -32
; CHECK-NEXT:    li a1, 32
; CHECK-NEXT:    vsetvli zero, a1, e32, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e32, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a1
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x float> @llvm.vector.splice.nxv16f32(<vscale x 16 x float> %a, <vscale x 16 x float> %b, i32 -32)
  ret <vscale x 16 x float> %res
}

define <vscale x 16 x float> @splice_nxv16f32_offset_max(<vscale x 16 x float> %a, <vscale x 16 x float> %b) #0 {
; CHECK-LABEL: splice_nxv16f32_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    slli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -31
; CHECK-NEXT:    vsetvli zero, a0, e32, m8, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 31
; CHECK-NEXT:    vsetvli a1, zero, e32, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 16 x float> @llvm.vector.splice.nxv16f32(<vscale x 16 x float> %a, <vscale x 16 x float> %b, i32 31)
  ret <vscale x 16 x float> %res
}

declare <vscale x 1 x double> @llvm.vector.splice.nxv1f64(<vscale x 1 x double>, <vscale x 1 x double>, i32)

define <vscale x 1 x double> @splice_nxv1f64_offset_zero(<vscale x 1 x double> %a, <vscale x 1 x double> %b) #0 {
; CHECK-LABEL: splice_nxv1f64_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x double> @llvm.vector.splice.nxv1f64(<vscale x 1 x double> %a, <vscale x 1 x double> %b, i32 0)
  ret <vscale x 1 x double> %res
}

define <vscale x 1 x double> @splice_nxv1f64_offset_negone(<vscale x 1 x double> %a, <vscale x 1 x double> %b) #0 {
; CHECK-LABEL: splice_nxv1f64_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli a1, zero, e64, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vslideup.vi v8, v9, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x double> @llvm.vector.splice.nxv1f64(<vscale x 1 x double> %a, <vscale x 1 x double> %b, i32 -1)
  ret <vscale x 1 x double> %res
}

define <vscale x 1 x double> @splice_nxv1f64_offset_min(<vscale x 1 x double> %a, <vscale x 1 x double> %b) #0 {
; CHECK-LABEL: splice_nxv1f64_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -2
; CHECK-NEXT:    vsetivli zero, 2, e64, m1, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m1, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v9, 2
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x double> @llvm.vector.splice.nxv1f64(<vscale x 1 x double> %a, <vscale x 1 x double> %b, i32 -2)
  ret <vscale x 1 x double> %res
}

define <vscale x 1 x double> @splice_nxv1f64_offset_max(<vscale x 1 x double> %a, <vscale x 1 x double> %b) #0 {
; CHECK-LABEL: splice_nxv1f64_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 3
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetvli zero, a0, e64, m1, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 1
; CHECK-NEXT:    vsetvli a1, zero, e64, m1, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v9, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 1 x double> @llvm.vector.splice.nxv1f64(<vscale x 1 x double> %a, <vscale x 1 x double> %b, i32 1)
  ret <vscale x 1 x double> %res
}

declare <vscale x 2 x double> @llvm.vector.splice.nxv2f64(<vscale x 2 x double>, <vscale x 2 x double>, i32)

define <vscale x 2 x double> @splice_nxv2f64_offset_zero(<vscale x 2 x double> %a, <vscale x 2 x double> %b) #0 {
; CHECK-LABEL: splice_nxv2f64_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x double> @llvm.vector.splice.nxv2f64(<vscale x 2 x double> %a, <vscale x 2 x double> %b, i32 0)
  ret <vscale x 2 x double> %res
}

define <vscale x 2 x double> @splice_nxv2f64_offset_negone(<vscale x 2 x double> %a, <vscale x 2 x double> %b) #0 {
; CHECK-LABEL: splice_nxv2f64_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e64, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x double> @llvm.vector.splice.nxv2f64(<vscale x 2 x double> %a, <vscale x 2 x double> %b, i32 -1)
  ret <vscale x 2 x double> %res
}

define <vscale x 2 x double> @splice_nxv2f64_offset_min(<vscale x 2 x double> %a, <vscale x 2 x double> %b) #0 {
; CHECK-LABEL: splice_nxv2f64_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -4
; CHECK-NEXT:    vsetivli zero, 4, e64, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m2, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v10, 4
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x double> @llvm.vector.splice.nxv2f64(<vscale x 2 x double> %a, <vscale x 2 x double> %b, i32 -4)
  ret <vscale x 2 x double> %res
}

define <vscale x 2 x double> @splice_nxv2f64_offset_max(<vscale x 2 x double> %a, <vscale x 2 x double> %b) #0 {
; CHECK-LABEL: splice_nxv2f64_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 2
; CHECK-NEXT:    addi a0, a0, -3
; CHECK-NEXT:    vsetvli zero, a0, e64, m2, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 3
; CHECK-NEXT:    vsetvli a1, zero, e64, m2, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v10, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 2 x double> @llvm.vector.splice.nxv2f64(<vscale x 2 x double> %a, <vscale x 2 x double> %b, i32 3)
  ret <vscale x 2 x double> %res
}

declare <vscale x 4 x double> @llvm.vector.splice.nxv4f64(<vscale x 4 x double>, <vscale x 4 x double>, i32)

define <vscale x 4 x double> @splice_nxv4f64_offset_zero(<vscale x 4 x double> %a, <vscale x 4 x double> %b) #0 {
; CHECK-LABEL: splice_nxv4f64_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x double> @llvm.vector.splice.nxv4f64(<vscale x 4 x double> %a, <vscale x 4 x double> %b, i32 0)
  ret <vscale x 4 x double> %res
}

define <vscale x 4 x double> @splice_nxv4f64_offset_negone(<vscale x 4 x double> %a, <vscale x 4 x double> %b) #0 {
; CHECK-LABEL: splice_nxv4f64_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e64, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x double> @llvm.vector.splice.nxv4f64(<vscale x 4 x double> %a, <vscale x 4 x double> %b, i32 -1)
  ret <vscale x 4 x double> %res
}

define <vscale x 4 x double> @splice_nxv4f64_offset_min(<vscale x 4 x double> %a, <vscale x 4 x double> %b) #0 {
; CHECK-LABEL: splice_nxv4f64_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -8
; CHECK-NEXT:    vsetivli zero, 8, e64, m4, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m4, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v12, 8
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x double> @llvm.vector.splice.nxv4f64(<vscale x 4 x double> %a, <vscale x 4 x double> %b, i32 -8)
  ret <vscale x 4 x double> %res
}

define <vscale x 4 x double> @splice_nxv4f64_offset_max(<vscale x 4 x double> %a, <vscale x 4 x double> %b) #0 {
; CHECK-LABEL: splice_nxv4f64_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    addi a0, a0, -7
; CHECK-NEXT:    vsetvli zero, a0, e64, m4, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 7
; CHECK-NEXT:    vsetvli a1, zero, e64, m4, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v12, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 4 x double> @llvm.vector.splice.nxv4f64(<vscale x 4 x double> %a, <vscale x 4 x double> %b, i32 7)
  ret <vscale x 4 x double> %res
}

declare <vscale x 8 x double> @llvm.vector.splice.nxv8f64(<vscale x 8 x double>, <vscale x 8 x double>, i32)

define <vscale x 8 x double> @splice_nxv8f64_offset_zero(<vscale x 8 x double> %a, <vscale x 8 x double> %b) #0 {
; CHECK-LABEL: splice_nxv8f64_offset_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x double> @llvm.vector.splice.nxv8f64(<vscale x 8 x double> %a, <vscale x 8 x double> %b, i32 0)
  ret <vscale x 8 x double> %res
}

define <vscale x 8 x double> @splice_nxv8f64_offset_negone(<vscale x 8 x double> %a, <vscale x 8 x double> %b) #0 {
; CHECK-LABEL: splice_nxv8f64_offset_negone:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    vsetivli zero, 1, e64, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m8, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v16, 1
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x double> @llvm.vector.splice.nxv8f64(<vscale x 8 x double> %a, <vscale x 8 x double> %b, i32 -1)
  ret <vscale x 8 x double> %res
}

define <vscale x 8 x double> @splice_nxv8f64_offset_min(<vscale x 8 x double> %a, <vscale x 8 x double> %b) #0 {
; CHECK-LABEL: splice_nxv8f64_offset_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -16
; CHECK-NEXT:    vsetivli zero, 16, e64, m8, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a0
; CHECK-NEXT:    vsetvli a0, zero, e64, m8, ta, ma
; CHECK-NEXT:    vslideup.vi v8, v16, 16
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x double> @llvm.vector.splice.nxv8f64(<vscale x 8 x double> %a, <vscale x 8 x double> %b, i32 -16)
  ret <vscale x 8 x double> %res
}

define <vscale x 8 x double> @splice_nxv8f64_offset_max(<vscale x 8 x double> %a, <vscale x 8 x double> %b) #0 {
; CHECK-LABEL: splice_nxv8f64_offset_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    addi a0, a0, -15
; CHECK-NEXT:    vsetvli zero, a0, e64, m8, ta, ma
; CHECK-NEXT:    vslidedown.vi v8, v8, 15
; CHECK-NEXT:    vsetvli a1, zero, e64, m8, ta, ma
; CHECK-NEXT:    vslideup.vx v8, v16, a0
; CHECK-NEXT:    ret
  %res = call <vscale x 8 x double> @llvm.vector.splice.nxv8f64(<vscale x 8 x double> %a, <vscale x 8 x double> %b, i32 15)
  ret <vscale x 8 x double> %res
}

attributes #0 = { vscale_range(2,0) }
