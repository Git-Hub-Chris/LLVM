; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=riscv64 -mattr=+m,+v -verify-machineinstrs < %s | FileCheck %s

; Test that we hoist the vid.v out of the loop by not using the EVL for AVL.

define void @reverse(ptr %p) {
; CHECK-LABEL: reverse:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    li a1, 0
; CHECK-NEXT:    li a2, 1024
; CHECK-NEXT:    vsetvli a3, zero, e64, m1, ta, ma
; CHECK-NEXT:    vid.v v8
; CHECK-NEXT:  .LBB0_1: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sub a3, a2, a1
; CHECK-NEXT:    slli a4, a1, 3
; CHECK-NEXT:    vsetvli a3, a3, e64, m1, ta, ma
; CHECK-NEXT:    add a4, a0, a4
; CHECK-NEXT:    vle64.v v9, (a4)
; CHECK-NEXT:    addi a5, a3, -1
; CHECK-NEXT:    vrsub.vx v10, v8, a5
; CHECK-NEXT:    vrgather.vv v11, v9, v10
; CHECK-NEXT:    add a1, a1, a3
; CHECK-NEXT:    vse64.v v11, (a4)
; CHECK-NEXT:    bltu a1, a2, .LBB0_1
; CHECK-NEXT:  # %bb.2: # %exit
; CHECK-NEXT:    ret
entry:
  br label %loop
loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]

  %cnt = sub i64 1024, %iv
  %evl = call i32 @llvm.experimental.get.vector.length(i64 %cnt, i32 1, i1 true)

  %p.gep = getelementptr i64, ptr %p, i64 %iv
  %v = call <vscale x 1 x i64> @llvm.vp.load(ptr %p.gep, <vscale x 1 x i1> splat (i1 true), i32 %evl)

  %w = call <vscale x 1 x i64> @llvm.experimental.vp.reverse(<vscale x 1 x i64> %v, <vscale x 1 x i1> splat (i1 true), i32 %evl)

  call void @llvm.vp.store(<vscale x 1 x i64> %w, ptr %p.gep, <vscale x 1 x i1> splat (i1 true), i32 %evl)

  %evl.zext = zext i32 %evl to i64
  %iv.next = add i64 %iv, %evl.zext
  %done = icmp uge i64 %iv.next, 1024
  br i1 %done, label %exit, label %loop

exit:
  ret void
}
