# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 4
# RUN: llc %s -mtriple=riscv64 -run-pass=greedy,virtregrewriter,stack-slot-coloring -o - | FileCheck %s

--- |
  define void @foo() {
  entry:
    ; Dummy test just to hold the alloca
    %alpha = alloca i32, i32 0, align 4
    ret void
  }

...
---
name:            foo
alignment:       4
tracksRegLiveness: true
frameInfo:
  maxAlignment:    4
  localFrameSize:  4
stack:
  - { id: 0, name: alpha, size: 1, alignment: 4, local-offset: -4 }
machineFunctionInfo:
  varArgsFrameIndex: 0
  varArgsSaveSize: 0
body:             |
  bb.0.entry:
    ; To trick stack-slot-colouring to run its dead-store-elimination phase,
    ; which is at fault, we need the register allocator to run, and spill in two
    ; places that can have their slots merged. Achieve this by volatile-loading
    ; data into all allocatable GPRs except $x31. Then, volatile storing them
    ; later, leaving regalloc only $x31 to play with in the middle.
    $x1 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x5 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x6 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x7 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x8 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x9 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x10 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x11 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x12 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x13 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x14 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x15 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x16 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x17 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x18 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x19 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x20 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x21 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x22 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x23 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x24 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x25 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x26 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x27 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x28 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x29 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    $x30 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)

    ; Force the first spill.
    %0:gpr = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    %1:gpr = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    SW %1, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW %0, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)

    ; CHECK: renamable $x31 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    ; CHECK-NEXT: SD killed renamable $x31, %stack.1, 0 :: (store (s64) into %stack.1)
    ; CHECK-NEXT: renamable $x31 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    ; CHECK-NEXT: SW killed renamable $x31, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    ; CHECK-NEXT: renamable $x31 = LD %stack.1, 0 :: (load (s64) from %stack.1)
    ; CHECK-NEXT: SW killed renamable $x31, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)

    ; stack-slot-coloring doesn't know that a write to $x0 is discarded.
    dead $x0 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    ; This stores 0 rather than the result of the preceding load since $x0
    ; is special.
    ; We don't want this store to be deleted.
    SW $x0, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)

    ; CHECK-NEXT: dead $x0 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    ; CHECK-NEXT: SW $x0, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)

    ; Force a second spill
    %2:gpr = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    %3:gpr = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    SW %3, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW %2, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)

    ; CHECK-NEXT: renamable $x31 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    ; CHECK-NEXT: SD killed renamable $x31, %stack.1, 0 :: (store (s64) into %stack.1)
    ; CHECK-NEXT: renamable $x31 = LW %stack.0.alpha, 0 :: (volatile load (s32) from %ir.alpha)
    ; CHECK-NEXT: SW killed renamable $x31, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    ; CHECK-NEXT: renamable $x31 = LD %stack.1, 0 :: (load (s64) from %stack.1)
    ; CHECK-NEXT: SW killed renamable $x31, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)

    SW $x1, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x5, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x6, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x7, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x8, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x9, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x10, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x11, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x12, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x13, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x14, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x15, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x16, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x17, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x18, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x19, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x20, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x21, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x22, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x23, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x24, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x25, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x26, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x27, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x28, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x29, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    SW $x30, %stack.0.alpha, 0 :: (volatile store (s32) into %ir.alpha)
    PseudoRET

...
