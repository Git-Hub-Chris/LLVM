; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --default-march x86_64-unknown-linux-gnu --version 5
; RUN: llc --mcpu=sapphirerapids -mtriple=x86_64 < %s | FileCheck %s

define half @complex_canonicalize_fmul_half(half %a, half %b) {
; CHECK-LABEL: complex_canonicalize_fmul_half:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT: 	vsubsh	%xmm1, %xmm0, %xmm0
; CHECK-NEXT: 	vaddsh	%xmm1, %xmm0, %xmm2
; CHECK-NEXT: 	vsubsh	%xmm0, %xmm2, %xmm0
; CHECK-NEXT: 	vsubsh	%xmm1, %xmm0, %xmm0
; CHECK-NEXT: 	retq
entry:

  %mul1 = fsub half %a, %b
  %add = fadd half %mul1, %b
  %mul2 = fsub half %add, %mul1
  %canonicalized = call half @llvm.canonicalize.f16(half %mul2)
  %result = fsub half %canonicalized, %b
  ret half %result
}

define x86_fp80 @complex_canonicalize_fmul_x86_fp80(x86_fp80 %a, x86_fp80 %b) {
entry:
  ; CHECK-LABEL: complex_canonicalize_fmul_x86_fp80
  ; CHECK: # %bb.0:
  ; CHECK-NEXT: 	fldt	24(%rsp)
  ; CHECK-NEXT: 	fldt	8(%rsp)
  ; CHECK-NEXT: 	fsub	%st(1), %st
  ; CHECK-NEXT: 	fld	%st(0)
  ; CHECK-NEXT: 	fadd	%st(2), %st
  ; CHECK-NEXT: 	fsubp	%st, %st(1)
  ; CHECK-NEXT: 	fsubp	%st, %st(1)
  ; CHECK-NEXT: 	retq

  %mul1 = fsub x86_fp80 %a, %b
  %add = fadd x86_fp80 %mul1, %b
  %mul2 = fsub x86_fp80 %add, %mul1
  %canonicalized = call x86_fp80 @llvm.canonicalize.f80(x86_fp80 %mul2)
  %result = fsub x86_fp80 %canonicalized, %b
  ret x86_fp80 %result
}

define bfloat @complex_canonicalize_fmul_bfloat(bfloat %a, bfloat %b) {
; CHECK-LABEL: complex_canonicalize_fmul_bfloat:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT: 	vmovw	%xmm0, %eax
; CHECK-NEXT: 	vmovw	%xmm1, %ecx
; CHECK-NEXT: 	shll	$16, %ecx
; CHECK-NEXT: 	vmovd	%ecx, %xmm0
; CHECK-NEXT: 	shll	$16, %eax
; CHECK-NEXT: 	vmovd	%eax, %xmm1
; CHECK-NEXT: 	vsubss	%xmm0, %xmm1, %xmm1
; CHECK-NEXT: 	vcvtneps2bf16	%xmm1, %xmm1
; CHECK-NEXT: 	vmovw	%xmm1, %eax
; CHECK-NEXT: 	shll	$16, %eax
; CHECK-NEXT: 	vmovd	%eax, %xmm1
; CHECK-NEXT: 	vaddss	%xmm0, %xmm1, %xmm2
; CHECK-NEXT: 	vcvtneps2bf16	%xmm2, %xmm2
; CHECK-NEXT: 	vmovw	%xmm2, %eax
; CHECK-NEXT: 	shll	$16, %eax
; CHECK-NEXT: 	vmovd	%eax, %xmm2
; CHECK-NEXT: 	vsubss	%xmm1, %xmm2, %xmm1
; CHECK-NEXT: 	vcvtneps2bf16	%xmm1, %xmm1
; CHECK-NEXT: 	vmovw	%xmm1, %eax
; CHECK-NEXT: 	shll	$16, %eax
; CHECK-NEXT: 	vmovd	%eax, %xmm1
; CHECK-NEXT: 	vcvtneps2bf16	%xmm1, %xmm1
; CHECK-NEXT: 	vmovw	%xmm1, %eax
; CHECK-NEXT: 	shll	$16, %eax
; CHECK-NEXT: 	vmovd	%eax, %xmm1
; CHECK-NEXT: 	vsubss	%xmm0, %xmm1, %xmm0
; CHECK-NEXT: 	vcvtneps2bf16	%xmm0, %xmm0
; CHECK-NEXT: 	vmovw	%xmm0, %eax
; CHECK-NEXT: 	vmovw	%eax, %xmm0
; CHECK-NEXT: 	retq

entry:

  %sub1 = fsub bfloat %a, %b
  %add = fadd bfloat %sub1, %b
  %sub2 = fsub bfloat %add, %sub1
  %canonicalized = call bfloat @llvm.canonicalize.bf16(bfloat %sub2)
  %result = fsub bfloat %canonicalized, %b
  ret bfloat %result
}

define double @canonicalize_fp64(double %a, double %b) unnamed_addr #0 {
start:
  ; CHECK-LABEL: canonicalize_fp64:
  ; CHECK: # %bb.0:
  ; CHECK-NEXT: 	vmaxsd	%xmm0, %xmm1, %xmm2
  ; CHECK-NEXT: 	vcmpunordsd	%xmm0, %xmm0, %k1
  ; CHECK-NEXT: 	vmovsd	%xmm1, %xmm2, %xmm2 {%k1}
  ; CHECK-NEXT: 	vmovapd	%xmm2, %xmm0
  ; CHECK-NEXT: 	retq

  %c = fcmp olt double %a, %b
  %d = fcmp uno double %a, 0.000000e+00
  %or.cond.i.i = or i1 %d, %c
  %e = select i1 %or.cond.i.i, double %b, double %a
  %f = tail call double @llvm.canonicalize.f64(double %e) #2
  ret double %f
}

define float @canonicalize_fp32(float %aa, float %bb) unnamed_addr #0 {
start:
  ; CHECK-LABEL: canonicalize_fp32:
  ; CHECK: # %bb.0:
  ; CHECK-NEXT: vmaxss %xmm0, %xmm1, %xmm2
  ; CHECK-NEXT: vcmpunordss %xmm0, %xmm0, %k1
  ; CHECK-NEXT: vmovss %xmm1, %xmm2, %xmm2 {%k1}
  ; CHECK-NEXT: vmovaps %xmm2, %xmm0
  ; CHECK-NEXT: retq

  %cc = fcmp olt float %aa, %bb
  %dd = fcmp uno float %aa, 0.000000e+00
  %or.cond.i.i.x = or i1 %dd, %cc
  %ee = select i1 %or.cond.i.i.x, float %bb, float %aa
  %ff = tail call float @llvm.canonicalize.f32(float %ee) #2
  ret float %ff
}

define void @v_test_canonicalize_var_f32(float addrspace(1)* %out) #1 {
  ; CHECK-LAEBL: v_test_canonicalize_var_f32
  ; CHECK: # %bb.0:
  ; CHECK-NEXT: vmovss	(%rdi), %xmm0                   
	; CHECK-NEXT: vmovss	%xmm0, (%rdi)
	; CHECK-NEXT: retq
  %val = load float, float addrspace(1)* %out
  %canonicalized = call float @llvm.canonicalize.f32(float %val)
  store float %canonicalized, float addrspace(1)* %out
  ret void
}

define void @v_test_canonicalize_x86_fp80(x86_fp80 addrspace(1)* %out) #1 {
  ; CHECK-LAEBL: v_test_canonicalize_x86_fp80
  ; CHECK: # %bb.0:
  ; CHECK-NEXT: fldt	(%rdi)
	; CHECK-NEXT: fstpt	(%rdi)
	; CHECK-NEXT: retq
  %val = load x86_fp80, x86_fp80 addrspace(1)* %out
  %canonicalized = call x86_fp80 @llvm.canonicalize.f80(x86_fp80 %val)
  store x86_fp80 %canonicalized, x86_fp80 addrspace(1)* %out
  ret void
}

define void @v_test_canonicalize__half(half addrspace(1)* %out) {
; CHECK-LABEL: v_test_canonicalize__half:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT: 	vmovsh	(%rdi), %xmm0                   # xmm0 = mem[0],zero,zero,zero,zero,zero,zero,zero
; CHECK-NEXT: 	vmovsh	%xmm0, (%rdi)
; CHECK-NEXT: 	retq
entry:
  %val = load half, half addrspace(1)* %out
  %canonicalized = call half @llvm.canonicalize.f16(half %val)
  store half %canonicalized, half addrspace(1)* %out
  ret void
}

define void @v_test_canonicalize_var_f64(double addrspace(1)* %out) #1 {
  ; CHECK-LAEBL: v_test_canonicalize_var_f64
  ; CHECK: # %bb.0:
  ; CHECK-NEXT: vmovsd	(%rdi), %xmm0                   # xmm0 = mem[0],zero                   
	; CHECK-NEXT: vmovsd	%xmm0, (%rdi)
	; CHECK-NEXT: retq
  %val = load double, double addrspace(1)* %out
  %canonicalized = call double @llvm.canonicalize.f64(double %val)
  store double %canonicalized, double addrspace(1)* %out
  ret void
}

define void @v_test_canonicalize__bfloat(bfloat addrspace(1)* %out) {
; CHECK-LABEL: v_test_canonicalize__bfloat:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT: 	movzwl	(%rdi), %eax
; CHECK-NEXT: 	shll	$16, %eax
; CHECK-NEXT: 	vmovd	%eax, %xmm0
; CHECK-NEXT: 	vcvtneps2bf16	%xmm0, %xmm0
; CHECK-NEXT: 	vpextrw	$0, %xmm0, (%rdi)
; CHECK-NEXT: 	retq

entry:
  %val = load bfloat, bfloat addrspace(1)* %out
  %canonicalized = call bfloat @llvm.canonicalize.bf16(bfloat %val)
  store bfloat %canonicalized, bfloat addrspace(1)* %out
  ret void
}

declare double @llvm.canonicalize.f64(double)
declare float @llvm.canonicalize.f32(float)
declare bfloat @llvm.canonicalize.bf16(bfloat)
declare x86_fp80 @llvm.canonicalize.f80(x86_fp80)
declare half @llvm.canonicalize.f16(half)