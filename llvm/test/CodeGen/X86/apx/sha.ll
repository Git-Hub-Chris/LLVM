; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc < %s -mattr=+sha,+egpr -mtriple=x86_64-unknown-unknown --show-mc-encoding | FileCheck %s

declare <4 x i32> @llvm.x86.sha1rnds4(<4 x i32>, <4 x i32>, i8) nounwind readnone

define <4 x i32> @test_sha1rnds4rr(<4 x i32> %a, <4 x i32> %b) nounwind uwtable {
; CHECK-LABEL: test_sha1rnds4rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha1rnds4 $3, %xmm1, %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xd4,0xc1,0x03]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = tail call <4 x i32> @llvm.x86.sha1rnds4(<4 x i32> %a, <4 x i32> %b, i8 3)
  ret <4 x i32> %0
}

define <4 x i32> @test_sha1rnds4rm(<4 x i32> %a, ptr %b) nounwind uwtable {
; CHECK-LABEL: test_sha1rnds4rm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha1rnds4 $3, (%rdi), %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xd4,0x07,0x03]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = load <4 x i32>, ptr %b
  %1 = tail call <4 x i32> @llvm.x86.sha1rnds4(<4 x i32> %a, <4 x i32> %0, i8 3)
  ret <4 x i32> %1
}

declare <4 x i32> @llvm.x86.sha1nexte(<4 x i32>, <4 x i32>) nounwind readnone

define <4 x i32> @test_sha1nexterr(<4 x i32> %a, <4 x i32> %b) nounwind uwtable {
; CHECK-LABEL: test_sha1nexterr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha1nexte %xmm1, %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xd8,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = tail call <4 x i32> @llvm.x86.sha1nexte(<4 x i32> %a, <4 x i32> %b)
  ret <4 x i32> %0
}

define <4 x i32> @test_sha1nexterm(<4 x i32> %a, ptr %b) nounwind uwtable {
; CHECK-LABEL: test_sha1nexterm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha1nexte (%rdi), %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xd8,0x07]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = load <4 x i32>, ptr %b
  %1 = tail call <4 x i32> @llvm.x86.sha1nexte(<4 x i32> %a, <4 x i32> %0)
  ret <4 x i32> %1
}

declare <4 x i32> @llvm.x86.sha1msg1(<4 x i32>, <4 x i32>) nounwind readnone

define <4 x i32> @test_sha1msg1rr(<4 x i32> %a, <4 x i32> %b) nounwind uwtable {
; CHECK-LABEL: test_sha1msg1rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha1msg1 %xmm1, %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xd9,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = tail call <4 x i32> @llvm.x86.sha1msg1(<4 x i32> %a, <4 x i32> %b)
  ret <4 x i32> %0
}

define <4 x i32> @test_sha1msg1rm(<4 x i32> %a, ptr %b) nounwind uwtable {
; CHECK-LABEL: test_sha1msg1rm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha1msg1 (%rdi), %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xd9,0x07]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = load <4 x i32>, ptr %b
  %1 = tail call <4 x i32> @llvm.x86.sha1msg1(<4 x i32> %a, <4 x i32> %0)
  ret <4 x i32> %1
}

declare <4 x i32> @llvm.x86.sha1msg2(<4 x i32>, <4 x i32>) nounwind readnone

define <4 x i32> @test_sha1msg2rr(<4 x i32> %a, <4 x i32> %b) nounwind uwtable {
; CHECK-LABEL: test_sha1msg2rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha1msg2 %xmm1, %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xda,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = tail call <4 x i32> @llvm.x86.sha1msg2(<4 x i32> %a, <4 x i32> %b)
  ret <4 x i32> %0
}

define <4 x i32> @test_sha1msg2rm(<4 x i32> %a, ptr %b) nounwind uwtable {
; CHECK-LABEL: test_sha1msg2rm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha1msg2 (%rdi), %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xda,0x07]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = load <4 x i32>, ptr %b
  %1 = tail call <4 x i32> @llvm.x86.sha1msg2(<4 x i32> %a, <4 x i32> %0)
  ret <4 x i32> %1
}

declare <4 x i32> @llvm.x86.sha256rnds2(<4 x i32>, <4 x i32>, <4 x i32>) nounwind readnone

define <4 x i32> @test_sha256rnds2rr(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c) nounwind uwtable {
;
; CHECK-LABEL: test_sha256rnds2rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movaps %xmm0, %xmm3 # encoding: [0x0f,0x28,0xd8]
; CHECK-NEXT:    movaps %xmm2, %xmm0 # encoding: [0x0f,0x28,0xc2]
; CHECK-NEXT:    sha256rnds2 %xmm0, %xmm1, %xmm3 # encoding: [0x62,0xf4,0x7c,0x08,0xdb,0xd9]
; CHECK-NEXT:    movaps %xmm3, %xmm0 # encoding: [0x0f,0x28,0xc3]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = tail call <4 x i32> @llvm.x86.sha256rnds2(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c)
  ret <4 x i32> %0
}

define <4 x i32> @test_sha256rnds2rm(<4 x i32> %a, ptr %b, <4 x i32> %c) nounwind uwtable {
;
; CHECK-LABEL: test_sha256rnds2rm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movaps %xmm0, %xmm2 # encoding: [0x0f,0x28,0xd0]
; CHECK-NEXT:    movaps %xmm1, %xmm0 # encoding: [0x0f,0x28,0xc1]
; CHECK-NEXT:    sha256rnds2 %xmm0, (%rdi), %xmm2 # encoding: [0x62,0xf4,0x7c,0x08,0xdb,0x17]
; CHECK-NEXT:    movaps %xmm2, %xmm0 # encoding: [0x0f,0x28,0xc2]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = load <4 x i32>, ptr %b
  %1 = tail call <4 x i32> @llvm.x86.sha256rnds2(<4 x i32> %a, <4 x i32> %0, <4 x i32> %c)
  ret <4 x i32> %1
}

declare <4 x i32> @llvm.x86.sha256msg1(<4 x i32>, <4 x i32>) nounwind readnone

define <4 x i32> @test_sha256msg1rr(<4 x i32> %a, <4 x i32> %b) nounwind uwtable {
; CHECK-LABEL: test_sha256msg1rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha256msg1 %xmm1, %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xdc,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = tail call <4 x i32> @llvm.x86.sha256msg1(<4 x i32> %a, <4 x i32> %b)
  ret <4 x i32> %0
}

define <4 x i32> @test_sha256msg1rm(<4 x i32> %a, ptr %b) nounwind uwtable {
; CHECK-LABEL: test_sha256msg1rm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha256msg1 (%rdi), %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xdc,0x07]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = load <4 x i32>, ptr %b
  %1 = tail call <4 x i32> @llvm.x86.sha256msg1(<4 x i32> %a, <4 x i32> %0)
  ret <4 x i32> %1
}

declare <4 x i32> @llvm.x86.sha256msg2(<4 x i32>, <4 x i32>) nounwind readnone

define <4 x i32> @test_sha256msg2rr(<4 x i32> %a, <4 x i32> %b) nounwind uwtable {
; CHECK-LABEL: test_sha256msg2rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha256msg2 %xmm1, %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xdd,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = tail call <4 x i32> @llvm.x86.sha256msg2(<4 x i32> %a, <4 x i32> %b)
  ret <4 x i32> %0
}

define <4 x i32> @test_sha256msg2rm(<4 x i32> %a, ptr %b) nounwind uwtable {
; CHECK-LABEL: test_sha256msg2rm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha256msg2 (%rdi), %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xdd,0x07]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = load <4 x i32>, ptr %b
  %1 = tail call <4 x i32> @llvm.x86.sha256msg2(<4 x i32> %a, <4 x i32> %0)
  ret <4 x i32> %1
}

; Make sure we don't forget that sha instructions have no VEX equivalents and thus don't zero YMM/ZMM.
define <8 x i32> @test_sha1rnds4_zero_extend(<4 x i32> %a, ptr %b) nounwind uwtable {
;
; CHECK-LABEL: test_sha1rnds4_zero_extend:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sha1rnds4 $3, (%rdi), %xmm0 # encoding: [0x62,0xf4,0x7c,0x08,0xd4,0x07,0x03]
; CHECK-NEXT:    xorps %xmm1, %xmm1 # encoding: [0x0f,0x57,0xc9]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = load <4 x i32>, ptr %b
  %1 = tail call <4 x i32> @llvm.x86.sha1rnds4(<4 x i32> %a, <4 x i32> %0, i8 3)
  %2 = shufflevector <4 x i32> %1, <4 x i32> zeroinitializer, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x i32> %2
}
