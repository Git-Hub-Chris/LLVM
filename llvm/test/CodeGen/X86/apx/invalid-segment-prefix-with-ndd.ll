; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+ndd -verify-machineinstrs --show-mc-encoding | FileCheck %s

@tm_nest_level = internal thread_local global i32 0
define i32 @add32mi_FS() nounwind {
; CHECK-LABEL: add32mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movl $123456, %ecx # encoding: [0xb9,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    addl %ecx, tm_nest_level@TPOFF(%rax), %eax # encoding: [0x62,0xf4,0x7c,0x18,0x01,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i32, ptr @tm_nest_level
  %add = add nsw i32 %t, 123456
  ret i32 %add
}

define i32 @add32mi_GS() {
; CHECK-LABEL: add32mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    addl %eax, %gs:255, %eax # encoding: [0x65,0x62,0xf4,0x7c,0x18,0x01,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i32 255 to ptr addrspace(256)
  %t = load i32, ptr addrspace(256) %a
  %add = add nsw i32 %t, 123456
  ret i32 %add
}

define i64 @add64mi_FS() nounwind {
; CHECK-LABEL: add64mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movl $123456, %ecx # encoding: [0xb9,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    addq %rcx, tm_nest_level@TPOFF(%rax), %rax # encoding: [0x62,0xf4,0xfc,0x18,0x01,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i64, ptr @tm_nest_level
  %add = add nsw i64 %t, 123456
  ret i64 %add
}

define i64 @add64mi_GS() {
; CHECK-LABEL: add64mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    addq %rax, %gs:255, %rax # encoding: [0x65,0x62,0xf4,0xfc,0x18,0x01,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i64 255 to ptr addrspace(256)
  %t = load i64, ptr addrspace(256) %a
  %add = add nsw i64 %t, 123456
  ret i64 %add
}

define i32 @sub32mi_FS() nounwind {
; CHECK-LABEL: sub32mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movl $-123456, %ecx # encoding: [0xb9,0xc0,0x1d,0xfe,0xff]
; CHECK-NEXT:    # imm = 0xFFFE1DC0
; CHECK-NEXT:    addl %ecx, tm_nest_level@TPOFF(%rax), %eax # encoding: [0x62,0xf4,0x7c,0x18,0x01,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i32, ptr @tm_nest_level
  %sub = sub nsw i32 %t, 123456
  ret i32 %sub
}

define i32 @sub32mi_GS() {
; CHECK-LABEL: sub32mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $-123456, %eax # encoding: [0xb8,0xc0,0x1d,0xfe,0xff]
; CHECK-NEXT:    # imm = 0xFFFE1DC0
; CHECK-NEXT:    addl %eax, %gs:255, %eax # encoding: [0x65,0x62,0xf4,0x7c,0x18,0x01,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i32 255 to ptr addrspace(256)
  %t = load i32, ptr addrspace(256) %a
  %sub = sub nsw i32 %t, 123456
  ret i32 %sub
}

define i64 @sub64mi_FS() nounwind {
; CHECK-LABEL: sub64mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movq $-123456, %rcx # encoding: [0x48,0xc7,0xc1,0xc0,0x1d,0xfe,0xff]
; CHECK-NEXT:    # imm = 0xFFFE1DC0
; CHECK-NEXT:    addq %rcx, tm_nest_level@TPOFF(%rax), %rax # encoding: [0x62,0xf4,0xfc,0x18,0x01,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i64, ptr @tm_nest_level
  %sub = sub nsw i64 %t, 123456
  ret i64 %sub
}

define i64 @sub64mi_GS() {
; CHECK-LABEL: sub64mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq $-123456, %rax # encoding: [0x48,0xc7,0xc0,0xc0,0x1d,0xfe,0xff]
; CHECK-NEXT:    # imm = 0xFFFE1DC0
; CHECK-NEXT:    addq %rax, %gs:255, %rax # encoding: [0x65,0x62,0xf4,0xfc,0x18,0x01,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i64 255 to ptr addrspace(256)
  %t = load i64, ptr addrspace(256) %a
  %sub = sub nsw i64 %t, 123456
  ret i64 %sub
}

define i32 @or32mi_FS() nounwind {
; CHECK-LABEL: or32mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movl $123456, %ecx # encoding: [0xb9,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    orl %ecx, tm_nest_level@TPOFF(%rax), %eax # encoding: [0x62,0xf4,0x7c,0x18,0x09,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i32, ptr @tm_nest_level
  %or = or i32 %t, 123456
  ret i32 %or
}

define i32 @or32mi_GS() {
; CHECK-LABEL: or32mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    orl %eax, %gs:255, %eax # encoding: [0x65,0x62,0xf4,0x7c,0x18,0x09,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i32 255 to ptr addrspace(256)
  %t = load i32, ptr addrspace(256) %a
  %or = or i32 %t, 123456
  ret i32 %or
}

define i64 @or64mi_FS() nounwind {
; CHECK-LABEL: or64mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movl $123456, %ecx # encoding: [0xb9,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    orq %rcx, tm_nest_level@TPOFF(%rax), %rax # encoding: [0x62,0xf4,0xfc,0x18,0x09,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i64, ptr @tm_nest_level
  %or = or i64 %t, 123456
  ret i64 %or
}

define i64 @or64mi_GS() {
; CHECK-LABEL: or64mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    orq %rax, %gs:255, %rax # encoding: [0x65,0x62,0xf4,0xfc,0x18,0x09,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i64 255 to ptr addrspace(256)
  %t = load i64, ptr addrspace(256) %a
  %or = or i64 %t, 123456
  ret i64 %or
}

define i32 @xor32mi_FS() nounwind {
; CHECK-LABEL: xor32mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movl $123456, %ecx # encoding: [0xb9,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    xorl %ecx, tm_nest_level@TPOFF(%rax), %eax # encoding: [0x62,0xf4,0x7c,0x18,0x31,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i32, ptr @tm_nest_level
  %xor = xor i32 %t, 123456
  ret i32 %xor
}

define i32 @xor32mi_GS() {
; CHECK-LABEL: xor32mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    xorl %eax, %gs:255, %eax # encoding: [0x65,0x62,0xf4,0x7c,0x18,0x31,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i32 255 to ptr addrspace(256)
  %t = load i32, ptr addrspace(256) %a
  %xor = xor i32 %t, 123456
  ret i32 %xor
}

define i64 @xor64mi_FS() nounwind {
; CHECK-LABEL: xor64mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movl $123456, %ecx # encoding: [0xb9,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    xorq %rcx, tm_nest_level@TPOFF(%rax), %rax # encoding: [0x62,0xf4,0xfc,0x18,0x31,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i64, ptr @tm_nest_level
  %xor = xor i64 %t, 123456
  ret i64 %xor
}

define i64 @xor64mi_GS() {
; CHECK-LABEL: xor64mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    xorq %rax, %gs:255, %rax # encoding: [0x65,0x62,0xf4,0xfc,0x18,0x31,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i64 255 to ptr addrspace(256)
  %t = load i64, ptr addrspace(256) %a
  %xor = xor i64 %t, 123456
  ret i64 %xor
}

define i32 @and32mi_FS() nounwind {
; CHECK-LABEL: and32mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movl $123456, %ecx # encoding: [0xb9,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    andl %ecx, tm_nest_level@TPOFF(%rax), %eax # encoding: [0x62,0xf4,0x7c,0x18,0x21,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i32, ptr @tm_nest_level
  %and = and i32 %t, 123456
  ret i32 %and
}

define i32 @and32mi_GS() {
; CHECK-LABEL: and32mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    andl %eax, %gs:255, %eax # encoding: [0x65,0x62,0xf4,0x7c,0x18,0x21,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i32 255 to ptr addrspace(256)
  %t = load i32, ptr addrspace(256) %a
  %and = and i32 %t, 123456
  ret i32 %and
}

define i64 @and64mi_FS() nounwind {
; CHECK-LABEL: and64mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    movq tm_nest_level@TPOFF(%rax), %rax # encoding: [0x48,0x8b,0x80,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 3, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    andl $123456, %eax, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x81,0xe0,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i64, ptr @tm_nest_level
  %and = and i64 %t, 123456
  ret i64 %and
}

define i64 @and64mi_GS() {
; CHECK-LABEL: and64mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq %gs:255, %rax # encoding: [0x65,0x48,0x8b,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    andl $123456, %eax, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x81,0xe0,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i64 255 to ptr addrspace(256)
  %t = load i64, ptr addrspace(256) %a
  %and = and i64 %t, 123456
  ret i64 %and
}

define i32 @adc32mi_FS(i32 %x, i32 %y) nounwind {
; CHECK-LABEL: adc32mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    subl %edi, %esi, %ecx # encoding: [0x62,0xf4,0x74,0x18,0x29,0xfe]
; CHECK-NEXT:    movl $123456, %ecx # encoding: [0xb9,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    adcl %ecx, tm_nest_level@TPOFF(%rax), %eax # encoding: [0x62,0xf4,0x7c,0x18,0x11,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i32, ptr @tm_nest_level
  %s = add i32 %t, 123456
  %k = icmp ugt i32 %x, %y
  %z = zext i1 %k to i32
  %r = add i32 %s, %z
  ret i32 %r
}

define i32 @adc32mi_GS(i32 %x, i32 %y) {
; CHECK-LABEL: adc32mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    subl %edi, %esi, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x29,0xfe]
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    adcl %eax, %gs:255, %eax # encoding: [0x65,0x62,0xf4,0x7c,0x18,0x11,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a = inttoptr i32 255 to ptr addrspace(256)
  %t = load i32, ptr addrspace(256) %a
  %s = add i32 %t, 123456
  %k = icmp ugt i32 %x, %y
  %z = zext i1 %k to i32
  %r = add i32 %s, %z
  ret i32 %r
}

define i64 @adc64mi_FS(i64 %x, i64 %y) nounwind {
; CHECK-LABEL: adc64mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    subq %rdi, %rsi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0x29,0xfe]
; CHECK-NEXT:    movl $123456, %ecx # encoding: [0xb9,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    adcq %rcx, tm_nest_level@TPOFF(%rax), %rax # encoding: [0x62,0xf4,0xfc,0x18,0x11,0x88,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i64, ptr @tm_nest_level
  %s = add i64 %t, 123456
  %k = icmp ugt i64 %x, %y
  %z = zext i1 %k to i64
  %r = add i64 %s, %z
  ret i64 %r
}

define i64 @adc64mi_GS(i64 %x, i64 %y) {
; CHECK-LABEL: adc64mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    subq %rdi, %rsi, %rax # encoding: [0x62,0xf4,0xfc,0x18,0x29,0xfe]
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    adcq %rax, %gs:255, %rax # encoding: [0x65,0x62,0xf4,0xfc,0x18,0x11,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a = inttoptr i64 255 to ptr addrspace(256)
  %t = load i64, ptr addrspace(256) %a
  %s = add i64 %t, 123456
  %k = icmp ugt i64 %x, %y
  %z = zext i1 %k to i64
  %r = add i64 %s, %z
  ret i64 %r
}

define i32 @sbb32mi_FS(i32 %x, i32 %y) nounwind {
; CHECK-LABEL: sbb32mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    subl %edi, %esi, %ecx # encoding: [0x62,0xf4,0x74,0x18,0x29,0xfe]
; CHECK-NEXT:    sbbl $0, tm_nest_level@TPOFF(%rax), %eax # encoding: [0x62,0xf4,0x7c,0x18,0x81,0x98,A,A,A,A,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    addl $-123456, %eax, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x81,0xc0,0xc0,0x1d,0xfe,0xff]
; CHECK-NEXT:    # imm = 0xFFFE1DC0
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i32, ptr @tm_nest_level
  %s = sub i32 %t, 123456
  %k = icmp ugt i32 %x, %y
  %z = zext i1 %k to i32
  %r = sub i32 %s, %z
  ret i32 %r
}

define i32 @sbb32mi_GS(i32 %x, i32 %y) {
; CHECK-LABEL: sbb32mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %gs:255, %eax # encoding: [0x65,0x8b,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    subl %edi, %esi, %ecx # encoding: [0x62,0xf4,0x74,0x18,0x29,0xfe]
; CHECK-NEXT:    sbbl $0, %eax, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x81,0xd8,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    addl $-123456, %eax, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x81,0xc0,0xc0,0x1d,0xfe,0xff]
; CHECK-NEXT:    # imm = 0xFFFE1DC0
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i32 255 to ptr addrspace(256)
  %t = load i32, ptr addrspace(256) %a
  %s = sub i32 %t, 123456
  %k = icmp ugt i32 %x, %y
  %z = zext i1 %k to i32
  %r = sub i32 %s, %z
  ret i32 %r
}

define i64 @sbb64mi_FS(i64 %x, i64 %y) nounwind {
; CHECK-LABEL: sbb64mi_FS:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %fs:0, %rax # encoding: [0x64,0x48,0x8b,0x04,0x25,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    subq %rdi, %rsi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0x29,0xfe]
; CHECK-NEXT:    sbbq $0, tm_nest_level@TPOFF(%rax), %rax # encoding: [0x62,0xf4,0xfc,0x18,0x81,0x98,A,A,A,A,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    # fixup A - offset: 6, value: tm_nest_level@TPOFF, kind: reloc_signed_4byte
; CHECK-NEXT:    addq $-123456, %rax, %rax # encoding: [0x62,0xf4,0xfc,0x18,0x81,0xc0,0xc0,0x1d,0xfe,0xff]
; CHECK-NEXT:    # imm = 0xFFFE1DC0
; CHECK-NEXT:    retq # encoding: [0xc3]

  %t = load i64, ptr @tm_nest_level
  %s = sub i64 %t, 123456
  %k = icmp ugt i64 %x, %y
  %z = zext i1 %k to i64
  %r = sub i64 %s, %z
  ret i64 %r
}

define i64 @sbb64mi_GS(i64 %x, i64 %y) {
; CHECK-LABEL: sbb64mi_GS:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq %gs:255, %rax # encoding: [0x65,0x48,0x8b,0x04,0x25,0xff,0x00,0x00,0x00]
; CHECK-NEXT:    subq %rdi, %rsi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0x29,0xfe]
; CHECK-NEXT:    sbbq $0, %rax, %rax # encoding: [0x62,0xf4,0xfc,0x18,0x81,0xd8,0x00,0x00,0x00,0x00]
; CHECK-NEXT:    addq $-123456, %rax, %rax # encoding: [0x62,0xf4,0xfc,0x18,0x81,0xc0,0xc0,0x1d,0xfe,0xff]
; CHECK-NEXT:    # imm = 0xFFFE1DC0
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %a= inttoptr i64 255 to ptr addrspace(256)
  %t = load i64, ptr addrspace(256) %a
  %s = sub i64 %t, 123456
  %k = icmp ugt i64 %x, %y
  %z = zext i1 %k to i64
  %r = sub i64 %s, %z
  ret i64 %r
}
