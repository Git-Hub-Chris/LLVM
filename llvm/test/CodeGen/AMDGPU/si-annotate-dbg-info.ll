; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -mtriple=amdgcn-- -S -structurizecfg -si-annotate-control-flow %s | FileCheck -check-prefix=OPT %s

define amdgpu_ps i32 @if_else(i32 %0) {
; OPT-LABEL: define amdgpu_ps i32 @if_else(
; OPT-SAME: i32 [[TMP0:%.*]]) {
; OPT-NEXT:    [[C:%.*]] = icmp ne i32 [[TMP0]], 0
; OPT-NEXT:    [[TMP2:%.*]] = call { i1, i64 } @llvm.amdgcn.if.i64(i1 [[C]])
; OPT-NEXT:    [[TMP3:%.*]] = extractvalue { i1, i64 } [[TMP2]], 0
; OPT-NEXT:    [[TMP4:%.*]] = extractvalue { i1, i64 } [[TMP2]], 1
; OPT-NEXT:    br i1 [[TMP3]], label [[FALSE:%.*]], label [[FLOW:%.*]]
; OPT:       Flow:
; OPT-NEXT:    [[TMP5:%.*]] = phi i32 [ 33, [[FALSE]] ], [ undef, [[TMP1:%.*]] ]
; OPT-NEXT:    [[TMP6:%.*]] = call { i1, i64 } @llvm.amdgcn.else.i64.i64(i64 [[TMP4]])
; OPT-NEXT:    [[TMP7:%.*]] = extractvalue { i1, i64 } [[TMP6]], 0
; OPT-NEXT:    [[TMP8:%.*]] = extractvalue { i1, i64 } [[TMP6]], 1
; OPT-NEXT:    br i1 [[TMP7]], label [[TRUE:%.*]], label [[EXIT:%.*]]
; OPT:       true:
; OPT-NEXT:    br label [[EXIT]]
; OPT:       false:
; OPT-NEXT:    br label [[FLOW]]
; OPT:       exit:
; OPT-NEXT:    [[RET:%.*]] = phi i32 [ [[TMP5]], [[FLOW]] ], [ 42, [[TRUE]] ]
; OPT-NEXT:    call void @llvm.amdgcn.end.cf.i64(i64 [[TMP8]])
; OPT-NEXT:    ret i32 [[RET]]
;
  %c = icmp eq i32 %0, 0
  br i1 %c, label %true, label %false
true:
  br label %exit
false:
  br label %exit
exit:
  %ret = phi i32 [ 42, %true ], [ 33, %false ]
  ret i32 %ret
}

define amdgpu_ps void @loop_if_break(i32 %n) {
; OPT-LABEL: define amdgpu_ps void @loop_if_break(
; OPT-SAME: i32 [[N:%.*]]) {
; OPT-NEXT:  entry:
; OPT-NEXT:    br label [[LOOP:%.*]]
; OPT:       loop:
; OPT-NEXT:    [[PHI_BROKEN:%.*]] = phi i64 [ [[TMP5:%.*]], [[FLOW:%.*]] ], [ 0, [[ENTRY:%.*]] ]
; OPT-NEXT:    [[I:%.*]] = phi i32 [ [[N]], [[ENTRY]] ], [ [[TMP3:%.*]], [[FLOW]] ]
; OPT-NEXT:    [[C:%.*]] = icmp ugt i32 [[I]], 0
; OPT-NEXT:    [[TMP0:%.*]] = call { i1, i64 } @llvm.amdgcn.if.i64(i1 [[C]])
; OPT-NEXT:    [[TMP1:%.*]] = extractvalue { i1, i64 } [[TMP0]], 0
; OPT-NEXT:    [[TMP2:%.*]] = extractvalue { i1, i64 } [[TMP0]], 1
; OPT-NEXT:    br i1 [[TMP1]], label [[LOOP_BODY:%.*]], label [[FLOW]]
; OPT:       loop_body:
; OPT-NEXT:    [[I_NEXT:%.*]] = sub i32 [[I]], 1
; OPT-NEXT:    br label [[FLOW]]
; OPT:       Flow:
; OPT-NEXT:    [[TMP3]] = phi i32 [ [[I_NEXT]], [[LOOP_BODY]] ], [ undef, [[LOOP]] ]
; OPT-NEXT:    [[TMP4:%.*]] = phi i1 [ false, [[LOOP_BODY]] ], [ true, [[LOOP]] ]
; OPT-NEXT:    call void @llvm.amdgcn.end.cf.i64(i64 [[TMP2]])
; OPT-NEXT:    [[TMP5]] = call i64 @llvm.amdgcn.if.break.i64(i1 [[TMP4]], i64 [[PHI_BROKEN]])
; OPT-NEXT:    [[TMP6:%.*]] = call i1 @llvm.amdgcn.loop.i64(i64 [[TMP5]])
; OPT-NEXT:    br i1 [[TMP6]], label [[EXIT:%.*]], label [[LOOP]]
; OPT:       exit:
; OPT-NEXT:    call void @llvm.amdgcn.end.cf.i64(i64 [[TMP5]])
; OPT-NEXT:    ret void
;
entry:
  br label %loop
loop:
  %i = phi i32 [ %n, %entry ], [ %i.next, %loop_body ]
  %c = icmp ugt i32 %i, 0
  br i1 %c, label %loop_body, label %exit
loop_body:
  %i.next = sub i32 %i, 1
  br label %loop
exit:
  ret void
}
