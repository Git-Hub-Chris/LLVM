; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -S -passes=jump-threading < %s | FileCheck %s

; Jump threading should not be able to duplicate a block containing inline
; assembly, since we do not know what is in the inline-asm instruction.

define void @foo(i32 %n.arg, ptr %b.arg, ptr %c.arg) {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: i32 [[N_ARG:%.*]], ptr [[B_ARG:%.*]], ptr [[C_ARG:%.*]]) {
; CHECK-NEXT:  L.entry:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i32 [[N_ARG]], 0
; CHECK-NEXT:    br i1 [[TMP0]], label [[L_B0000:%.*]], label [[L_B0002:%.*]]
; CHECK:       L.B0002:
; CHECK-NEXT:    store ptr null, ptr [[C_ARG]], align 8
; CHECK-NEXT:    store ptr null, ptr [[B_ARG]], align 8
; CHECK-NEXT:    br label [[L_B0000]]
; CHECK:       L.B0000:
; CHECK-NEXT:    call void asm sideeffect " .LABEL: \0A\09", ""()
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[N_ARG]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label [[L_B0001:%.*]], label [[L_B0003:%.*]]
; CHECK:       L.B0003:
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[B_ARG]], align 8
; CHECK-NEXT:    call void @bar(ptr [[TMP2]])
; CHECK-NEXT:    br label [[L_B0001]]
; CHECK:       L.B0001:
; CHECK-NEXT:    ret void
;
L.entry:
  %0 = icmp eq i32  %n.arg, 0
  br i1  %0, label %L.B0000, label %L.B0002
L.B0002:
  store ptr null, ptr %c.arg
  store ptr null, ptr %b.arg
  br label %L.B0000
L.B0000:
  call void asm sideeffect "   .LABEL: \0A\09", "" ()
  %1 = icmp eq i32  %n.arg, 0
  br i1  %1, label %L.B0001, label %L.B0003
L.B0003:
  %2 = load ptr, ptr %b.arg
  call void  @bar (ptr  %2)
  br label %L.B0001
L.B0001:
  ret void
}

declare void @bar(ptr)
