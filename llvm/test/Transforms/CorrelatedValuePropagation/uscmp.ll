; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=correlated-propagation -S | FileCheck %s

; If nothing is known we can't change anything
define i8 @ucmp_0(i32 %x, i32 %y) {
  %1 = call i8 @llvm.ucmp(i32 %x, i32 %y)
  ret i8 %1
}

define i8 @scmp_0(i32 %x, i32 %y) {
  %1 = call i8 @llvm.scmp(i32 %x, i32 %y)
  ret i8 %1
}

; If we know that range of LHS < range of RHS then return -1
define i8 @ucmp_1(i32 %x, i32 %y) {
  ; X is within [4, 8)
  %cond1 = icmp uge i32 %x, 4
  call void @llvm.assume(i1 %cond1)
  %cond2 = icmp ult i32 %x, 8
  call void @llvm.assume(i1 %cond2)
  ; Y is within [8, +INF)
  %cond3 = icmp uge i32 %y, 8
  call void @llvm.assume(i1 %cond3)

  %1 = call i8 @llvm.ucmp(i32 %x, i32 %y)
  ret i8 %1
}

define i8 @scmp_1(i32 %x, i32 %y) {
  ; X is within [-5, 3)
  %cond1 = icmp sge i32 %x, -5
  call void @llvm.assume(i1 %cond1)
  %cond2 = icmp slt i32 %x, 3
  call void @llvm.assume(i1 %cond2)
  ; Y is within [3, +INF)
  %cond3 = icmp sge i32 %y, 3
  call void @llvm.assume(i1 %cond3)

  %1 = call i8 @llvm.scmp(i32 %x, i32 %y)
  ret i8 %1
}

; If we know that range of LHS > range of RHS then return 1
define i8 @ucmp_2(i32 %x, i32 %y) {
  ; X is within [4, +INF)
  %cond1 = icmp uge i32 %x, 4
  call void @llvm.assume(i1 %cond1)
  ; Y is within [0, 4)
  %cond2 = icmp ult i32 %y, 4
  call void @llvm.assume(i1 %cond2)

  %1 = call i8 @llvm.ucmp(i32 %x, i32 %y)
  ret i8 %1
}

define i8 @scmp_2(i32 %x, i32 %y) {
  ; X is within [4, +INF)
  %cond1 = icmp sge i32 %x, 4
  call void @llvm.assume(i1 %cond1)
  ; Y is within [-INF, 4)
  %cond2 = icmp slt i32 %y, 4
  call void @llvm.assume(i1 %cond2)

  %1 = call i8 @llvm.scmp(i32 %x, i32 %y)
  ret i8 %1
}

; Negative test: ranges overlap
define i8 @ucmp_3(i32 %x, i32 %y) {
  ; X is within [4, +INF)
  %cond1 = icmp uge i32 %x, 4
  call void @llvm.assume(i1 %cond1)
  ; Y is within [0, 6)
  %cond2 = icmp ult i32 %y, 6
  call void @llvm.assume(i1 %cond2)

  %1 = call i8 @llvm.ucmp(i32 %x, i32 %y)
  ret i8 %1
}

define i8 @scmp_3(i32 %x, i32 %y) {
  ; X is within [2, +INF)
  %cond1 = icmp sge i32 %x, 2
  call void @llvm.assume(i1 %cond1)
  ; Y is within [-INF, 4)
  %cond2 = icmp slt i32 %y, 4
  call void @llvm.assume(i1 %cond2)

  %1 = call i8 @llvm.scmp(i32 %x, i32 %y)
  ret i8 %1
}

; Negative test: mismatched signedness of range-establishing comparisons and
;                of the intrinsic
define i8 @ucmp_4(i32 %x, i32 %y) {
  ; X is within [4, +INF)
  %cond1 = icmp sge i32 %x, 4
  call void @llvm.assume(i1 %cond1)
  ; Y is within [0, 4)
  %cond2 = icmp slt i32 %y, 4
  call void @llvm.assume(i1 %cond2)

  %1 = call i8 @llvm.ucmp(i32 %x, i32 %y)
  ret i8 %1
}

define i8 @scmp_4(i32 %x, i32 %y) {
  ; X is within [4, +INF)
  %cond1 = icmp uge i32 %x, 4
  call void @llvm.assume(i1 %cond1)
  ; Y is within [0, 4)
  %cond2 = icmp ult i32 %y, 4
  call void @llvm.assume(i1 %cond2)

  %1 = call i8 @llvm.scmp(i32 %x, i32 %y)
  ret i8 %1
}
