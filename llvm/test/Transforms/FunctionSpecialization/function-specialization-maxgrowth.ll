; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --include-generated-funcs --version 5
; RUN: opt -passes="ipsccp<func-spec>" -funcspec-min-function-size=1       \
; RUN:                                 -funcspec-for-literal-constant=true \
; RUN:                                 -funcspec-min-codesize-savings=50   \
; RUN:                                 -funcspec-min-latency-savings=50    \
; RUN:                                 -funcspec-max-codesize-growth=1     \
; RUN:                                 -S < %s | FileCheck %s

; Verify that we are able to specialize a function successfully after analysis
; of other specializations that are found to not be profitable.
define void @test_specialize_after_failed_analysis(i32 %n) {
entry:
  %notspec0 = call i32 @add0(i32 0, i32 %n)
  %notspec1 = call i32 @add0(i32 1, i32 %n)
  %spec = call i32 @add0(i32 1, i32 1)
  ret void
}

define i32 @add0(i32 %x, i32 %y) {
entry:
  %res = add i32 %x, %y
  ret i32 %res
}

; Verify that we do not specialize once maximum codesize growth has been
; exceeded.
define void @test_max_codesize_growth_exceeded(i32 %n) {
entry:
  %spec0 = call i32 @add1(i32 0, i32 0)
  %spec1 = call i32 @add1(i32 1, i32 1)
  %spec2 = call i32 @add1(i32 2, i32 2)
  %notspec = call i32 @add1(i32 3, i32 3)
  ret void
}

define i32 @add1(i32 %x, i32 %y) {
entry:
  %res = add i32 %x, %y
  ret i32 %res
}

; CHECK-LABEL: define void @test_specialize_after_failed_analysis(
; CHECK-SAME: i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[NOTSPEC0:%.*]] = call i32 @add0(i32 0, i32 [[N]])
; CHECK-NEXT:    [[NOTSPEC1:%.*]] = call i32 @add0(i32 1, i32 [[N]])
; CHECK-NEXT:    [[SPEC:%.*]] = call i32 @add0(i32 1, i32 1)
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define i32 @add0(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RES:%.*]] = add i32 [[X]], [[Y]]
; CHECK-NEXT:    ret i32 [[RES]]
;
;
; CHECK-LABEL: define void @test_max_codesize_growth_exceeded(
; CHECK-SAME: i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SPEC0:%.*]] = call i32 @add1.specialized.1(i32 0, i32 0)
; CHECK-NEXT:    [[SPEC1:%.*]] = call i32 @add1.specialized.2(i32 1, i32 1)
; CHECK-NEXT:    [[SPEC2:%.*]] = call i32 @add1.specialized.3(i32 2, i32 2)
; CHECK-NEXT:    [[NOTSPEC:%.*]] = call i32 @add1(i32 3, i32 3)
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define i32 @add1(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RES:%.*]] = add i32 [[X]], [[Y]]
; CHECK-NEXT:    ret i32 [[RES]]
;
;
; CHECK-LABEL: define internal i32 @add1.specialized.1(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i32 poison
;
;
; CHECK-LABEL: define internal i32 @add1.specialized.2(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i32 poison
;
;
; CHECK-LABEL: define internal i32 @add1.specialized.3(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i32 poison
;
