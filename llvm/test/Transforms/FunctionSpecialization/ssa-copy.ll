; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --include-generated-funcs --version 5
; RUN: opt -passes="ipsccp<func-spec>" -funcspec-min-function-size=1       \
; RUN:                                 -funcspec-for-literal-constant=true \
; RUN:                                 -funcspec-min-codesize-savings=50   \
; RUN:                                 -funcspec-min-latency-savings=0     \
; RUN:                                 -S < %s | FileCheck %s

; Verify that we are able to estimate the codesize savings by looking through
; calls to ssa_copy intrinsics, which are inserted by PredicateInfo when IPSCCP
; is run prior to FunctionSpecialization.
; FIXME: We should be able to specialize this, but we currently do not handle
; FIXME: llvm.ssa.copy calls in InstCostVisitor.
define i32 @main() {
entry:
  %res = call i32 @test_ssa_copy(i32 0)
  ret i32 %res
}

define i32 @test_ssa_copy(i32 %x) {
entry:
  br label %block1

block1:
  %cmp = icmp eq i32 %x, 0
  br i1 %cmp, label %block2, label %exit1

block2:
  br i1 %cmp, label %block3, label %exit2

block3:
  br i1 %cmp, label %exit4, label %exit3

exit1:
  ret i32 %x

exit2:
  ret i32 %x

exit3:
  ret i32 %x

exit4:
  ret i32 999
}

; CHECK-LABEL: define range(i32 1, 0) i32 @main() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RES:%.*]] = call i32 @test_ssa_copy(i32 0)
; CHECK-NEXT:    ret i32 [[RES]]
;
;
; CHECK-LABEL: define range(i32 1, 0) i32 @test_ssa_copy(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[BLOCK1:.*]]
; CHECK:       [[BLOCK1]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X]], 0
; CHECK-NEXT:    br i1 [[CMP]], label %[[BLOCK2:.*]], label %[[EXIT1:.*]]
; CHECK:       [[BLOCK2]]:
; CHECK-NEXT:    br label %[[BLOCK3:.*]]
; CHECK:       [[BLOCK3]]:
; CHECK-NEXT:    br label %[[EXIT4:.*]]
; CHECK:       [[EXIT1]]:
; CHECK-NEXT:    ret i32 [[X]]
; CHECK:       [[EXIT4]]:
; CHECK-NEXT:    ret i32 999
;
