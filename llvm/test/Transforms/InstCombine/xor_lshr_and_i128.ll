; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

define i128 @xor_lshr_and(i128 %x, i128 %y) {
; CHECK-LABEL: define i128 @xor_lshr_and(
; CHECK-SAME: i128 [[X:%.*]], i128 [[Y:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i128 [[Y]], [[X]]
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i128 [[XOR]], 1
; CHECK-NEXT:    [[AND:%.*]] = and i128 [[Y]], [[X]]
; CHECK-NEXT:    [[ADD:%.*]] = add i128 [[LSHR]], [[AND]]
; CHECK-NEXT:    ret i128 [[ADD]]
;
start:
  %xor = xor i128 %y, %x
  %lshr = lshr i128 %xor, 1
  %and = and i128 %y, %x
  %add = add i128 %lshr, %and
  ret i128 %add
}

define i128 @xor_lshr_and_commuted1(i128 %x, i128 %y) {
; CHECK-LABEL: define i128 @xor_lshr_and_commuted1(
; CHECK-SAME: i128 [[X:%.*]], i128 [[Y:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[AND:%.*]] = and i128 [[Y]], [[X]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i128 [[Y]], [[X]]
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i128 [[XOR]], 1
; CHECK-NEXT:    [[ADD:%.*]] = add i128 [[LSHR]], [[AND]]
; CHECK-NEXT:    ret i128 [[ADD]]
;
start:
  %and = and i128 %y, %x
  %xor = xor i128 %y, %x
  %lshr = lshr i128 %xor, 1
  %add = add i128 %lshr, %and
  ret i128 %add
}

define i128 @xor_lshr_and_commuted2(i128 %x, i128 %y) {
; CHECK-LABEL: define i128 @xor_lshr_and_commuted2(
; CHECK-SAME: i128 [[X:%.*]], i128 [[Y:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[AND:%.*]] = and i128 [[Y]], [[X]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i128 [[Y]], [[X]]
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i128 [[XOR]], 1
; CHECK-NEXT:    [[ADD:%.*]] = add i128 [[LSHR]], [[AND]]
; CHECK-NEXT:    ret i128 [[ADD]]
;
start:
  %and = and i128 %y, %x
  %xor = xor i128 %y, %x
  %lshr = lshr i128 %xor, 1
  %add = add i128 %lshr, %and
  ret i128 %add
}

declare void @use(i8)

define i128 @xor_lshr_and_multi_use(i128 %x, i128 %y) {
; CHECK-LABEL: define i128 @xor_lshr_and_multi_use(
; CHECK-SAME: i128 [[X:%.*]], i128 [[Y:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i128 [[Y]], [[X]]
; CHECK-NEXT:    call void @use(i128 [[XOR]])
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i128 [[XOR]], 1
; CHECK-NEXT:    call void @use(i128 [[LSHR]])
; CHECK-NEXT:    [[AND:%.*]] = and i128 [[Y]], [[X]]
; CHECK-NEXT:    [[ADD:%.*]] = add i128 [[LSHR]], [[AND]]
; CHECK-NEXT:    ret i128 [[ADD]]
;
start:
  %xor = xor i128 %y, %x
  call void @use(i128 %xor)
  %lshr = lshr i128 %xor, 1
  call void @use(i128 %lshr)
  %and = and i128 %y, %x
  %add = add i128 %lshr, %and
  ret i128 %add
}

define i128 @xor_lshr_and_negative(i128 %x, i128 %y) {
; CHECK-LABEL: define i128 @xor_lshr_and_negative(
; CHECK-SAME: i128 [[X:%.*]], i128 [[Y:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i128 [[X]], -1
; CHECK-NEXT:    [[AND:%.*]] = and i128 [[Y]], [[X]]
; CHECK-NEXT:    [[ADD:%.*]] = add i128 [[AND]], [[XOR]]
; CHECK-NEXT:    ret i128 [[ADD]]
;
start:
  %xor = xor i128 %x, -1
  %and = and i128 %y, %x
  %add = add i128 %xor, %and
  ret i128 %add
}

define i32 @xor_lshr_and_negative2(i32 %x, i32 %y) {
; CHECK-LABEL: define i32 @xor_lshr_and_negative2(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i32 [[Y]], [[X]]
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i32 [[XOR]], 1
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[Y]], [[X]]
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[LSHR]], [[AND]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
start:
  %xor = xor i32 %y, %x
  %lshr = lshr i32 %xor, 1
  %and = and i32 %y, %x
  %add = add i32 %lshr, %and
  ret i32 %add
}

define <2 x i128> @xor_lshr_and_vec(<2 x i128> %x, <2 x i128> %y) {
; CHECK-LABEL: define <2 x i128> @xor_lshr_and_vec(
; CHECK-SAME: <2 x i128> [[X:%.*]], <2 x i128> [[Y:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[XOR:%.*]] = xor <2 x i128> [[Y]], [[X]]
; CHECK-NEXT:    [[LSHR:%.*]] = lshr <2 x i128> [[XOR]], <i128 1, i128 1>
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i128> [[Y]], [[X]]
; CHECK-NEXT:    [[ADD:%.*]] = add <2 x i128> [[LSHR]], [[AND]]
; CHECK-NEXT:    ret <2 x i128> [[ADD]]
;
start:
  %xor = xor <2 x i128> %y, %x
  %lshr = lshr <2 x i128> %xor, <i128 1, i128 1>
  %and = and <2 x i128> %y, %x
  %add = add <2 x i128> %lshr, %and
  ret <2 x i128> %add
}

