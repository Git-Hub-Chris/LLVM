; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=arm64 -S < %s -passes=instcombine | FileCheck %s

; Verify that instcombine doesn't look at users of Constant in different
; functions for dominates() queries.

define void @spam(ptr %arg) personality ptr null {
; CHECK-LABEL: define void @spam(
; CHECK-SAME: ptr [[ARG:%.*]]) personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I]], label %[[BB2_I:.*]], label %[[BB3_I:.*]]
; CHECK:       [[BB2_I]]:
; CHECK-NEXT:    store i64 1, ptr [[ARG]], align 8
; CHECK-NEXT:    br label %[[BARNEY_EXIT:.*]]
; CHECK:       [[BB3_I]]:
; CHECK-NEXT:    [[LOAD_I_I:%.*]] = load volatile i32, ptr null, align 4
; CHECK-NEXT:    [[ICMP_I_I:%.*]] = icmp eq i32 [[LOAD_I_I]], 0
; CHECK-NEXT:    br i1 [[ICMP_I_I]], label %[[BB2_I_I:.*]], label %[[BB3_I_I:.*]]
; CHECK:       [[BB2_I_I]]:
; CHECK-NEXT:    br label %[[BB1_I:.*]]
; CHECK:       [[BB1_I]]:
; CHECK-NEXT:    [[LOAD_I_I_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I_I]], label %[[SPAM_EXIT_I:.*]], label %[[BB3_I_I_I:.*]]
; CHECK:       [[BB3_I_I_I]]:
; CHECK-NEXT:    call void @zot.4()
; CHECK-NEXT:    br label %[[SPAM_EXIT_I]]
; CHECK:       [[SPAM_EXIT_I]]:
; CHECK-NEXT:    [[ALLOCA_SROA_0_1_I:%.*]] = phi i64 [ 0, %[[BB3_I_I_I]] ], [ 1, %[[BB1_I]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i64 [[ALLOCA_SROA_0_1_I]] to ptr
; CHECK-NEXT:    store i32 0, ptr [[TMP0]], align 4
; CHECK-NEXT:    br label %[[BB1_I]]
; CHECK:       [[EGGS_EXIT:.*:]]
; CHECK-NEXT:    br label %[[BARNEY_EXIT]]
; CHECK:       [[BB3_I_I]]:
; CHECK-NEXT:    [[LOAD_I_I1:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I1]], label %[[QUUX_EXIT:.*]], label %[[BB3_I_I2:.*]]
; CHECK:       [[BB3_I_I2]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[QUUX_EXIT]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    br label %[[BARNEY_EXIT]]
; CHECK:       [[BARNEY_EXIT]]:
; CHECK-NEXT:    ret void
;
bb:
  %load.i = load volatile i1, ptr null, align 1
  br i1 %load.i, label %bb2.i, label %bb3.i

bb2.i:                                            ; preds = %bb
  store i64 1, ptr %arg, align 8
  br label %barney.exit

bb3.i:                                            ; preds = %bb
  %load.i.i = load volatile i32, ptr null, align 4
  %icmp.i.i = icmp eq i32 %load.i.i, 0
  br i1 %icmp.i.i, label %bb2.i.i, label %bb3.i.i

bb2.i.i:                                          ; preds = %bb3.i
  br label %bb1.i

bb1.i:                                            ; preds = %spam.exit.i, %bb2.i.i
  %load.i.i.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i.i, label %spam.exit.i, label %bb3.i.i.i

bb3.i.i.i:                                        ; preds = %bb1.i
  call void @zot.4()
  br label %spam.exit.i

spam.exit.i:                                      ; preds = %bb3.i.i.i, %bb1.i
  %alloca.sroa.0.1.i = phi i64 [ 0, %bb3.i.i.i ], [ 1, %bb1.i ]
  %0 = inttoptr i64 %alloca.sroa.0.1.i to ptr
  store i32 0, ptr %0, align 4
  br label %bb1.i

eggs.exit:                                        ; No predecessors!
  br label %barney.exit

bb3.i.i:                                          ; preds = %bb3.i
  %load.i.i1 = load volatile i1, ptr null, align 1
  br i1 %load.i.i1, label %quux.exit, label %bb3.i.i2

bb3.i.i2:                                         ; preds = %bb3.i.i
  call void @snork()
  unreachable

quux.exit:                                        ; preds = %bb3.i.i
  store ptr null, ptr null, align 8
  br label %barney.exit

barney.exit:                                      ; preds = %quux.exit, %eggs.exit, %bb2.i
  ret void
}

define ptr @zot(ptr %arg) personality ptr null {
; CHECK-LABEL: define ptr @zot(
; CHECK-SAME: ptr [[ARG:%.*]]) personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I_I_I_I:%.*]] = load ptr, ptr [[ARG]], align 8
; CHECK-NEXT:    store ptr null, ptr [[ARG]], align 8
; CHECK-NEXT:    store i32 0, ptr [[LOAD_I_I_I_I]], align 4
; CHECK-NEXT:    ret ptr null
;
bb:
  %load.i.i.i.i = load ptr, ptr %arg, align 8
  store ptr null, ptr %arg, align 8
  store i32 0, ptr %load.i.i.i.i, align 4
  ret ptr null
}

define void @wombat() personality ptr null {
; CHECK-LABEL: define void @wombat() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
;
bb:
  call void @snork()
  unreachable
}

define ptr @wombat.1(ptr %arg) {
; CHECK-LABEL: define ptr @wombat.1(
; CHECK-SAME: ptr [[ARG:%.*]]) {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    store i64 1, ptr [[ARG]], align 8
; CHECK-NEXT:    ret ptr null
;
bb:
  store i64 1, ptr %arg, align 8
  ret ptr null
}

define void @quux() personality ptr null {
; CHECK-LABEL: define void @quux() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I]], label %[[WIBBLE_EXIT:.*]], label %[[BB3_I:.*]]
; CHECK:       [[BB3_I]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[WIBBLE_EXIT]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    ret void
;
bb:
  %load.i = load volatile i1, ptr null, align 1
  br i1 %load.i, label %wibble.exit, label %bb3.i

bb3.i:                                            ; preds = %bb
  call void @snork()
  unreachable

wibble.exit:                                      ; preds = %bb
  store ptr null, ptr null, align 8
  ret void
}

define void @wobble() personality ptr null {
; CHECK-LABEL: define void @wobble() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I]], label %[[WOBBLE_2_EXIT:.*]], label %[[BB3_I_I:.*]]
; CHECK:       [[BB3_I_I]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[WOBBLE_2_EXIT]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    ret void
;
bb:
  %load.i.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i, label %wobble.2.exit, label %bb3.i.i

bb3.i.i:                                          ; preds = %bb
  call void @snork()
  unreachable

wobble.2.exit:                                    ; preds = %bb
  store ptr null, ptr null, align 8
  ret void
}

define void @eggs() personality ptr null {
; CHECK-LABEL: define void @eggs() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    br label %[[BB1:.*]]
; CHECK:       [[BB1]]:
; CHECK-NEXT:    [[LOAD_I_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I]], label %[[SPAM_EXIT:.*]], label %[[BB3_I_I:.*]]
; CHECK:       [[BB3_I_I]]:
; CHECK-NEXT:    call void @zot.4()
; CHECK-NEXT:    br label %[[SPAM_EXIT]]
; CHECK:       [[SPAM_EXIT]]:
; CHECK-NEXT:    [[ALLOCA_SROA_0_1:%.*]] = phi i64 [ 0, %[[BB3_I_I]] ], [ 1, %[[BB1]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i64 [[ALLOCA_SROA_0_1]] to ptr
; CHECK-NEXT:    store i32 0, ptr [[TMP0]], align 4
; CHECK-NEXT:    br label %[[BB1]]
;
bb:
  br label %bb1

bb1:                                              ; preds = %spam.exit, %bb
  %load.i.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i, label %spam.exit, label %bb3.i.i

bb3.i.i:                                          ; preds = %bb1
  call void @zot.4()
  br label %spam.exit

spam.exit:                                        ; preds = %bb1, %bb3.i.i
  %alloca.sroa.0.1 = phi i64 [ 0, %bb3.i.i ], [ 1, %bb1 ]
  %0 = inttoptr i64 %alloca.sroa.0.1 to ptr
  store i32 0, ptr %0, align 4
  br label %bb1
}

define void @wobble.2() personality ptr null {
; CHECK-LABEL: define void @wobble.2() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I]], label %[[BB2_I:.*]], label %[[BB3_I:.*]]
; CHECK:       [[BB2_I]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    br label %[[WIBBLE_EXIT:.*]]
; CHECK:       [[BB3_I]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[FOO_EXIT:.*:]]
; CHECK-NEXT:    br label %[[WIBBLE_EXIT]]
; CHECK:       [[WIBBLE_EXIT]]:
; CHECK-NEXT:    ret void
;
bb:
  %load.i = load volatile i1, ptr null, align 1
  br i1 %load.i, label %bb2.i, label %bb3.i

bb2.i:                                            ; preds = %bb
  %inttoptr.i = inttoptr i64 0 to ptr
  store ptr %inttoptr.i, ptr null, align 8
  br label %wibble.exit

bb3.i:                                            ; preds = %bb
  call void @snork()
  unreachable

foo.exit:                                         ; No predecessors!
  br label %wibble.exit

wibble.exit:                                      ; preds = %bb2.i, %foo.exit
  ret void
}

define void @quux.3() personality ptr null {
; CHECK-LABEL: define void @quux.3() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I]], label %[[BB2_I:.*]], label %[[BB3_I:.*]]
; CHECK:       [[BB2_I]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    br label %[[WIBBLE_EXIT:.*]]
; CHECK:       [[BB3_I]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[WOMBAT_EXIT:.*:]]
; CHECK-NEXT:    br label %[[WIBBLE_EXIT]]
; CHECK:       [[WIBBLE_EXIT]]:
; CHECK-NEXT:    ret void
;
bb:
  %load.i = load volatile i1, ptr null, align 1
  br i1 %load.i, label %bb2.i, label %bb3.i

bb2.i:                                            ; preds = %bb
  store ptr null, ptr null, align 8
  br label %wibble.exit

bb3.i:                                            ; preds = %bb
  call void @snork()
  unreachable

wombat.exit:                                      ; No predecessors!
  br label %wibble.exit

wibble.exit:                                      ; preds = %bb2.i, %wombat.exit
  ret void
}

define void @zot.4() personality ptr null {
; CHECK-LABEL: define void @zot.4() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I:%.*]] = load volatile i32, ptr null, align 4
; CHECK-NEXT:    [[ICMP_I:%.*]] = icmp eq i32 [[LOAD_I]], 0
; CHECK-NEXT:    br i1 [[ICMP_I]], label %[[BB2_I:.*]], label %[[BB3_I:.*]]
; CHECK:       [[BB2_I]]:
; CHECK-NEXT:    br label %[[BB1_I:.*]]
; CHECK:       [[BB1_I]]:
; CHECK-NEXT:    [[LOAD_I_I_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I_I]], label %[[SPAM_EXIT_I:.*]], label %[[BB3_I_I_I:.*]]
; CHECK:       [[BB3_I_I_I]]:
; CHECK-NEXT:    call void @zot.4()
; CHECK-NEXT:    br label %[[SPAM_EXIT_I]]
; CHECK:       [[SPAM_EXIT_I]]:
; CHECK-NEXT:    [[ALLOCA_I_SROA_0_1:%.*]] = phi i64 [ 0, %[[BB3_I_I_I]] ], [ 1, %[[BB1_I]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i64 [[ALLOCA_I_SROA_0_1]] to ptr
; CHECK-NEXT:    store i32 0, ptr [[TMP0]], align 4
; CHECK-NEXT:    br label %[[BB1_I]]
; CHECK:       [[EGGS_EXIT:.*:]]
; CHECK-NEXT:    br label %[[BLAM_EXIT:.*]]
; CHECK:       [[BB3_I]]:
; CHECK-NEXT:    [[LOAD_I_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I]], label %[[BB2_I_I:.*]], label %[[BB3_I_I:.*]]
; CHECK:       [[BB2_I_I]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    br label %[[BLAM_EXIT]]
; CHECK:       [[BB3_I_I]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[WOMBAT_EXIT:.*:]]
; CHECK-NEXT:    br label %[[BLAM_EXIT]]
; CHECK:       [[BLAM_EXIT]]:
; CHECK-NEXT:    ret void
;
bb:
  %load.i = load volatile i32, ptr null, align 4
  %icmp.i = icmp eq i32 %load.i, 0
  br i1 %icmp.i, label %bb2.i, label %bb3.i

bb2.i:                                            ; preds = %bb
  br label %bb1.i

bb1.i:                                            ; preds = %spam.exit.i, %bb2.i
  %load.i.i.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i.i, label %spam.exit.i, label %bb3.i.i.i

bb3.i.i.i:                                        ; preds = %bb1.i
  call void @zot.4()
  br label %spam.exit.i

spam.exit.i:                                      ; preds = %bb1.i, %bb3.i.i.i
  %alloca.i.sroa.0.1 = phi i64 [ 0, %bb3.i.i.i ], [ 1, %bb1.i ]
  %0 = inttoptr i64 %alloca.i.sroa.0.1 to ptr
  store i32 0, ptr %0, align 4
  br label %bb1.i

eggs.exit:                                        ; No predecessors!
  br label %blam.exit

bb3.i:                                            ; preds = %bb
  %load.i.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i, label %bb2.i.i, label %bb3.i.i

bb2.i.i:                                          ; preds = %bb3.i
  store ptr null, ptr null, align 8
  br label %blam.exit

bb3.i.i:                                          ; preds = %bb3.i
  call void @snork()
  unreachable

wombat.exit:                                      ; No predecessors!
  br label %blam.exit

blam.exit:                                        ; preds = %wombat.exit, %bb2.i.i, %eggs.exit
  ret void
}

define void @blam() personality ptr null {
; CHECK-LABEL: define void @blam() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD:%.*]] = load volatile i32, ptr null, align 4
; CHECK-NEXT:    [[ICMP:%.*]] = icmp eq i32 [[LOAD]], 0
; CHECK-NEXT:    br i1 [[ICMP]], label %[[BB2:.*]], label %[[BB3:.*]]
; CHECK:       [[BB1:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[BB2]]:
; CHECK-NEXT:    br label %[[BB1_I:.*]]
; CHECK:       [[BB1_I]]:
; CHECK-NEXT:    [[LOAD_I_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I]], label %[[SPAM_EXIT:.*]], label %[[BB3_I_I:.*]]
; CHECK:       [[BB3_I_I]]:
; CHECK-NEXT:    [[LOAD_I_I_I:%.*]] = load volatile i32, ptr null, align 4
; CHECK-NEXT:    [[ICMP_I_I_I:%.*]] = icmp eq i32 [[LOAD_I_I_I]], 0
; CHECK-NEXT:    br i1 [[ICMP_I_I_I]], label %[[BB2_I_I_I:.*]], label %[[BB3_I_I_I:.*]]
; CHECK:       [[BB2_I_I_I]]:
; CHECK-NEXT:    br label %[[BB1_I1:.*]]
; CHECK:       [[BB1_I1]]:
; CHECK-NEXT:    [[LOAD_I_I_I2:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I_I2]], label %[[SPAM_EXIT_I:.*]], label %[[BB3_I_I_I3:.*]]
; CHECK:       [[BB3_I_I_I3]]:
; CHECK-NEXT:    call void @zot.4()
; CHECK-NEXT:    br label %[[SPAM_EXIT_I]]
; CHECK:       [[SPAM_EXIT_I]]:
; CHECK-NEXT:    [[ALLOCA_SROA_0_1_I:%.*]] = phi i64 [ 0, %[[BB3_I_I_I3]] ], [ 1, %[[BB1_I1]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i64 [[ALLOCA_SROA_0_1_I]] to ptr
; CHECK-NEXT:    store i32 0, ptr [[TMP0]], align 4
; CHECK-NEXT:    br label %[[BB1_I1]]
; CHECK:       [[EGGS_EXIT4:.*]]:
; CHECK-NEXT:    br label %[[SPAM_EXIT]]
; CHECK:       [[BB3_I_I_I]]:
; CHECK-NEXT:    [[LOAD_I_I5:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I5]], label %[[QUUX_EXIT:.*]], label %[[BB3_I_I6:.*]]
; CHECK:       [[BB3_I_I6]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[QUUX_EXIT]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    br label %[[SPAM_EXIT]]
; CHECK:       [[SPAM_EXIT]]:
; CHECK-NEXT:    [[ALLOCA_I_SROA_0_1:%.*]] = phi i64 [ 1, %[[BB1_I]] ], [ 0, %[[QUUX_EXIT]] ], [ 0, %[[EGGS_EXIT4]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[ALLOCA_I_SROA_0_1]] to ptr
; CHECK-NEXT:    store i32 0, ptr [[TMP1]], align 4
; CHECK-NEXT:    br label %[[BB1_I]]
; CHECK:       [[EGGS_EXIT:.*:]]
; CHECK-NEXT:    br label %[[BB1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    [[LOAD_I_I7:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I7]], label %[[WOBBLE_2_EXIT:.*]], label %[[BB3_I_I8:.*]]
; CHECK:       [[BB3_I_I8]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[WOBBLE_2_EXIT]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    br label %[[BB1]]
;
bb:
  %load = load volatile i32, ptr null, align 4
  %icmp = icmp eq i32 %load, 0
  br i1 %icmp, label %bb2, label %bb3

bb1:                                              ; preds = %wobble.2.exit, %eggs.exit
  ret void

bb2:                                              ; preds = %bb
  br label %bb1.i

bb1.i:                                            ; preds = %spam.exit, %bb2
  %load.i.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i, label %spam.exit, label %bb3.i.i

bb3.i.i:                                          ; preds = %bb1.i
  %load.i.i.i = load volatile i32, ptr null, align 4
  %icmp.i.i.i = icmp eq i32 %load.i.i.i, 0
  br i1 %icmp.i.i.i, label %bb2.i.i.i, label %bb3.i.i.i

bb2.i.i.i:                                        ; preds = %bb3.i.i
  br label %bb1.i1

bb1.i1:                                           ; preds = %spam.exit.i, %bb2.i.i.i
  %load.i.i.i2 = load volatile i1, ptr null, align 1
  br i1 %load.i.i.i2, label %spam.exit.i, label %bb3.i.i.i3

bb3.i.i.i3:                                       ; preds = %bb1.i1
  call void @zot.4()
  br label %spam.exit.i

spam.exit.i:                                      ; preds = %bb3.i.i.i3, %bb1.i1
  %alloca.sroa.0.1.i = phi i64 [ 0, %bb3.i.i.i3 ], [ 1, %bb1.i1 ]
  %0 = inttoptr i64 %alloca.sroa.0.1.i to ptr
  store i32 0, ptr %0, align 4
  br label %bb1.i1

eggs.exit4:                                       ; No predecessors!
  br label %spam.exit

bb3.i.i.i:                                        ; preds = %bb3.i.i
  %load.i.i5 = load volatile i1, ptr null, align 1
  br i1 %load.i.i5, label %quux.exit, label %bb3.i.i6

bb3.i.i6:                                         ; preds = %bb3.i.i.i
  call void @snork()
  unreachable

quux.exit:                                        ; preds = %bb3.i.i.i
  store ptr null, ptr null, align 8
  br label %spam.exit

spam.exit:                                        ; preds = %eggs.exit4, %quux.exit, %bb1.i
  %alloca.i.sroa.0.1 = phi i64 [ 1, %bb1.i ], [ 0, %quux.exit ], [ 0, %eggs.exit4 ]
  %1 = inttoptr i64 %alloca.i.sroa.0.1 to ptr
  store i32 0, ptr %1, align 4
  br label %bb1.i

eggs.exit:                                        ; No predecessors!
  br label %bb1

bb3:                                              ; preds = %bb
  %load.i.i7 = load volatile i1, ptr null, align 1
  br i1 %load.i.i7, label %wobble.2.exit, label %bb3.i.i8

bb3.i.i8:                                         ; preds = %bb3
  call void @snork()
  unreachable

wobble.2.exit:                                    ; preds = %bb3
  store ptr null, ptr null, align 8
  br label %bb1
}

define void @barney(ptr %arg) personality ptr null {
; CHECK-LABEL: define void @barney(
; CHECK-SAME: ptr [[ARG:%.*]]) personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD]], label %[[BB2:.*]], label %[[BB3:.*]]
; CHECK:       [[BB1:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[BB2]]:
; CHECK-NEXT:    store i64 1, ptr [[ARG]], align 8
; CHECK-NEXT:    br label %[[BB1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    [[LOAD_I:%.*]] = load volatile i32, ptr null, align 4
; CHECK-NEXT:    [[ICMP_I:%.*]] = icmp eq i32 [[LOAD_I]], 0
; CHECK-NEXT:    br i1 [[ICMP_I]], label %[[BB2_I:.*]], label %[[BB3_I:.*]]
; CHECK:       [[BB2_I]]:
; CHECK-NEXT:    br label %[[BB1_I_I:.*]]
; CHECK:       [[BB1_I_I]]:
; CHECK-NEXT:    [[LOAD_I_I_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I_I]], label %[[SPAM_EXIT_I:.*]], label %[[BB3_I_I_I:.*]]
; CHECK:       [[BB3_I_I_I]]:
; CHECK-NEXT:    [[LOAD_I_I_I_I:%.*]] = load volatile i32, ptr null, align 4
; CHECK-NEXT:    [[ICMP_I_I_I_I:%.*]] = icmp eq i32 [[LOAD_I_I_I_I]], 0
; CHECK-NEXT:    br i1 [[ICMP_I_I_I_I]], label %[[BB2_I_I_I_I:.*]], label %[[BB3_I_I_I_I:.*]]
; CHECK:       [[BB2_I_I_I_I]]:
; CHECK-NEXT:    br label %[[BB1_I1_I:.*]]
; CHECK:       [[BB1_I1_I]]:
; CHECK-NEXT:    [[LOAD_I_I_I2_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I_I2_I]], label %[[SPAM_EXIT_I_I:.*]], label %[[BB3_I_I_I3_I:.*]]
; CHECK:       [[BB3_I_I_I3_I]]:
; CHECK-NEXT:    call void @zot.4()
; CHECK-NEXT:    br label %[[SPAM_EXIT_I_I]]
; CHECK:       [[SPAM_EXIT_I_I]]:
; CHECK-NEXT:    [[ALLOCA_SROA_0_1_I_I:%.*]] = phi i64 [ 0, %[[BB3_I_I_I3_I]] ], [ 1, %[[BB1_I1_I]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i64 [[ALLOCA_SROA_0_1_I_I]] to ptr
; CHECK-NEXT:    store i32 0, ptr [[TMP0]], align 4
; CHECK-NEXT:    br label %[[BB1_I1_I]]
; CHECK:       [[BB3_I_I_I_I]]:
; CHECK-NEXT:    [[LOAD_I_I5_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I5_I]], label %[[QUUX_EXIT_I:.*]], label %[[BB3_I_I6_I:.*]]
; CHECK:       [[BB3_I_I6_I]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[QUUX_EXIT_I]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    br label %[[SPAM_EXIT_I]]
; CHECK:       [[SPAM_EXIT_I]]:
; CHECK-NEXT:    [[ALLOCA_I_SROA_0_1_I:%.*]] = phi i64 [ 1, %[[BB1_I_I]] ], [ 0, %[[QUUX_EXIT_I]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[ALLOCA_I_SROA_0_1_I]] to ptr
; CHECK-NEXT:    store i32 0, ptr [[TMP1]], align 4
; CHECK-NEXT:    br label %[[BB1_I_I]]
; CHECK:       [[BB3_I]]:
; CHECK-NEXT:    [[LOAD_I_I7_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I7_I]], label %[[BLAM_EXIT:.*]], label %[[BB3_I_I8_I:.*]]
; CHECK:       [[BB3_I_I8_I]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[BLAM_EXIT]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    br label %[[BB1]]
;
bb:
  %load = load volatile i1, ptr null, align 1
  br i1 %load, label %bb2, label %bb3

bb1:                                              ; preds = %blam.exit, %bb2
  ret void

bb2:                                              ; preds = %bb
  store i64 1, ptr %arg, align 8
  br label %bb1

bb3:                                              ; preds = %bb
  %load.i = load volatile i32, ptr null, align 4
  %icmp.i = icmp eq i32 %load.i, 0
  br i1 %icmp.i, label %bb2.i, label %bb3.i

bb2.i:                                            ; preds = %bb3
  br label %bb1.i.i

bb1.i.i:                                          ; preds = %spam.exit.i, %bb2.i
  %load.i.i.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i.i, label %spam.exit.i, label %bb3.i.i.i

bb3.i.i.i:                                        ; preds = %bb1.i.i
  %load.i.i.i.i = load volatile i32, ptr null, align 4
  %icmp.i.i.i.i = icmp eq i32 %load.i.i.i.i, 0
  br i1 %icmp.i.i.i.i, label %bb2.i.i.i.i, label %bb3.i.i.i.i

bb2.i.i.i.i:                                      ; preds = %bb3.i.i.i
  br label %bb1.i1.i

bb1.i1.i:                                         ; preds = %spam.exit.i.i, %bb2.i.i.i.i
  %load.i.i.i2.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i.i2.i, label %spam.exit.i.i, label %bb3.i.i.i3.i

bb3.i.i.i3.i:                                     ; preds = %bb1.i1.i
  call void @zot.4()
  br label %spam.exit.i.i

spam.exit.i.i:                                    ; preds = %bb3.i.i.i3.i, %bb1.i1.i
  %alloca.sroa.0.1.i.i = phi i64 [ 0, %bb3.i.i.i3.i ], [ 1, %bb1.i1.i ]
  %0 = inttoptr i64 %alloca.sroa.0.1.i.i to ptr
  store i32 0, ptr %0, align 4
  br label %bb1.i1.i

bb3.i.i.i.i:                                      ; preds = %bb3.i.i.i
  %load.i.i5.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i5.i, label %quux.exit.i, label %bb3.i.i6.i

bb3.i.i6.i:                                       ; preds = %bb3.i.i.i.i
  call void @snork()
  unreachable

quux.exit.i:                                      ; preds = %bb3.i.i.i.i
  store ptr null, ptr null, align 8
  br label %spam.exit.i

spam.exit.i:                                      ; preds = %quux.exit.i, %bb1.i.i
  %alloca.i.sroa.0.1.i = phi i64 [ 1, %bb1.i.i ], [ 0, %quux.exit.i ]
  %1 = inttoptr i64 %alloca.i.sroa.0.1.i to ptr
  store i32 0, ptr %1, align 4
  br label %bb1.i.i

bb3.i:                                            ; preds = %bb3
  %load.i.i7.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i7.i, label %blam.exit, label %bb3.i.i8.i

bb3.i.i8.i:                                       ; preds = %bb3.i
  call void @snork()
  unreachable

blam.exit:                                        ; preds = %bb3.i
  store ptr null, ptr null, align 8
  br label %bb1
}

define void @snork() personality ptr null {
; CHECK-LABEL: define void @snork() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I]], label %[[BB2_I:.*]], label %[[BB3_I:.*]]
; CHECK:       [[BB2_I]]:
; CHECK-NEXT:    br label %[[BARNEY_EXIT:.*]]
; CHECK:       [[BB3_I]]:
; CHECK-NEXT:    [[LOAD_I1:%.*]] = load volatile i32, ptr null, align 4
; CHECK-NEXT:    [[ICMP_I:%.*]] = icmp eq i32 [[LOAD_I1]], 0
; CHECK-NEXT:    br i1 [[ICMP_I]], label %[[BB2_I3:.*]], label %[[BLAM_EXIT:.*]]
; CHECK:       [[BB2_I3]]:
; CHECK-NEXT:    br label %[[BB1_I_I:.*]]
; CHECK:       [[BB1_I_I]]:
; CHECK-NEXT:    [[LOAD_I_I_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I_I]], label %[[SPAM_EXIT_I:.*]], label %[[BB3_I_I_I:.*]]
; CHECK:       [[BB3_I_I_I]]:
; CHECK-NEXT:    [[LOAD_I_I_I_I:%.*]] = load volatile i32, ptr null, align 4
; CHECK-NEXT:    [[ICMP_I_I_I_I:%.*]] = icmp eq i32 [[LOAD_I_I_I_I]], 0
; CHECK-NEXT:    br i1 [[ICMP_I_I_I_I]], label %[[BB2_I_I_I_I:.*]], label %[[BB3_I_I_I_I:.*]]
; CHECK:       [[BB2_I_I_I_I]]:
; CHECK-NEXT:    br label %[[BB1_I:.*]]
; CHECK:       [[BB1_I]]:
; CHECK-NEXT:    [[LOAD_I_I_I6:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I_I6]], label %[[SPAM_EXIT_I8:.*]], label %[[BB3_I_I_I7:.*]]
; CHECK:       [[BB3_I_I_I7]]:
; CHECK-NEXT:    call void @zot.4()
; CHECK-NEXT:    br label %[[SPAM_EXIT_I8]]
; CHECK:       [[SPAM_EXIT_I8]]:
; CHECK-NEXT:    [[ALLOCA_I_SROA_0_1:%.*]] = phi i64 [ 0, %[[BB3_I_I_I7]] ], [ 1, %[[BB1_I]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i64 [[ALLOCA_I_SROA_0_1]] to ptr
; CHECK-NEXT:    store i32 0, ptr [[TMP0]], align 4
; CHECK-NEXT:    br label %[[BB1_I]]
; CHECK:       [[EGGS_EXIT:.*]]:
; CHECK-NEXT:    br label %[[SPAM_EXIT_I]]
; CHECK:       [[BB3_I_I_I_I]]:
; CHECK-NEXT:    [[LOAD_I_I4:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I4]], label %[[QUUX_EXIT:.*]], label %[[BB3_I_I5:.*]]
; CHECK:       [[BB3_I_I5]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[QUUX_EXIT]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    br label %[[SPAM_EXIT_I]]
; CHECK:       [[SPAM_EXIT_I]]:
; CHECK-NEXT:    [[ALLOCA_I_I_SROA_0_1:%.*]] = phi i64 [ 1, %[[BB1_I_I]] ], [ 0, %[[QUUX_EXIT]] ], [ 0, %[[EGGS_EXIT]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[ALLOCA_I_I_SROA_0_1]] to ptr
; CHECK-NEXT:    store i32 0, ptr [[TMP1]], align 4
; CHECK-NEXT:    br label %[[BB1_I_I]]
; CHECK:       [[BLAM_EXIT]]:
; CHECK-NEXT:    [[LOAD_I_I:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD_I_I]], label %[[WOBBLE_2_EXIT:.*]], label %[[BB3_I_I:.*]]
; CHECK:       [[BB3_I_I]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[WOBBLE_2_EXIT]]:
; CHECK-NEXT:    br label %[[BARNEY_EXIT]]
; CHECK:       [[BARNEY_EXIT]]:
; CHECK-NEXT:    store ptr poison, ptr null, align 8
; CHECK-NEXT:    ret void
;
bb:
  %load.i = load volatile i1, ptr null, align 1
  br i1 %load.i, label %bb2.i, label %bb3.i

bb2.i:                                            ; preds = %bb
  store i64 1, ptr null, align 8
  br label %barney.exit

bb3.i:                                            ; preds = %bb
  %load.i1 = load volatile i32, ptr null, align 4
  %icmp.i = icmp eq i32 %load.i1, 0
  br i1 %icmp.i, label %bb2.i3, label %blam.exit

bb2.i3:                                           ; preds = %bb3.i
  br label %bb1.i.i

bb1.i.i:                                          ; preds = %spam.exit.i, %bb2.i3
  %load.i.i.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i.i, label %spam.exit.i, label %bb3.i.i.i

bb3.i.i.i:                                        ; preds = %bb1.i.i
  %load.i.i.i.i = load volatile i32, ptr null, align 4
  %icmp.i.i.i.i = icmp eq i32 %load.i.i.i.i, 0
  br i1 %icmp.i.i.i.i, label %bb2.i.i.i.i, label %bb3.i.i.i.i

bb2.i.i.i.i:                                      ; preds = %bb3.i.i.i
  br label %bb1.i

bb1.i:                                            ; preds = %spam.exit.i8, %bb2.i.i.i.i
  %load.i.i.i6 = load volatile i1, ptr null, align 1
  br i1 %load.i.i.i6, label %spam.exit.i8, label %bb3.i.i.i7

bb3.i.i.i7:                                       ; preds = %bb1.i
  call void @zot.4()
  br label %spam.exit.i8

spam.exit.i8:                                     ; preds = %bb1.i, %bb3.i.i.i7
  %alloca.i.sroa.0.1 = phi i64 [ 0, %bb3.i.i.i7 ], [ 1, %bb1.i ]
  %0 = inttoptr i64 %alloca.i.sroa.0.1 to ptr
  store i32 0, ptr %0, align 4
  br label %bb1.i

eggs.exit:                                        ; No predecessors!
  br label %spam.exit.i

bb3.i.i.i.i:                                      ; preds = %bb3.i.i.i
  %load.i.i4 = load volatile i1, ptr null, align 1
  br i1 %load.i.i4, label %quux.exit, label %bb3.i.i5

bb3.i.i5:                                         ; preds = %bb3.i.i.i.i
  call void @snork()
  unreachable

quux.exit:                                        ; preds = %bb3.i.i.i.i
  store ptr null, ptr null, align 8
  br label %spam.exit.i

spam.exit.i:                                      ; preds = %eggs.exit, %quux.exit, %bb1.i.i
  %alloca.i.i.sroa.0.1 = phi i64 [ 1, %bb1.i.i ], [ 0, %quux.exit ], [ 0, %eggs.exit ]
  %1 = inttoptr i64 %alloca.i.i.sroa.0.1 to ptr
  store i32 0, ptr %1, align 4
  br label %bb1.i.i

blam.exit:                                        ; preds = %bb3.i
  %load.i.i = load volatile i1, ptr null, align 1
  br i1 %load.i.i, label %wobble.2.exit, label %bb3.i.i

bb3.i.i:                                          ; preds = %blam.exit
  call void @snork()
  unreachable

wobble.2.exit:                                    ; preds = %blam.exit
  store ptr null, ptr null, align 8
  br label %barney.exit

barney.exit:                                      ; preds = %bb2.i, %wobble.2.exit
  ret void
}

define void @wibble(ptr %arg) personality ptr null {
; CHECK-LABEL: define void @wibble(
; CHECK-SAME: ptr [[ARG:%.*]]) personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD:%.*]] = load volatile i1, ptr null, align 1
; CHECK-NEXT:    br i1 [[LOAD]], label %[[BB2:.*]], label %[[BB3:.*]]
; CHECK:       [[BB1:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[BB2]]:
; CHECK-NEXT:    store ptr null, ptr [[ARG]], align 8
; CHECK-NEXT:    br label %[[BB1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[WOMBAT_EXIT:.*:]]
; CHECK-NEXT:    br label %[[BB1]]
;
bb:
  %load = load volatile i1, ptr null, align 1
  br i1 %load, label %bb2, label %bb3

bb1:                                              ; preds = %wombat.exit, %bb2
  ret void

bb2:                                              ; preds = %bb
  %inttoptr = inttoptr i64 0 to ptr
  store ptr %inttoptr, ptr %arg, align 8
  br label %bb1

bb3:                                              ; preds = %bb
  call void @snork()
  unreachable

wombat.exit:                                      ; No predecessors!
  br label %bb1
}

define i64 @zot.5(i64 %arg) {
; CHECK-LABEL: define i64 @zot.5(
; CHECK-SAME: i64 [[ARG:%.*]]) {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    ret i64 [[ARG]]
;
bb:
  ret i64 %arg
}

define i64 @foo() personality ptr null {
; CHECK-LABEL: define i64 @foo() personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    call void @snork()
; CHECK-NEXT:    unreachable
; CHECK:       [[WOMBAT_EXIT:.*:]]
; CHECK-NEXT:    ret i64 0
;
bb:
  call void @snork()
  unreachable

wombat.exit:                                      ; No predecessors!
  ret i64 0
}

define ptr @ham(ptr %arg) {
; CHECK-LABEL: define ptr @ham(
; CHECK-SAME: ptr [[ARG:%.*]]) {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I_I:%.*]] = load ptr, ptr [[ARG]], align 8
; CHECK-NEXT:    store ptr null, ptr [[ARG]], align 8
; CHECK-NEXT:    store i32 0, ptr [[LOAD_I_I]], align 4
; CHECK-NEXT:    ret ptr null
;
bb:
  %load.i.i = load ptr, ptr %arg, align 8
  store ptr null, ptr %arg, align 8
  store i32 0, ptr %load.i.i, align 4
  ret ptr null
}

define void @quux.6(ptr %arg) {
; CHECK-LABEL: define void @quux.6(
; CHECK-SAME: ptr [[ARG:%.*]]) {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[ARG]], align 8
; CHECK-NEXT:    store ptr null, ptr [[ARG]], align 8
; CHECK-NEXT:    store i32 0, ptr [[LOAD]], align 4
; CHECK-NEXT:    ret void
;
bb:
  %load = load ptr, ptr %arg, align 8
  store ptr null, ptr %arg, align 8
  store i32 0, ptr %load, align 4
  ret void
}

define ptr @foo.7(ptr %arg) {
; CHECK-LABEL: define ptr @foo.7(
; CHECK-SAME: ptr [[ARG:%.*]]) {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I:%.*]] = load ptr, ptr [[ARG]], align 8
; CHECK-NEXT:    store ptr null, ptr [[ARG]], align 8
; CHECK-NEXT:    store i32 0, ptr [[LOAD_I]], align 4
; CHECK-NEXT:    ret ptr null
;
bb:
  %load.i = load ptr, ptr %arg, align 8
  store ptr null, ptr %arg, align 8
  store i32 0, ptr %load.i, align 4
  ret ptr null
}

define ptr @ham.8(ptr %arg) personality ptr null {
; CHECK-LABEL: define ptr @ham.8(
; CHECK-SAME: ptr [[ARG:%.*]]) personality ptr null {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[LOAD_I_I_I:%.*]] = load ptr, ptr [[ARG]], align 8
; CHECK-NEXT:    store ptr null, ptr [[ARG]], align 8
; CHECK-NEXT:    store i32 0, ptr [[LOAD_I_I_I]], align 4
; CHECK-NEXT:    ret ptr null
;
bb:
  %load.i.i.i = load ptr, ptr %arg, align 8
  store ptr null, ptr %arg, align 8
  store i32 0, ptr %load.i.i.i, align 4
  ret ptr null
}

define ptr @foo.9(ptr %arg) {
; CHECK-LABEL: define ptr @foo.9(
; CHECK-SAME: ptr [[ARG:%.*]]) {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    store i64 1, ptr [[ARG]], align 8
; CHECK-NEXT:    ret ptr null
;
bb:
  store i64 1, ptr %arg, align 8
  ret ptr null
}


declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)
