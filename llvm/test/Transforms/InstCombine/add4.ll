; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

declare i32 @use32(i32)

define i64 @match_unsigned(i64 %x) {
; CHECK-LABEL: @match_unsigned(
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[X:%.*]], 19136
; CHECK-NEXT:    ret i64 [[UREM]]
;
  %t = urem i64 %x, 299
  %t1 = udiv i64 %x, 299
  %t2 = urem i64 %t1, 64
  %t3 = mul i64 %t2, 299
  %t4 = add i64 %t, %t3
  ret i64 %t4
}

define <2 x i64> @match_unsigned_vector(<2 x i64> %x) {
; CHECK-LABEL: @match_unsigned_vector(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[UREM:%.*]] = urem <2 x i64> [[X:%.*]], <i64 19136, i64 19136>
; CHECK-NEXT:    ret <2 x i64> [[UREM]]
;
bb:
  %tmp = urem <2 x i64> %x, <i64 299, i64 299>
  %tmp1 = udiv <2 x i64> %x, <i64 299, i64 299>
  %tmp2 = urem <2 x i64> %tmp1, <i64 64, i64 64>
  %tmp3 = mul <2 x i64> %tmp2, <i64 299, i64 299>
  %tmp4 = add <2 x i64> %tmp, %tmp3
  ret <2 x i64> %tmp4
}
define i64 @match_andAsRem_lshrAsDiv_shlAsMul(i64 %x) {
; CHECK-LABEL: @match_andAsRem_lshrAsDiv_shlAsMul(
; CHECK-NEXT:    [[UREM:%.*]] = urem i64 [[X:%.*]], 576
; CHECK-NEXT:    ret i64 [[UREM]]
;
  %t = and i64 %x, 63
  %t1 = lshr i64 %x, 6
  %t2 = urem i64 %t1, 9
  %t3 = shl i64 %t2, 6
  %t4 = add i64 %t, %t3
  ret i64 %t4
}

define i64 @match_signed(i64 %x) {
; CHECK-LABEL: @match_signed(
; CHECK-NEXT:    [[SREM1:%.*]] = srem i64 [[X:%.*]], 172224
; CHECK-NEXT:    ret i64 [[SREM1]]
;
  %t = srem i64 %x, 299
  %t1 = sdiv i64 %x, 299
  %t2 = srem i64 %t1, 64
  %t3 = sdiv i64 %x, 19136
  %t4 = srem i64 %t3, 9
  %t5 = mul i64 %t2, 299
  %t6 = add i64 %t, %t5
  %t7 = mul i64 %t4, 19136
  %t8 = add i64 %t6, %t7
  ret i64 %t8
}

define <2 x i64> @match_signed_vector(<2 x i64> %x) {
; CHECK-LABEL: @match_signed_vector(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[SREM1:%.*]] = srem <2 x i64> [[X:%.*]], <i64 172224, i64 172224>
; CHECK-NEXT:    ret <2 x i64> [[SREM1]]
;
bb:
  %tmp = srem <2 x i64> %x, <i64 299, i64 299>
  %tmp1 = sdiv <2 x i64> %x, <i64 299, i64 299>
  %tmp2 = srem <2 x i64> %tmp1, <i64 64, i64 64>
  %tmp3 = sdiv <2 x i64> %x, <i64 19136, i64 19136>
  %tmp4 = srem <2 x i64> %tmp3, <i64 9, i64 9>
  %tmp5 = mul <2 x i64> %tmp2, <i64 299, i64 299>
  %tmp6 = add <2 x i64> %tmp, %tmp5
  %tmp7 = mul <2 x i64> %tmp4, <i64 19136, i64 19136>
  %tmp8 = add <2 x i64> %tmp6, %tmp7
  ret <2 x i64> %tmp8
}

define i64 @not_match_inconsistent_signs(i64 %x) {
; CHECK-LABEL: @not_match_inconsistent_signs(
; CHECK-NEXT:    [[T:%.*]] = urem i64 [[X:%.*]], 299
; CHECK-NEXT:    [[T1:%.*]] = sdiv i64 [[X]], 299
; CHECK-NEXT:    [[T2:%.*]] = and i64 [[T1]], 63
; CHECK-NEXT:    [[T3:%.*]] = mul nuw nsw i64 [[T2]], 299
; CHECK-NEXT:    [[T4:%.*]] = add nuw nsw i64 [[T]], [[T3]]
; CHECK-NEXT:    ret i64 [[T4]]
;
  %t = urem i64 %x, 299
  %t1 = sdiv i64 %x, 299
  %t2 = urem i64 %t1, 64
  %t3 = mul i64 %t2, 299
  %t4 = add i64 %t, %t3
  ret i64 %t4
}

define i64 @not_match_inconsistent_values(i64 %x) {
; CHECK-LABEL: @not_match_inconsistent_values(
; CHECK-NEXT:    [[T:%.*]] = urem i64 [[X:%.*]], 299
; CHECK-NEXT:    [[T1:%.*]] = udiv i64 [[X]], 29
; CHECK-NEXT:    [[T2:%.*]] = and i64 [[T1]], 63
; CHECK-NEXT:    [[T3:%.*]] = mul nuw nsw i64 [[T2]], 299
; CHECK-NEXT:    [[T4:%.*]] = add nuw nsw i64 [[T]], [[T3]]
; CHECK-NEXT:    ret i64 [[T4]]
;
  %t = urem i64 %x, 299
  %t1 = udiv i64 %x, 29
  %t2 = urem i64 %t1, 64
  %t3 = mul i64 %t2, 299
  %t4 = add i64 %t, %t3
  ret i64 %t4
}

define i32 @not_match_overflow(i32 %x) {
; CHECK-LABEL: @not_match_overflow(
; CHECK-NEXT:    [[X_FR:%.*]] = freeze i32 [[X:%.*]]
; CHECK-NEXT:    [[T:%.*]] = urem i32 [[X_FR]], 299
; CHECK-NEXT:    [[TMP1:%.*]] = urem i32 [[X_FR]], 299
; CHECK-NEXT:    [[T3:%.*]] = sub nuw i32 [[X_FR]], [[TMP1]]
; CHECK-NEXT:    [[T4:%.*]] = add i32 [[T]], [[T3]]
; CHECK-NEXT:    ret i32 [[T4]]
;
  %t = urem i32 %x, 299
  %t1 = udiv i32 %x, 299
  %t2 = urem i32 %t1, 147483647
  %t3 = mul i32 %t2, 299
  %t4 = add i32 %t, %t3
  ret i32 %t4
}

; (x + (-1)) + (x * 5) --> (x * 6) + (-1)
define i8 @mul_add_common_factor_0(i8 %x) {
; CHECK-LABEL: @mul_add_common_factor_0(
; CHECK-NEXT:    [[A1:%.*]] = mul i8 [[X:%.*]], 6
; CHECK-NEXT:    [[TMP1:%.*]] = add i8 [[A1]], -1
; CHECK-NEXT:    ret i8 [[TMP1]]
;
  %a0 = add i8 %x, -1
  %m = mul i8 %x, 5
  %a1 = add i8 %a0, %m ; the mul operand is the right operand, should swap the operand
  ret i8 %a1
}

; (x * 4) + (x - 1) --> (x * 5) + (-1)
define i16 @mul_add_common_factor_1(i16 %x) {
; CHECK-LABEL: @mul_add_common_factor_1(
; CHECK-NEXT:    [[A1:%.*]] = mul i16 [[X:%.*]], 5
; CHECK-NEXT:    [[TMP1:%.*]] = add i16 [[A1]], -1
; CHECK-NEXT:    ret i16 [[TMP1]]
;
  %a0 = add i16 %x, -1
  %m = mul i16 %x, 4
  %a1 = add i16 %m, %a0 ; the mul operand is the left operand
  ret i16 %a1
}

; Negative test: y is not a const for (x + y) + (x * 4) --> (x * 5) + y
define i32 @mul_add_common_factor_2(i32 %x, i32 %y) {
; CHECK-LABEL: @mul_add_common_factor_2(
; CHECK-NEXT:    [[A0:%.*]] = add i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[M:%.*]] = shl i32 [[X]], 2
; CHECK-NEXT:    [[A1:%.*]] = add i32 [[A0]], [[M]]
; CHECK-NEXT:    ret i32 [[A1]]
;
  %a0 = add i32 %x, %y
  %m = mul i32 %x, 4
  %a1 = add i32 %a0, %m
  ret i32 %a1
}

; Negative test: y is not a const for (y + x) + (x * 4) --> (x * 5) + y
define i32 @mul_add_common_factor_2_commute(i32 %x, i32 %y) {
; CHECK-LABEL: @mul_add_common_factor_2_commute(
; CHECK-NEXT:    [[A0:%.*]] = add i32 [[Y:%.*]], [[X:%.*]]
; CHECK-NEXT:    [[M:%.*]] = shl i32 [[X]], 2
; CHECK-NEXT:    [[A1:%.*]] = add i32 [[A0]], [[M]]
; CHECK-NEXT:    ret i32 [[A1]]
;
  %a0 = add i32 %y, %x
  %m = mul i32 %x, 4
  %a1 = add i32 %a0, %m
  ret i32 %a1
}

; Negative test: t is not a const for (x + 2) + (x * t) --> (t + 1) * x + 2
define i128 @mul_add_common_factor_3(i128 %x, i128 %t) {
; CHECK-LABEL: @mul_add_common_factor_3(
; CHECK-NEXT:    [[A0:%.*]] = add i128 [[X:%.*]], 2
; CHECK-NEXT:    [[M:%.*]] = mul i128 [[X]], [[T:%.*]]
; CHECK-NEXT:    [[A1:%.*]] = add i128 [[A0]], [[M]]
; CHECK-NEXT:    ret i128 [[A1]]
;
  %a0 = add i128 %x, 2
  %m = mul i128 %x, %t
  %a1 = add i128 %a0, %m
  ret i128 %a1
}

; Negative test: t is not a const for (x + 2) + (t * x) --> (t + 1) * x + 2
define i128 @mul_add_common_factor_3_commute(i128 %x, i128 %t) {
; CHECK-LABEL: @mul_add_common_factor_3_commute(
; CHECK-NEXT:    [[A0:%.*]] = add i128 [[X:%.*]], 2
; CHECK-NEXT:    [[M:%.*]] = mul i128 [[T:%.*]], [[X]]
; CHECK-NEXT:    [[A1:%.*]] = add i128 [[A0]], [[M]]
; CHECK-NEXT:    ret i128 [[A1]]
;
  %a0 = add i128 %x, 2
  %m = mul i128 %t, %x
  %a1 = add i128 %a0, %m
  ret i128 %a1
}

; Negative test: The transformation should not create more instructions
define i32 @mul_add_common_factor_4(i32 %x) {
; CHECK-LABEL: @mul_add_common_factor_4(
; CHECK-NEXT:    [[A0:%.*]] = add i32 [[X:%.*]], -1
; CHECK-NEXT:    [[M:%.*]] = shl i32 [[X]], 2
; CHECK-NEXT:    call void @use32(i32 [[A0]])
; CHECK-NEXT:    [[A1:%.*]] = add i32 [[M]], [[A0]]
; CHECK-NEXT:    ret i32 [[A1]]
;
  %a0 = add i32 %x, -1
  %m = mul i32 %x, 4
  call void @use32(i32 %a0) ; an extra use
  %a1 = add i32 %m, %a0
  ret i32 %a1
}

; (x * 4) + (x + 3) --> (x * 5) + 3
define <2 x i8> @mul_add_common_factor_5(<2 x i8> %x) {
; CHECK-LABEL: @mul_add_common_factor_5(
; CHECK-NEXT:    [[A1:%.*]] = mul <2 x i8> [[X:%.*]], <i8 5, i8 5>
; CHECK-NEXT:    [[TMP1:%.*]] = add <2 x i8> [[A1]], <i8 3, i8 3>
; CHECK-NEXT:    ret <2 x i8> [[TMP1]]
;
  %a0 = add <2 x i8> %x, <i8 3, i8 3>
  %m = mul <2 x i8> %x, <i8 4, i8 4> ; vector type
  %a1 = add <2 x i8> %m, %a0
  ret <2 x i8> %a1
}

; (x << 2) + (x - 1) --> (x * 5) + (-1)
define i16 @shl_add_common_factor_1(i16 %x) {
; CHECK-LABEL: @shl_add_common_factor_1(
; CHECK-NEXT:    [[A1:%.*]] = mul i16 [[X:%.*]], 5
; CHECK-NEXT:    [[TMP1:%.*]] = add i16 [[A1]], -1
; CHECK-NEXT:    ret i16 [[TMP1]]
;
  %a0 = add i16 %x, -1
  %s = shl i16 %x, 2
  %a1 = add i16 %s, %a0 ; the shl operand is the left operand
  ret i16 %a1
}

; Negative test: y is not a const for (y + x) + (x << 2)
define i32 @shl_add_common_factor_2(i32 %x, i32 %y) {
; CHECK-LABEL: @shl_add_common_factor_2(
; CHECK-NEXT:    [[A0:%.*]] = add i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[S:%.*]] = shl i32 [[X]], 2
; CHECK-NEXT:    [[A1:%.*]] = add i32 [[A0]], [[S]]
; CHECK-NEXT:    ret i32 [[A1]]
;
  %a0 = add i32 %x, %y
  %s = shl i32 %x, 2
  %a1 = add i32 %a0, %s ; the shl operand is the right operand
  ret i32 %a1
}

; Negative test: y is not a const for (y + x) + (x << 2)
define i32 @shl_add_common_factor_2_commute(i32 %x, i32 %y) {
; CHECK-LABEL: @shl_add_common_factor_2_commute(
; CHECK-NEXT:    [[A0:%.*]] = add i32 [[Y:%.*]], [[X:%.*]]
; CHECK-NEXT:    [[S:%.*]] = shl i32 [[X]], 2
; CHECK-NEXT:    [[A1:%.*]] = add i32 [[A0]], [[S]]
; CHECK-NEXT:    ret i32 [[A1]]
;
  %a0 = add i32 %y, %x ; swap the operand
  %s = shl i32 %x, 2
  %a1 = add i32 %a0, %s
  ret i32 %a1
}

; Negative test: The transformation should not create more instructions
define i32 @shl_add_common_factor_4(i32 %x) {
; CHECK-LABEL: @shl_add_common_factor_4(
; CHECK-NEXT:    [[A0:%.*]] = add i32 [[X:%.*]], -1
; CHECK-NEXT:    [[S:%.*]] = shl i32 [[X]], 2
; CHECK-NEXT:    call void @use32(i32 [[S]])
; CHECK-NEXT:    [[A1:%.*]] = add i32 [[S]], [[A0]]
; CHECK-NEXT:    ret i32 [[A1]]
;
  %a0 = add i32 %x, -1
  %s = shl i32 %x, 2
  call void @use32(i32 %s) ; an extra use
  %a1 = add i32 %s, %a0
  ret i32 %a1
}

; (x << 2) + (x + 3) --> (x * 5) + 3
define <2 x i64> @shl_add_common_factor_5(<2 x i64> %x) {
; CHECK-LABEL: @shl_add_common_factor_5(
; CHECK-NEXT:    [[A1:%.*]] = mul <2 x i64> [[X:%.*]], <i64 5, i64 5>
; CHECK-NEXT:    [[TMP1:%.*]] = add <2 x i64> [[A1]], <i64 3, i64 3>
; CHECK-NEXT:    ret <2 x i64> [[TMP1]]
;
  %a0 = add <2 x i64> %x, <i64 3, i64 3>
  %s = shl <2 x i64> %x, <i64 2, i64 2> ; vector type
  %a1 = add <2 x i64> %s, %a0
  ret <2 x i64> %a1
}
