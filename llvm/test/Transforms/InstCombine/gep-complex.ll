; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=instcombine < %s | FileCheck %s

%"class.std::__1::complex" = type { float, float }
@mdlComplex = dso_local global [10000 x %"class.std::__1::complex"] zeroinitializer, align 4

define float @decompose_complex_scalar(ptr %array) {
; CHECK-LABEL: @decompose_complex_scalar(
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAY:%.*]], align 4
; CHECK-NEXT:    [[SEXTVAL_SCALE:%.*]] = shl nsw i32 [[VAL]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[SEXTVAL_SCALE]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr @mdlComplex, i64 [[TMP1]]
; CHECK-NEXT:    [[RES:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret float [[RES]]
;
  %val = load i32, ptr %array, align 4
  %sextVal = sext i32 %val to i64
  %arrayidx = getelementptr inbounds [10000 x %"class.std::__1::complex"], ptr @mdlComplex, i32 0, i64 %sextVal
  %res = load float, ptr %arrayidx, align 4
  ret float %res
}

define <4 x ptr> @decompose_complex_vector(ptr %array) {
; CHECK-LABEL: @decompose_complex_vector(
; CHECK-NEXT:    [[VAL:%.*]] = load <4 x i32>, ptr [[ARRAY:%.*]], align 4
; CHECK-NEXT:    [[SEXTVAL_SCALE:%.*]] = shl nsw <4 x i32> [[VAL]], <i32 1, i32 1, i32 1, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = sext <4 x i32> [[SEXTVAL_SCALE]] to <4 x i64>
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr @mdlComplex, <4 x i64> [[TMP1]]
; CHECK-NEXT:    ret <4 x ptr> [[ARRAYIDX]]
;
  %val = load <4 x i32>, ptr %array, align 4
  %sextVal = sext <4 x i32> %val to <4 x i64>
  %arrayidx = getelementptr inbounds [10000 x %"class.std::__1::complex"], ptr @mdlComplex, i32 0, <4 x i64> %sextVal
  ret <4 x ptr> %arrayidx
}

