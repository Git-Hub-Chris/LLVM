; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=vector-widen -S -vw-override-target-consider-to-widen=1 -vw-max-instr-distance=2 < %s | FileCheck %s

define <4 x i32> @foo(float %a0, float %a1, float %a2, float %a3, ptr %ptr1, ptr %ptr2) {
; CHECK-LABEL: @foo(
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x float>, ptr [[PTR1:%.*]], align 16
; CHECK-NEXT:    [[TMP2:%.*]] = load <4 x float>, ptr [[PTR1]], align 16
; CHECK-NEXT:    [[TMP3:%.*]] = call <8 x float> @llvm.vector.insert.v8f32.v4f32(<8 x float> undef, <4 x float> [[TMP2]], i64 0)
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x float> @llvm.vector.insert.v8f32.v4f32(<8 x float> [[TMP3]], <4 x float> [[TMP1]], i64 4)
; CHECK-NEXT:    [[TMP5:%.*]] = fptosi <8 x float> [[TMP4]] to <8 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = call <4 x i32> @llvm.vector.extract.v4i32.v8i32(<8 x i32> [[TMP5]], i64 0)
; CHECK-NEXT:    [[TMP7:%.*]] = call <4 x i32> @llvm.vector.extract.v4i32.v8i32(<8 x i32> [[TMP5]], i64 4)
; CHECK-NEXT:    [[TMP8:%.*]] = insertelement <4 x float> poison, float [[A0:%.*]], i32 0
; CHECK-NEXT:    [[TMP9:%.*]] = insertelement <4 x float> [[TMP8]], float [[A1:%.*]], i32 1
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <4 x float> [[TMP9]], float [[A2:%.*]], i32 2
; CHECK-NEXT:    [[TMP11:%.*]] = insertelement <4 x float> [[TMP10]], float [[A3:%.*]], i32 3
; CHECK-NEXT:    [[TMP12:%.*]] = fptosi <4 x float> [[TMP11]] to <4 x i32>
; CHECK-NEXT:    store <4 x i32> [[TMP6]], ptr [[PTR1]], align 2
; CHECK-NEXT:    store <4 x i32> [[TMP12]], ptr [[PTR2:%.*]], align 2
; CHECK-NEXT:    ret <4 x i32> [[TMP7]]
;
  %1 = load <4 x float>, ptr %ptr1
  %2 = fptosi <4 x float> %1 to <4 x i32>
  %3 = load <4 x float>, ptr %ptr1
  %4 = fptosi <4 x float> %3 to <4 x i32>
  %5 = insertelement <4 x float> poison, float %a0, i32 0
  %6 = insertelement <4 x float> %5, float %a1, i32 1
  %7 = insertelement <4 x float> %6, float %a2, i32 2
  %8 = insertelement <4 x float> %7, float %a3, i32 3
  %9 = fptosi <4 x float> %8 to <4 x i32>
  store <4 x i32> %4, ptr %ptr1, align 2
  store <4 x i32> %9, ptr %ptr2, align 2
  ret <4 x i32> %2
}

define <4 x i32> @bar(<4 x float> %a0, ptr %ptr1, ptr %ptr2) {
; CHECK-LABEL: @bar(
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x float>, ptr [[PTR1:%.*]], align 16
; CHECK-NEXT:    [[TMP2:%.*]] = fptosi <4 x float> [[TMP1]] to <4 x i32>
; CHECK-NEXT:    [[TMP3:%.*]] = load <4 x float>, ptr [[PTR1]], align 16
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x float> @llvm.vector.insert.v8f32.v4f32(<8 x float> undef, <4 x float> [[A0:%.*]], i64 0)
; CHECK-NEXT:    [[TMP5:%.*]] = call <8 x float> @llvm.vector.insert.v8f32.v4f32(<8 x float> [[TMP4]], <4 x float> [[TMP3]], i64 4)
; CHECK-NEXT:    [[TMP6:%.*]] = fptosi <8 x float> [[TMP5]] to <8 x i32>
; CHECK-NEXT:    [[TMP7:%.*]] = call <4 x i32> @llvm.vector.extract.v4i32.v8i32(<8 x i32> [[TMP6]], i64 0)
; CHECK-NEXT:    [[TMP8:%.*]] = call <4 x i32> @llvm.vector.extract.v4i32.v8i32(<8 x i32> [[TMP6]], i64 4)
; CHECK-NEXT:    store <4 x i32> [[TMP8]], ptr [[PTR1]], align 2
; CHECK-NEXT:    store <4 x i32> [[TMP7]], ptr [[PTR2:%.*]], align 2
; CHECK-NEXT:    ret <4 x i32> [[TMP2]]
;

  %1 = load <4 x float>, ptr %ptr1
  %2 = fptosi <4 x float> %1 to <4 x i32>
  %3 = load <4 x float>, ptr %ptr1
  %4 = fptosi <4 x float> %3 to <4 x i32>
  %5 = fptosi <4 x float> %a0 to <4 x i32>
  store <4 x i32> %4, ptr %ptr1, align 2
  store <4 x i32> %5, ptr %ptr2, align 2
  ret <4 x i32> %2
}
