; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals all --version 4
; RUN: opt -passes=pgo-instr-gen,pgo-ctx-instr-lower -profile-context-root=an_entrypoint \
; RUN:   -S < %s | FileCheck %s

declare void @bar()

;.
; CHECK: @__llvm_profile_raw_version = hidden constant i64 360287970189639690, comdat
; CHECK: @__profn_foo = private constant [3 x i8] c"foo"
; CHECK: @__profn_an_entrypoint = private constant [13 x i8] c"an_entrypoint"
; CHECK: @an_entrypoint_ctx_root = global { ptr, ptr, ptr, i8 } zeroinitializer
; CHECK: @__llvm_instrprof_callsite = external hidden thread_local global ptr
; CHECK: @__llvm_instrprof_expected_callee = external hidden thread_local global ptr
;.
define void @foo(i32 %a) {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: i32 [[A:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @__llvm_instrprof_get_context(ptr @foo, i64 6699318081062747564, i32 2, i32 1)
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = and i64 [[TMP2]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = call ptr @llvm.threadlocal.address.p0(ptr @__llvm_instrprof_expected_callee)
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr ptr, ptr [[TMP4]], i64 [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = call ptr @llvm.threadlocal.address.p0(ptr @__llvm_instrprof_callsite)
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i32, ptr [[TMP6]], i64 [[TMP3]]
; CHECK-NEXT:    [[TMP8:%.*]] = and i64 [[TMP2]], -2
; CHECK-NEXT:    [[TMP9:%.*]] = inttoptr i64 [[TMP8]] to ptr
; CHECK-NEXT:    [[T:%.*]] = icmp eq i32 [[A]], 0
; CHECK-NEXT:    br i1 [[T]], label [[YES:%.*]], label [[NO:%.*]]
; CHECK:       yes:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr { { i64, ptr, i32, i32 }, [2 x i64], [1 x ptr] }, ptr [[TMP9]], i32 0, i32 1, i32 1
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, ptr [[TMP10]], align 4
; CHECK-NEXT:    [[TMP12:%.*]] = add i64 [[TMP11]], 1
; CHECK-NEXT:    store i64 [[TMP12]], ptr [[TMP10]], align 4
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       no:
; CHECK-NEXT:    store volatile ptr @bar, ptr [[TMP5]], align 8
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr { { i64, ptr, i32, i32 }, [2 x i64], [1 x ptr] }, ptr [[TMP1]], i32 0, i32 2, i32 0
; CHECK-NEXT:    store volatile ptr [[TMP13]], ptr [[TMP7]], align 8
; CHECK-NEXT:    call void @bar()
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
  %t = icmp eq i32 %a, 0
  br i1 %t, label %yes, label %no
yes:
  br label %exit
no:
  call void @bar()
  br label %exit
exit:
  ret void
}

define void @an_entrypoint(i32 %a) {
; CHECK-LABEL: define void @an_entrypoint(
; CHECK-SAME: i32 [[A:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @__llvm_instrprof_start_context(ptr @an_entrypoint_ctx_root, i64 4909520559318251808, i32 2, i32 0)
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = and i64 [[TMP2]], -2
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
; CHECK-NEXT:    [[T:%.*]] = icmp eq i32 [[A]], 0
; CHECK-NEXT:    br i1 [[T]], label [[YES:%.*]], label [[NO:%.*]]
; CHECK:       yes:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr { { i64, ptr, i32, i32 }, [2 x i64], [0 x ptr] }, ptr [[TMP4]], i32 0, i32 1, i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = add i64 [[TMP6]], 1
; CHECK-NEXT:    store i64 [[TMP7]], ptr [[TMP5]], align 4
; CHECK-NEXT:    call void @__llvm_instrprof_release_context(ptr @an_entrypoint_ctx_root)
; CHECK-NEXT:    ret void
; CHECK:       no:
; CHECK-NEXT:    call void @__llvm_instrprof_release_context(ptr @an_entrypoint_ctx_root)
; CHECK-NEXT:    ret void
;
  %t = icmp eq i32 %a, 0
  br i1 %t, label %yes, label %no

yes:
  ret void
no:
  ret void
}
;.
; CHECK: attributes #[[ATTR0:[0-9]+]] = { nounwind }
; CHECK: attributes #[[ATTR1:[0-9]+]] = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
;.
