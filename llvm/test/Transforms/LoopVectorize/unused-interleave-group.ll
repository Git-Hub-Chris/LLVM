; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -passes=loop-vectorize -S -force-vector-width=4 -enable-interleaved-mem-accesses=true -debug-only=loop-vectorize < %s 2>&1 | FileCheck %s

; This test checks if an unused interleave group is removed by removeDeadRecipes.

%struct.foo = type { ptr, ptr }

define void @test_unused_interleave(ptr %src) {
; CHECK-LABEL: Checking a loop in 'test_unused_interleave'
; CHECK: VPlan 'Initial VPlan for VF={4},UF>=1' {
; CHECK-NEXT: Live-in vp<%0> = vector-trip-count
; CHECK-NEXT: Live-in ir<0> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT: vector.ph:
; CHECK-NEXT: Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT: <x1> vector loop: {
; CHECK-NEXT:   vector.body:
; CHECK-NEXT:     EMIT vp<%1> = CANONICAL-INDUCTION ir<0>, vp<%6>
; CHECK-NEXT:     vp<%2> = SCALAR-STEPS vp<%1>, ir<1>
; CHECK-NEXT:     CLONE ir<%next19.i.i> = getelementptr inbounds ir<%src>, vp<%2>, ir<0>
; CHECK-NEXT:     INTERLEAVE-GROUP with factor 2 at %load_p1, ir<%next19.i.i>
; CHECK-NEXT:       ir<%load_p1> = load from index 0
; CHECK-NEXT:       ir<%load_p2> = load from index 1
; CHECK-NEXT:     EMIT vp<%6> = VF * UF + nuw vp<%1>
; CHECK-NEXT:     EMIT branch-on-count vp<%6>, vp<%0>
; CHECK-NEXT:   No successors
; CHECK-NEXT: }
entry:
  br label %for.body14.i.i

for.body14.i.i:
  %i.1424.i.i = phi i32 [ %inc21.i.i, %for.body14.i.i ], [ 0, %entry ]
  %next19.i.i = getelementptr inbounds %struct.foo, ptr %src, i32 %i.1424.i.i, i32 0
  %load_p1 = load ptr, ptr %next19.i.i, align 4
  %arrayidx15.i.i1427 = getelementptr inbounds %struct.foo, ptr %src, i32 %i.1424.i.i
  %val.i.i = getelementptr inbounds %struct.foo, ptr %arrayidx15.i.i1427, i32 0, i32 1
  %load_p2 = load ptr, ptr %val.i.i, align 4
  %inc21.i.i = add nuw nsw i32 %i.1424.i.i, 1
  %exitcond438.i.i = icmp eq i32 %inc21.i.i, 0
  br i1 %exitcond438.i.i, label %for.end22.i.i, label %for.body14.i.i

for.end22.i.i:
  unreachable
}
