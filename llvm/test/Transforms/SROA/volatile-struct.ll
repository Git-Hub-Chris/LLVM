; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes='sroa' -S < %s | FileCheck %s --check-prefixes=CHECK,SROA
; These are the critical passes to get the clang-seen behavior.
; RUN: opt -passes='early-cse,sroa,instcombine' -S < %s | FileCheck %s --check-prefixes=CHECK,CLANG

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

%struct.F = type { i32 }

define dso_local void @Write(ptr noundef %f, i32 %e.coerce) {
; CHECK-LABEL: define dso_local void @Write
; CHECK-SAME: (ptr noundef [[F:%.*]], i32 [[E_COERCE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store volatile i32 [[E_COERCE]], ptr [[F]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %e = alloca %struct.F, align 4
  %f.addr = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %struct.F, ptr %e, i32 0, i32 0
  store i32 %e.coerce, ptr %coerce.dive, align 4
  store ptr %f, ptr %f.addr, align 8
  %0 = load ptr, ptr %f.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %0, ptr align 4 %e, i64 4, i8 1)
  ret void
}

declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i8 immarg)

define dso_local i32 @Read(ptr noundef %f) {
; CHECK-LABEL: define dso_local i32 @Read
; CHECK-SAME: (ptr noundef [[F:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[RETVAL_SROA_0_0_COPYLOAD:%.*]] = load volatile i32, ptr [[F]], align 4
; CHECK-NEXT:    ret i32 [[RETVAL_SROA_0_0_COPYLOAD]]
;
entry:
  %retval = alloca %struct.F, align 4
  %f.addr = alloca ptr, align 8
  store ptr %f, ptr %f.addr, align 8
  %0 = load ptr, ptr %f.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %retval, ptr align 4 %0, i64 4, i8 2)
  %coerce.dive = getelementptr inbounds %struct.F, ptr %retval, i32 0, i32 0
  %1 = load i32, ptr %coerce.dive, align 4
  ret i32 %1
}

define dso_local void @Init(ptr noundef %f, i32 noundef %a, i32 noundef %b) {
; SROA-LABEL: define dso_local void @Init
; SROA-SAME: (ptr noundef [[F:%.*]], i32 noundef [[A:%.*]], i32 noundef [[B:%.*]]) {
; SROA-NEXT:  entry:
; SROA-NEXT:    [[BF_VALUE:%.*]] = and i32 [[A]], 3
; SROA-NEXT:    [[BF_CLEAR:%.*]] = and i32 undef, -4
; SROA-NEXT:    [[BF_SET:%.*]] = or i32 [[BF_CLEAR]], [[BF_VALUE]]
; SROA-NEXT:    [[BF_VALUE2:%.*]] = and i32 [[B]], 3
; SROA-NEXT:    [[BF_SHL:%.*]] = shl i32 [[BF_VALUE2]], 2
; SROA-NEXT:    [[BF_CLEAR3:%.*]] = and i32 [[BF_SET]], -13
; SROA-NEXT:    [[BF_SET4:%.*]] = or i32 [[BF_CLEAR3]], [[BF_SHL]]
; SROA-NEXT:    [[BF_CLEAR6:%.*]] = and i32 [[BF_SET4]], 15
; SROA-NEXT:    [[BF_SET7:%.*]] = or i32 [[BF_CLEAR6]], 0
; SROA-NEXT:    store volatile i32 [[BF_SET7]], ptr [[F]], align 4
; SROA-NEXT:    ret void
;
; CLANG-LABEL: define dso_local void @Init
; CLANG-SAME: (ptr noundef [[F:%.*]], i32 noundef [[A:%.*]], i32 noundef [[B:%.*]]) {
; CLANG-NEXT:  entry:
; CLANG-NEXT:    [[BF_VALUE:%.*]] = and i32 [[A]], 3
; CLANG-NEXT:    [[BF_VALUE2:%.*]] = shl i32 [[B]], 2
; CLANG-NEXT:    [[BF_SHL:%.*]] = and i32 [[BF_VALUE2]], 12
; CLANG-NEXT:    [[BF_SET4:%.*]] = or i32 [[BF_VALUE]], [[BF_SHL]]
; CLANG-NEXT:    store volatile i32 [[BF_SET4]], ptr [[F]], align 4
; CLANG-NEXT:    ret void
;
entry:
  %f.addr = alloca ptr, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %.compoundliteral = alloca %struct.F, align 4
  store ptr %f, ptr %f.addr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load ptr, ptr %f.addr, align 8
  %1 = load i32, ptr %a.addr, align 4
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.value = and i32 %1, 3
  %bf.clear = and i32 %bf.load, -4
  %bf.set = or i32 %bf.clear, %bf.value
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %2 = load i32, ptr %b.addr, align 4
  %bf.load1 = load i32, ptr %.compoundliteral, align 4
  %bf.value2 = and i32 %2, 3
  %bf.shl = shl i32 %bf.value2, 2
  %bf.clear3 = and i32 %bf.load1, -13
  %bf.set4 = or i32 %bf.clear3, %bf.shl
  store i32 %bf.set4, ptr %.compoundliteral, align 4
  %bf.load5 = load i32, ptr %.compoundliteral, align 4
  %bf.clear6 = and i32 %bf.load5, 15
  %bf.set7 = or i32 %bf.clear6, 0
  store i32 %bf.set7, ptr %.compoundliteral, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %0, ptr align 4 %.compoundliteral, i64 4, i8 1)
  ret void
}

define dso_local void @Set(ptr noundef %f, i32 noundef %a, i32 noundef %b) {
; SROA-LABEL: define dso_local void @Set
; SROA-SAME: (ptr noundef [[F:%.*]], i32 noundef [[A:%.*]], i32 noundef [[B:%.*]]) {
; SROA-NEXT:  entry:
; SROA-NEXT:    [[TMP_SROA_0_0_COPYLOAD:%.*]] = load volatile i32, ptr [[F]], align 4
; SROA-NEXT:    [[BF_VALUE:%.*]] = and i32 [[A]], 3
; SROA-NEXT:    [[BF_CLEAR:%.*]] = and i32 [[TMP_SROA_0_0_COPYLOAD]], -4
; SROA-NEXT:    [[BF_SET:%.*]] = or i32 [[BF_CLEAR]], [[BF_VALUE]]
; SROA-NEXT:    [[BF_RESULT_SHL:%.*]] = shl i32 [[BF_VALUE]], 30
; SROA-NEXT:    [[BF_RESULT_ASHR:%.*]] = ashr i32 [[BF_RESULT_SHL]], 30
; SROA-NEXT:    [[BF_VALUE2:%.*]] = and i32 [[B]], 3
; SROA-NEXT:    [[BF_SHL:%.*]] = shl i32 [[BF_VALUE2]], 2
; SROA-NEXT:    [[BF_CLEAR3:%.*]] = and i32 [[BF_SET]], -13
; SROA-NEXT:    [[BF_SET4:%.*]] = or i32 [[BF_CLEAR3]], [[BF_SHL]]
; SROA-NEXT:    [[BF_RESULT_SHL5:%.*]] = shl i32 [[BF_VALUE2]], 30
; SROA-NEXT:    [[BF_RESULT_ASHR6:%.*]] = ashr i32 [[BF_RESULT_SHL5]], 30
; SROA-NEXT:    store volatile i32 [[BF_SET4]], ptr [[F]], align 4
; SROA-NEXT:    ret void
;
; CLANG-LABEL: define dso_local void @Set
; CLANG-SAME: (ptr noundef [[F:%.*]], i32 noundef [[A:%.*]], i32 noundef [[B:%.*]]) {
; CLANG-NEXT:  entry:
; CLANG-NEXT:    [[TMP_SROA_0_0_COPYLOAD:%.*]] = load volatile i32, ptr [[F]], align 4
; CLANG-NEXT:    [[BF_VALUE:%.*]] = and i32 [[A]], 3
; CLANG-NEXT:    [[BF_CLEAR:%.*]] = and i32 [[TMP_SROA_0_0_COPYLOAD]], -16
; CLANG-NEXT:    [[BF_SET:%.*]] = or i32 [[BF_CLEAR]], [[BF_VALUE]]
; CLANG-NEXT:    [[BF_VALUE2:%.*]] = shl i32 [[B]], 2
; CLANG-NEXT:    [[BF_SHL:%.*]] = and i32 [[BF_VALUE2]], 12
; CLANG-NEXT:    [[BF_SET4:%.*]] = or i32 [[BF_SET]], [[BF_SHL]]
; CLANG-NEXT:    store volatile i32 [[BF_SET4]], ptr [[F]], align 4
; CLANG-NEXT:    ret void
;
entry:
  %f.addr = alloca ptr, align 8
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %tmp = alloca %struct.F, align 4
  store ptr %f, ptr %f.addr, align 8
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load ptr, ptr %f.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %tmp, ptr align 4 %0, i64 4, i8 2)
  %1 = load i32, ptr %a.addr, align 4
  %bf.load = load i32, ptr %tmp, align 4
  %bf.value = and i32 %1, 3
  %bf.clear = and i32 %bf.load, -4
  %bf.set = or i32 %bf.clear, %bf.value
  store i32 %bf.set, ptr %tmp, align 4
  %bf.result.shl = shl i32 %bf.value, 30
  %bf.result.ashr = ashr i32 %bf.result.shl, 30
  %2 = load i32, ptr %b.addr, align 4
  %bf.load1 = load i32, ptr %tmp, align 4
  %bf.value2 = and i32 %2, 3
  %bf.shl = shl i32 %bf.value2, 2
  %bf.clear3 = and i32 %bf.load1, -13
  %bf.set4 = or i32 %bf.clear3, %bf.shl
  store i32 %bf.set4, ptr %tmp, align 4
  %bf.result.shl5 = shl i32 %bf.value2, 30
  %bf.result.ashr6 = ashr i32 %bf.result.shl5, 30
  %3 = load ptr, ptr %f.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %3, ptr align 4 %tmp, i64 4, i8 1)
  ret void
}
