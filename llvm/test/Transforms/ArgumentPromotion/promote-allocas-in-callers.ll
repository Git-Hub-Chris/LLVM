; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=argpromotion < %s | FileCheck %s

; Tests where we do not perform promotion of alloca in caller:

define internal i32 @callee_nopromote_1(ptr nocapture readonly %p) {
; CHECK-LABEL: define internal i32 @callee_nopromote_1(
; CHECK-SAME: i32 [[P_0_VAL:%.*]]) {
; CHECK-NEXT:    [[SUM:%.*]] = add i32 [[P_0_VAL]], [[P_0_VAL]]
; CHECK-NEXT:    ret i32 [[SUM]]
;
  %p.val = load i32, ptr %p
  %sum = add i32 %p.val, %p.val
  ret i32 %sum
}

define i32 @caller_nopromote_1() {
; CHECK-LABEL: define i32 @caller_nopromote_1() {
; CHECK-NEXT:    [[P:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 1, ptr [[P]], align 4
; CHECK-NEXT:    [[P_VAL:%.*]] = load i32, ptr [[P]], align 4
; CHECK-NEXT:    [[RES:%.*]] = call i32 @callee_nopromote_1(i32 [[P_VAL]])
; CHECK-NEXT:    call void @clobber(ptr [[P]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %p = alloca i32
  store i32 1, ptr %p
  %res = call i32 @callee_nopromote_1(ptr %p)
  call void @clobber(ptr %p)
  ret i32 %res
}

define internal i32 @callee_nopromote_2(ptr %p1, ptr nocapture readonly %p2) {
; CHECK-LABEL: define internal i32 @callee_nopromote_2(
; CHECK-SAME: ptr [[P1:%.*]], ptr nocapture readonly [[P2:%.*]]) {
; CHECK-NEXT:    call void @clobber(ptr [[P1]])
; CHECK-NEXT:    [[P1_VAL:%.*]] = load i32, ptr [[P1]], align 4
; CHECK-NEXT:    [[P2_VAL:%.*]] = load i32, ptr [[P2]], align 4
; CHECK-NEXT:    [[SUM:%.*]] = add i32 [[P1_VAL]], [[P2_VAL]]
; CHECK-NEXT:    ret i32 [[SUM]]
;
  call void @clobber(ptr %p1)
  %p1.val = load i32, ptr %p1
  %p2.val = load i32, ptr %p2
  %sum = add i32 %p1.val, %p2.val
  ret i32 %sum
}

define i32 @caller_nopromote_2() {
; CHECK-LABEL: define i32 @caller_nopromote_2() {
; CHECK-NEXT:    [[P:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 1, ptr [[P]], align 4
; CHECK-NEXT:    [[RES:%.*]] = call i32 @callee_nopromote_2(ptr [[P]], ptr [[P]])
; CHECK-NEXT:    ret i32 [[RES]]
;
  %p = alloca i32
  store i32 1, ptr %p
  %res = call i32 @callee_nopromote_2(ptr %p, ptr %p)
  ret i32 %res
}

; Tests where we do perform promotion of alloca in caller:

define internal i32 @callee_promote_1(ptr nocapture readonly %p) {
; CHECK-LABEL: define internal i32 @callee_promote_1(
; CHECK-SAME: i32 [[P_0_VAL:%.*]]) {
; CHECK-NEXT:    [[SUM:%.*]] = add i32 [[P_0_VAL]], [[P_0_VAL]]
; CHECK-NEXT:    ret i32 [[SUM]]
;
  %p.val = load i32, ptr %p
  %sum = add i32 %p.val, %p.val
  ret i32 %sum
}

define i32 @caller_promote_1() {
; CHECK-LABEL: define i32 @caller_promote_1() {
; CHECK-NEXT:    [[RES:%.*]] = call i32 @callee_promote_1(i32 1)
; CHECK-NEXT:    ret i32 [[RES]]
;
  %p = alloca i32
  store i32 1, ptr %p
  %res = call i32 @callee_promote_1(ptr %p)
  ret i32 %res
}

; Make sure we handle multiple uses of an alloca.
define internal i32 @callee_promote_2(ptr nocapture readonly %p1, ptr nocapture readonly %p2) {
; CHECK-LABEL: define internal i32 @callee_promote_2(
; CHECK-SAME: i32 [[P1_0_VAL:%.*]], i32 [[P2_0_VAL:%.*]]) {
; CHECK-NEXT:    [[SUM:%.*]] = add i32 [[P1_0_VAL]], [[P2_0_VAL]]
; CHECK-NEXT:    ret i32 [[SUM]]
;
  %p1.val = load i32, ptr %p1
  %p2.val = load i32, ptr %p2
  %sum = add i32 %p1.val, %p2.val
  ret i32 %sum
}

define i32 @caller_promote_2() {
; CHECK-LABEL: define i32 @caller_promote_2() {
; CHECK-NEXT:    [[RES:%.*]] = call i32 @callee_promote_2(i32 1, i32 1)
; CHECK-NEXT:    ret i32 [[RES]]
;
  %p = alloca i32
  store i32 1, ptr %p
  %res = call i32 @callee_promote_2(ptr %p, ptr %p)
  ret i32 %res
}

declare void @clobber(ptr)
