; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt < %s -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S | FileCheck %s

; Jump threading should not be able to duplicate a block containing inline
; assembly, since we do not know what is in the inline-asm instruction.

define void @foo(i32 %n.arg, ptr %b.arg, ptr %c.arg) {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: i32 [[N_ARG:%.*]], ptr [[B_ARG:%.*]], ptr [[C_ARG:%.*]]) {
; CHECK-NEXT:  L.entry:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i32 [[N_ARG]], 0
; CHECK-NEXT:    br i1 [[TMP0]], label [[L_B0000:%.*]], label [[L_B0002:%.*]]
; CHECK:       L.B0002:
; CHECK-NEXT:    store ptr null, ptr [[C_ARG]], align 8
; CHECK-NEXT:    store ptr null, ptr [[B_ARG]], align 8
; CHECK-NEXT:    br label [[L_B0000]]
; CHECK:       L.B0000:
; CHECK-NEXT:    call void asm sideeffect " .LABEL: \0A\09", ""()
; CHECK-NEXT:    br i1 [[TMP0]], label [[L_B0001:%.*]], label [[L_B0003:%.*]]
; CHECK:       L.B0003:
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ARG]], align 8
; CHECK-NEXT:    call void @bar(ptr [[TMP1]])
; CHECK-NEXT:    br label [[L_B0001]]
; CHECK:       L.B0001:
; CHECK-NEXT:    ret void
;
L.entry:
  %0 = icmp eq i32 %n.arg, 0
  br i1 %0, label %L.B0000, label %L.B0002

L.B0002:                                          ; preds = %L.entry
  store ptr null, ptr %c.arg
  store ptr null, ptr %b.arg
  br label %L.B0000

L.B0000:                                          ; preds = %L.B0002, %L.entry
  call void asm sideeffect "   .LABEL: \0A\09", ""()
  br i1 %0, label %L.B0001, label %L.B0003

L.B0003:                                          ; preds = %L.B0000
  %1 = load ptr, ptr %b.arg
  call void @bar(ptr %1)
  br label %L.B0001

L.B0001:                                          ; preds = %L.B0003, %L.B0000
  ret void
}

declare void @bar(ptr)
