# Test handling of addends taken from the relocated word or instruction
# in AArch64 relocation sections of type SHT_REL. These can be generated
# by assemblers other than LLVM, in particular the legacy 'armasm'.
#
# llvm-mc will only generate SHT_RELA when targeting AArch64. So to make
# an input file with SHT_REL, we assemble our test source file, then
# round-trip via YAML and do some seddery to change the type of the
# relocation section. Since all the relocations were made manually with
# .reloc directives containing no addend, this succeeds.

# RUN: llvm-mc -filetype=obj -triple=aarch64 %S/Inputs/aarch64-reloc-implicit-addend.s -o %t_rela.o
# RUN: obj2yaml %t_rela.o -o %t_rela.yaml
# RUN: sed "s/\.rela/\.rel/;s/SHT_RELA/SHT_REL/" %t_rela.yaml > %t_rel.yaml
# RUN: yaml2obj %t_rel.yaml -o %t_rel.o
# RUN: llvm-mc -filetype=obj -triple=aarch64 %S/Inputs/aarch64-reloc-implicit-addend-targets.s -o %t_targets.o
# RUN: ld.lld %t_rel.o %t_targets.o -o %t --section-start=.data=0x100000 --section-start=.text=0x200000
# RUN: llvm-objdump -s %t | FileCheck %s --check-prefix=DATA
# RUN: llvm-objdump -d %t | FileCheck %s --check-prefix=CODE

# DATA: Contents of section .data:

# Absolute data relocations
# 0x7777777777777777 + 0x1234567887654321 = 0x89abcdeffedcba98
# 0x88888888 + 0x12344321 = 0x9abccba9
# 0x9999 + 0x1234 = 0xabcd
# DATA-NEXT:  100000 98badcfe efcdab89 a9cbbc9a cdab

# Relative data relocations, each subtracting the address of the relocated word
# 0x100000 + 0x1234567887654321 - 0x100010 = 0x1234567887654311
# 0x100000 + 0x12344321 - 0x100018 = 0x12344309
# 0x100000 + 0x1234 - 0x10001c = 0x1218
# DATA-NEXT:  100010 11436587 78563412 09433412 1812

# CODE: 0000000000200000 <_start>:

# 0x7777777777777777 + 0x1234 = 0x77777777777789ab
# CODE-NEXT:  200000: d2913560      mov     x0, #0x89ab
# CODE-NEXT:  200004: f2aeeee0      movk    x0, #0x7777, lsl #16
# CODE-NEXT:  200008: f2ceeee0      movk    x0, #0x7777, lsl #32
# CODE-NEXT:  20000c: f2eeeee0      movk    x0, #0x7777, lsl #48

# 0x77ffffffffffff77 + 0x1234 = 0x78000000000011ab
# CODE-NEXT:  200010: d2823560      mov     x0, #0x11ab            
# CODE-NEXT:  200014: f2a00000      movk    x0, #0x0, lsl #16
# CODE-NEXT:  200018: f2c00000      movk    x0, #0x0, lsl #32
# CODE-NEXT:  20001c: f2ef0000      movk    x0, #0x7800, lsl #48

# 0x7777777777777777 - 0x1234 = 0x7777777777776543
# CODE-NEXT:  200020: d28ca860      mov     x0, #0x6543
# CODE-NEXT:  200024: f2aeeee0      movk    x0, #0x7777, lsl #16
# CODE-NEXT:  200028: f2ceeee0      movk    x0, #0x7777, lsl #32
# CODE-NEXT:  20002c: f2eeeee0      movk    x0, #0x7777, lsl #48

# These values are all 0x245678 + 2^n, except the last one, where the
# set bit of the addend is the top bit, counting as negative, i.e. we expect
# 0x254678 - 0x100000 = 0x145678.
# CODE-NEXT:  200030: 3022b240      adr     x0, 0x245679
# CODE-NEXT:  200034: 5022b220      adr     x0, 0x24567a
# CODE-NEXT:  200038: 1022b220      adr     x0, 0x24567c
# CODE-NEXT:  20003c: 1022b220      adr     x0, 0x245680
# CODE-NEXT:  200040: 1062b1c0      adr     x0, 0x2c5678
# CODE-NEXT:  200044: 10a2b1a0      adr     x0, 0x145678

# Now we expect pairs of adrp/adr that load the same values.
# CODE-NEXT:  200048: b0000220      adrp    x0, 0x245000
# CODE-NEXT:  20004c: 9119e400      add     x0, x0, #0x679
# CODE-NEXT:  200050: b0000220      adrp    x0, 0x245000
# CODE-NEXT:  200054: 9119e800      add     x0, x0, #0x67a
# CODE-NEXT:  200058: b0000220      adrp    x0, 0x245000
# CODE-NEXT:  20005c: 9119f000      add     x0, x0, #0x67c
# CODE-NEXT:  200060: b0000220      adrp    x0, 0x245000
# CODE-NEXT:  200064: 911a0000      add     x0, x0, #0x680
# CODE-NEXT:  200068: b0000620      adrp    x0, 0x2c5000
# CODE-NEXT:  20006c: 9119e000      add     x0, x0, #0x678
# CODE-NEXT:  200070: b0fffa20      adrp    x0, 0x145000
# CODE-NEXT:  200074: 9119e000      add     x0, x0, #0x678
# The final test of adrp+add, loading 0x245678 + 0xfedcb - 0x100000 = 0x244443
# CODE-NEXT:  200078: 90000220      adrp    x0, 0x244000
# CODE-NEXT:  20007c: 91110c00      add     x0, x0, #0x443

# PC-relative loads with the same offsets as the ADRs above, except
# for the first two, which can't be expressed by pc-relative LDR with an
# offset shifted left 2.
# CODE-NEXT:  200080: 1822afe0      ldr     w0, 0x24567c
# CODE-NEXT:  200084: 1822afe0      ldr     w0, 0x245680
# CODE-NEXT:  200088: 1862af80      ldr     w0, 0x2c5678
# CODE-NEXT:  20008c: 18a2af60      ldr     w0, 0x145678

# Branch target 0x200100 plus powers of 2, except 2^15 which is negative.
# CODE-NEXT:  200090: b7f803a1      tbnz    x1, #0x3f, 0x200104
# CODE-NEXT:  200094: b7f003a1      tbnz    x1, #0x3e, 0x200108
# CODE-NEXT:  200098: b7ea0341      tbnz    x1, #0x3d, 0x204100
# CODE-NEXT:  20009c: b7e40321      tbnz    x1, #0x3c, 0x1f8100

# Same again, except we go up to 2^20.
# CODE-NEXT:  2000a0: b5000322      cbnz    x2, 0x200104
# CODE-NEXT:  2000a4: 54000320      b.eq    0x200108
# CODE-NEXT:  2000a8: b44002c2      cbz     x2, 0x280100
# CODE-NEXT:  2000ac: 548002a6      b.vs    0x100100

# And for BL and B, we go up to 2^25.
# CODE-NEXT:  2000b0: 94780015      bl      0x2000104
# CODE-NEXT:  2000b4: 94780015      bl      0x2000108
# CODE-NEXT:  2000b8: 94b80012      bl      0x3000100
# CODE-NEXT:  2000bc: 97f80011      bl      0x100
# CODE-NEXT:  2000c0: 14780011      b       0x2000104
# CODE-NEXT:  2000c4: 14780011      b       0x2000108
# CODE-NEXT:  2000c8: 14b8000e      b       0x3000100
# CODE-NEXT:  2000cc: 17f8000d      b       0x100
