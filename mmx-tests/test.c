#include <fenv.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

#include "gen_orig.h"
#include "gen_new.h"


// A bunch of helper functions for the code in gen_test.inc
#define m128_to_m64(x) (__m64)((__v2di)(x))[0]

#define arraysize(a) (sizeof(a) / sizeof(*a))

static void dump_mem(void *ptr, int nbytes) {
  for (int i = 0; i < nbytes; ++i) {
    printf(" %02x", ((unsigned char*)ptr)[i]);
  }
  printf("\n");
}

static int get_exc_flags() {
  return fetestexcept(FE_ALL_EXCEPT | __FE_DENORM);
}

static void clear_exc_flags() {
  feclearexcept(FE_ALL_EXCEPT | __FE_DENORM);
}

static void dump_exc_flags(int exc_flags) {
  printf("%x", exc_flags);
  if (exc_flags & FE_INEXACT)
    printf(" inexact");
  if (exc_flags & FE_DIVBYZERO)
    printf(" divbyzero");
  if (exc_flags & FE_UNDERFLOW)
    printf(" underflow");
  if (exc_flags & FE_OVERFLOW)
    printf(" overflow");
  if (exc_flags & FE_INVALID)
    printf(" invalid");
  if (exc_flags & __FE_DENORM)
    printf(" denormal");
}

static void dump_result(int orig_exc, int new_exc, void *orig_data, void *new_data, int nbytes) {
  printf(" orig_exc = ");
  dump_exc_flags(orig_exc);
  printf(" new_exc = ");
  dump_exc_flags(new_exc);
  printf("\n");
  printf(" orig");
  dump_mem(orig_data, nbytes);
  printf(" new ");
  dump_mem(new_data, nbytes);
}

static void check_mismatch(const char *name, int orig_exc, int new_exc,
                           void *orig_data, void *new_data, int nbytes,
                           const char *printf_fmt, ...) {
  if (orig_exc != new_exc || memcmp(orig_data, new_data, nbytes)) {
    va_list args;
    va_start(args, printf_fmt);
    printf("mismatch %s(", name);
    vprintf(printf_fmt, args);
    printf("):\n");
    dump_result(orig_exc, new_exc, orig_data, new_data, nbytes);
    va_end(args);
  }
}

unsigned short short_vals[] = {
  0x0000,
  0x0001,
  0xffee,
  0xffff,
};

unsigned long long padding_mmx_vals[] = {
  0x0000000000000000LL,
  0xffffffffffffffffLL,
  0x7fc000007fc00000LL, // float nan nan
  0xfff8000000000000LL, // -nan
};

unsigned long long mmx_vals[] = {
  0x0000000000000000LL,
  0x0000000000000001LL,
  0x0000000000000002LL,
  0x0000000000000003LL,
  0x0000000000000004LL,
  0x0000000000000005LL,
  0x0000000000000006LL,
  0x0000000000000007LL,
  0x0000000000000008LL,
  0x0000000000000009LL,
  0x000000000000000aLL,
  0x000000000000000bLL,
  0x000000000000000cLL,
  0x000000000000000dLL,
  0x000000000000000eLL,
  0x000000000000000fLL,
  0x0000000000000100LL,
  0x0000000000010000LL,
  0x0000000001000000LL,
  0x0000000100000000LL,
  0x0000010000000000LL,
  0x0001000000000000LL,
  0x0100000000000000LL,
  0x0101010101010101LL,
  0x0102030405060708LL,
  0x1234567890abcdefLL,
  0x007f007f007f007fLL,
  0x7f007f007f007f00LL,
  0x7f7f7f7f7f7f7f7fLL,
  0x8000800080008000LL,
  0x0080008000800080LL,
  0x8080808080808080LL,
  0x7fff7fff7fff7fffLL,
  0x8000800080008000LL,
  0x7fffffff7fffffffLL,
  0x8000000080000000LL,
  0x0000777700006666LL,
  0x7777000066660000LL,
  0x0000ffff0000eeeeLL,
  0xffff0000eeee0000LL,
  0x7700660055004400LL,
  0x0077006600550044LL,
  0xff00ee00dd00cc00LL,
  0x00ff00ee00dd00ccLL,
  0xffffffffffffffffLL,
  0x3ff0000000000000LL, // 1.0
  0x3ff8000000000000LL, // 1.5
  0x4000000000000000LL, // 2.0
  0x3f8000003fc00000LL, // float 1.0 1.5
  0x3fc0000040000000LL, // float 1.5 2.0
  0x7ff0000000000000LL, // inf
  0x7f8000007f800000LL, // float inf inf
  0xfff0000000000000LL, // -inf
  0xff800000ff800000LL, // float -inf -inf
  0x7ff8000000000000LL, // nan
  0x7fc000007fc00000LL, // float nan nan
  0xfff8000000000000LL, // -nan
  0xffc00000ffc00000LL, // float -nan -nan
};

struct __attribute__((aligned(sizeof(__m128)))) Mem {
  __m64 dummy;
  __m64 m64;
} mem, mem2;

// These 3 could be autogenerated...but I didn't add support for stores to the generator.
void test_stores() {
 // void _mm_storeh_pi(__m64 * arg_0, __m128 arg_1);
  for(int l0 = 0; l0 < arraysize(mmx_vals); ++l0) {
    for(int l1 = 0; l1 < arraysize(mmx_vals); ++l1) {
      clear_exc_flags();
      orig__mm_storeh_pi(&mem.m64, (__m128)(__m128i){mmx_vals[l0], mmx_vals[l1]});
      int orig_exc = get_exc_flags();
      clear_exc_flags();
      new__mm_storeh_pi(&mem2.m64, (__m128)(__m128i){mmx_vals[l0], mmx_vals[l1]});
      int new_exc = get_exc_flags();
      check_mismatch("_mm_storeh_pi", orig_exc, new_exc, &mem.m64, &mem2.m64, sizeof(__m64),
                     "&mem.m64, (__m128i){%016llx, %016llx},", mmx_vals[l0], mmx_vals[l1]);
    }
  }

  // void _mm_storel_pi(__m64 * arg_0, __m128 arg_1);
  for(int l0 = 0; l0 < arraysize(mmx_vals); ++l0) {
    for(int l1 = 0; l1 < arraysize(mmx_vals); ++l1) {
      clear_exc_flags();
      orig__mm_storel_pi(&mem.m64, (__m128)(__m128i){mmx_vals[l0], mmx_vals[l1]});
      int orig_exc = get_exc_flags();
      clear_exc_flags();
      new__mm_storel_pi(&mem2.m64, (__m128)(__m128i){mmx_vals[l0], mmx_vals[l1]});
      int new_exc = get_exc_flags();
      check_mismatch("_mm_storeh_pi", orig_exc, new_exc, &mem.m64, &mem2.m64, sizeof(__m64),
                     "&mem.m64, (__m128i){%016llx, %016llx},", mmx_vals[l0], mmx_vals[l1]);
    }
  }

  // void _mm_stream_pi(__m64 * arg_0, __m64 arg_1);
  for(int l0 = 0; l0 < arraysize(mmx_vals); ++l0) {
    clear_exc_flags();
    orig__mm_stream_pi(&mem.m64, (__m64)mmx_vals[l0]);
    int orig_exc = get_exc_flags();
    clear_exc_flags();
    new__mm_stream_pi(&mem2.m64, (__m64)mmx_vals[l0]);
    int new_exc = get_exc_flags();
    check_mismatch("_mm_stream_pi", orig_exc, new_exc, &mem.m64, &mem2.m64, sizeof(__m64),
                   "&mem.m64, %016llx,", mmx_vals[l0]);
  }
}

// Test that the nominally 64-bit maskmove doesn't trap at the edges of
// non-writable memory, despite being implemented by a 128-bit write.
void test_maskmove() {
  // Create a page memory with an inaccessible page on either side.
  char *map = mmap(0, 3 * 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
  if (!map)
    abort();
  if (mprotect(map, 4096, PROT_NONE))
    abort();
  if (mprotect(map + 4096 * 2, 4096, PROT_NONE))
    abort();
  long long init_val = 0xffeeddccbbaa9900;
  long long expected = 0x11ee3344bb669900;
  for (int offset = 0; offset < 16+9; ++offset) {
    char *copy_location = map + 4096 + (offset > 16 ? 4096 - 32 + offset : offset);
    memcpy(copy_location, &init_val, 8);
    new__mm_maskmove_si64((__m64)0x1122334455667788LL, (__m64)0x8000808000800000, copy_location);
    long long result;
    memcpy(&result, copy_location, 8);
    if (memcmp(&expected, &result, 8) != 0) {
      printf("test_maskmove: wrong value was stored %llx vs %llx\n", result, expected);
      return;
    }
  }
}

void test_generated() {
  #include "gen_test.inc"
}

int main() {
  int rounding[] = {FE_TONEAREST, FE_UPWARD, FE_DOWNWARD, FE_TOWARDZERO};
  for (int i = 0; i < 4; ++i)
  {
    fesetround(rounding[i]);

    test_maskmove();
    test_stores();
    test_generated();
  }
}
